' NeReLaBasic - Three-Body Problem Simulation (Vectorized)
' --------------------------------------------------------
' This program simulates the motion of three bodies interacting
' under their mutual gravitational attraction. It uses initial
' conditions that lead to a stable "figure-8" choreography.
'
' Method: Vectorized calculation of forces and numerical
' integration using the Semi-Implicit Euler method.

'=============================================================================
' 1. FUNCTION TO CALCULATE ACCELERATIONS (VECTORIZED)
'=============================================================================
FUNC CalculateAccelerations(Pos, Mass, G, softening)
    ' This function calculates the acceleration on each body using matrix operations,
    ' completely replacing the need for nested loops.

    ' Extract X and Y position vectors from the main Position matrix.
    PosX = SLICE(Pos, 1, 0) ' Get column 0 (all x-positions)
    PosY = SLICE(Pos, 1, 1) ' Get column 1 (all y-positions)

    ' 1. Calculate matrices of relative positions (rx, ry) for all pairs.
    '    The OUTER(A, B, "-") creates a matrix where M(i,j) = B(j) - A(i).
    rx_matrix = OUTER(PosX, PosX, "-")
    ry_matrix = OUTER(PosY, PosY, "-")

    ' 2. Calculate the matrix of squared distances between all pairs.
    '    The softening factor prevents division by zero if bodies get too close.
    dist_sq_matrix = rx_matrix^2 + ry_matrix^2 + softening

    ' 3. Calculate the matrix of inverse cube distances.
    '    This is a common optimization: F = G*m*r / r^3 instead of F = G*m*r / (r^2 * r)
    inv_dist_cube = dist_sq_matrix ^ -1.5

    ' 4. Create a matrix of the influencing masses for each interaction.
    '    M(i,j) will contain Mass[j].
    Mass_j_matrix = OUTER(Mass * 0, Mass, "+")

    ' 5. Calculate the full matrix of acceleration components for X and Y.
    '    The formula for the acceleration on body 'i' from body 'j' is:
    '    a_ij = G * Mass_j * (Pos_j - Pos_i) / |Pos_j - Pos_i|^3
    '    This is now calculated for all pairs at once.
    AccX_components = G * Mass_j_matrix * rx_matrix * inv_dist_cube
    AccY_components = G * Mass_j_matrix * ry_matrix * inv_dist_cube

    ' 6. Sum the forces.
    '    To get the total acceleration on each body, we sum the influences from all
    '    other bodies. This is equivalent to summing along the rows of our component matrices.
    '    The dimension parameter '1' tells SUM to reduce along the rows, giving a column vector.
    '    We explicitly set the diagonal (self-interaction) to 0 before summing.
    AccX_total = SUM(AccX_components * ((OUTER(IOTA(3)-1, IOTA(3)-1, "=")*-1)+1), 1)
    AccY_total = SUM(AccY_components * ((OUTER(IOTA(3)-1, IOTA(3)-1, "=")*-1)+1), 1)

    ' 7. Combine the final X and Y acceleration vectors back into one matrix.
    '    SUM returns a column matrix (e.g., 3x1), but MVLET expects a 1D vector.
    '    We must flatten the result of SUM into a 1D vector before using it.
    AccX_flat = RESHAPE(AccX_total, [NUM_BODIES])
    AccY_flat = RESHAPE(AccY_total, [NUM_BODIES])

    ' Create the final 3x2 acceleration matrix by inserting the flat vectors.
    FinalAcc = RESHAPE([0], [NUM_BODIES, DIMS])
    FinalAcc = MVLET(FinalAcc, 1, 0, AccX_flat)
    FinalAcc = MVLET(FinalAcc, 1, 1, AccY_flat)
    
    RETURN FinalAcc
ENDFUNC

'=============================================================================
' 2. SETUP AND DEFINE SIMULATION CONSTANTS
'=============================================================================
PRINT "--- 1. Setting up Simulation Constants ---"
G = 1.0           ' Gravitational constant
DT = 0.001        ' Time step for the simulation
NUM_STEPS = 2000  ' Number of steps to simulate
PRINT_EVERY = 200 ' How often to print the state
NUM_BODIES = 3
DIMS = 2          ' 2D simulation (x, y)
SOFTENING = 0.001 ' Softening factor to prevent division by zero

'=============================================================================
' 3. INITIALIZE DATA STRUCTURES AND SET INITIAL CONDITIONS
'=============================================================================
PRINT "--- 2. Initializing Body States (Mass, Position, Velocity) ---"

' Set masses (equal mass system)
Mass = [1, 1, 1]

' Set initial positions for the "figure-8" orbit using direct array assignment.
Pos = RESHAPE([0.97000436, -0.24308753, -0.97000436, 0.24308753, 0.0, 0.0], [3, 2])

' Set initial velocities for the "figure-8" orbit
Vel = RESHAPE([0.466203685, 0.43236573, 0.466203685, 0.43236573, -0.93240737, -0.86473146], [3, 2])

'=============================================================================
' 4. THE MAIN SIMULATION LOOP
'=============================================================================
PRINT "--- 3. Starting Simulation ---"
PRINT "Step, Body, PosX, PosY" ' CSV Header for easy plotting

FOR A = 1 TO NUM_STEPS
    ' First, calculate the accelerations on all bodies based on their current positions.
    Acc = CalculateAccelerations(Pos, Mass, G, SOFTENING)

    ' Next, update the velocity and position for each body.
    ' These operations are inherently vectorized.
    Vel = Vel + Acc * DT
    Pos = Pos + Vel * DT

    ' Periodically print the state of the system
    IF A MOD PRINT_EVERY = 0 THEN
        FOR i = 0 TO NUM_BODIES - 1
            PRINT A; ","; i; ","; Pos[i, 0]; ","; Pos[i, 1]
        NEXT i
    ENDIF
NEXT A

PRINT
PRINT "--- Simulation Complete ---"

' --- End of File ---

' NeReLaBasic - Three-Body Problem Simulation (Vectorized)
' --------------------------------------------------------
' This program simulates the motion of three bodies interacting
' under their mutual gravitational attraction. It uses initial
' conditions that lead to a stable "figure-8" choreography.
'
' Method: Vectorized calculation of forces and numerical
' integration using the Semi-Implicit Euler method.

'=============================================================================
' 1. FUNCTION TO CALCULATE ACCELERATIONS (VECTORIZED)
'=============================================================================
FUNC CalculateAccelerations(Pos, Mass, G, softening)
    ' This function calculates the acceleration on each body using matrix operations,
    ' completely replacing the need for nested loops.

    ' Extract X and Y position vectors from the main Position matrix.
    PosX = SLICE(Pos, 1, 0) ' Get column 0 (all x-positions)
    PosY = SLICE(Pos, 1, 1) ' Get column 1 (all y-positions)

    ' 1. Calculate matrices of relative positions (rx, ry) for all pairs.
    '    The OUTER(A, B, "-") creates a matrix where M(i,j) = B(j) - A(i).
    rx_matrix = OUTER(PosX, PosX, "-")
    ry_matrix = OUTER(PosY, PosY, "-")

    ' 2. Calculate the matrix of squared distances between all pairs.
    '    The softening factor prevents division by zero if bodies get too close.
    dist_sq_matrix = rx_matrix^2 + ry_matrix^2 + softening

    ' 3. Calculate the matrix of inverse cube distances.
    '    This is a common optimization: F = G*m*r / r^3 instead of F = G*m*r / (r^2 * r)
    inv_dist_cube = dist_sq_matrix ^ -1.5

    ' 4. Calculate the matrix of acceleration magnitudes.
    '    First, create a matrix of influencing masses using OUTER.
    Mass_j_matrix = OUTER(Mass * 0, Mass, "+")
    accel_mag_matrix = G * Mass_j_matrix * inv_dist_cube

    ' 5. Calculate the final acceleration components for X and Y.
    '    This is the acceleration magnitude multiplied by the direction vector (rx, ry).
    AccX_components = accel_mag_matrix * rx_matrix
    AccY_components = accel_mag_matrix * ry_matrix

    ' 6. Sum the forces.
    '    To get the total acceleration on each body, we sum the influences from all
    '    other bodies. This is equivalent to summing along the rows of our component matrices.
    '    The dimension parameter '1' tells SUM to reduce along the rows.
    AccX_total = SUM(AccX_components, 1)
    AccY_total = SUM(AccY_components, 1)

    ' 7. Combine the final X and Y acceleration vectors back into one matrix.
    '    SUM returns a column matrix (e.g., 3x1), but MVLET expects a 1D vector.
    '    We must flatten the result of SUM into a 1D vector before using it.
    AccX_flat = RESHAPE(AccX_total, [NUM_BODIES])
    AccY_flat = RESHAPE(AccY_total, [NUM_BODIES])

    ' Create the final 3x2 acceleration matrix by inserting the flat vectors.
    FinalAcc = RESHAPE([0], [NUM_BODIES, DIMS])
    FinalAcc = MVLET(FinalAcc, 1, 0, AccX_flat)
    FinalAcc = MVLET(FinalAcc, 1, 1, AccY_flat)
    
    RETURN FinalAcc
ENDFUNC

'=============================================================================
' 2. SETUP AND DEFINE SIMULATION CONSTANTS
'=============================================================================
PRINT "--- 1. Setting up Simulation Constants ---"

' --- GRAPHICS CONSTANTS ---
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
VIEW_SCALE = 220   ' Scales the simulation space to fit the screen (pixels per unit)
BODY_RADIUS = 5    ' Radius of the circle for each body in pixels
TRAIL_LENGTH = 50  ' How many past positions to store for the trail effect

G = 1.0           ' Gravitational constant
DT = 0.001        ' Time step for the simulation
NUM_STEPS = 2000  ' Number of steps to simulate
PRINT_EVERY = 200 ' How often to print the state
NUM_BODIES = 3
DIMS = 2          ' 2D simulation (x, y)
SOFTENING = 0.001 ' Softening factor to prevent division by zero

'=============================================================================
' 3. INITIALIZE DATA STRUCTURES AND SET INITIAL CONDITIONS
'=============================================================================
PRINT "--- 2. Initializing Body States (Mass, Position, Velocity) ---"

DIM Trail[3, TRAIL_LENGTH, 2] ' For each body, store X and Y for TRAIL_LENGTH steps
trail_idx = 0 ' The current index in our trail's circular buffer

' Set masses (equal mass system)
Mass = [1, 1, 1]

' Set initial positions for the "figure-8" orbit using direct array assignment.
Pos = RESHAPE([0.97000436, -0.24308753, -0.97000436, 0.24308753, 0.0, 0.0], [3, 2])

' Set initial velocities for the "figure-8" orbit
Vel = RESHAPE([0.466203685, 0.43236573, 0.466203685, 0.43236573, -0.93240737, -0.86473146], [3, 2])

SCREEN SCREEN_WIDTH, SCREEN_HEIGHT, "Three-Body Problem"

'=============================================================================
' 4. THE MAIN SIMULATION LOOP
'=============================================================================
PRINT "--- 3. Starting Simulation ---"
PRINT "Step, Body, PosX, PosY" ' CSV Header for easy plotting

FOR A = 1 TO NUM_STEPS
    ' First, calculate the accelerations on all bodies based on their current positions.
    Acc = CalculateAccelerations(Pos, Mass, G, SOFTENING)

    ' Next, update the velocity and position for each body.
    ' These operations are inherently vectorized.
    Vel = Vel + Acc * DT
    Pos = Pos + Vel * DT

    FOR i = 0 TO NUM_BODIES - 1
        ' Store the new position in the trail buffer
        Trail[i, trail_idx, 0] = Pos[i, 0]
        Trail[i, trail_idx, 1] = Pos[i, 1]
    NEXT i

    trail_idx = (trail_idx + 1) MOD TRAIL_LENGTH

   ' --- DRAWING LOGIC ---
    ' Clear the screen to black
    CLS 0, 0, 0

    ' Draw the trails first, so the bodies appear on top
    FOR i = 0 TO NUM_BODIES - 1
        ' Set trail color based on body index
        IF i = 0 THEN r = 100: g = 20: b = 20 
        IF i = 1 THEN r = 20: g = 100: b = 20 
        IF i = 2 THEN r = 20: g = 20: b = 100 
        
        FOR t = 0 TO TRAIL_LENGTH - 2
            ' Get two consecutive points from the trail buffer
            idx1 = (trail_idx + t) MOD TRAIL_LENGTH
            idx2 = (trail_idx + t + 1) MOD TRAIL_LENGTH

            ' Get simulation coordinates
            sim_x1 = Trail[i, idx1, 0] : sim_y1 = Trail[i, idx1, 1]
            sim_x2 = Trail[i, idx2, 0] : sim_y2 = Trail[i, idx2, 1]
            
            ' Don't draw lines from uninitialized parts of the trail buffer
            IF sim_x1 <> 0 AND sim_x2 <> 0 THEN
                ' Convert simulation coords to screen coords for both points
                screen_x1 = (sim_x1 * VIEW_SCALE) + (SCREEN_WIDTH / 2)
                screen_y1 = (sim_y1 * VIEW_SCALE) + (SCREEN_HEIGHT / 2)
                screen_x2 = (sim_x2 * VIEW_SCALE) + (SCREEN_WIDTH / 2)
                screen_y2 = (sim_y2 * VIEW_SCALE) + (SCREEN_HEIGHT / 2)
                LINE screen_x1, screen_y1, screen_x2, screen_y2, r, g, b
            ENDIF
        NEXT t
    NEXT i


    ' Draw the bodies themselves
    FOR i = 0 TO NUM_BODIES - 1
        ' Get the body's current simulation coordinates
        sim_x = Pos[i, 0]
        sim_y = Pos[i, 1]

        ' Convert simulation coordinates to screen pixel coordinates
        screen_x = (sim_x * VIEW_SCALE) + (SCREEN_WIDTH / 2)
        screen_y = (sim_y * VIEW_SCALE) + (SCREEN_HEIGHT / 2)

        ' Set color based on body index
        IF i = 0 THEN r = 255: g = 50: b = 50 
        IF i = 1 THEN r = 50: g = 255: b = 50 
        IF i = 2 THEN r = 50: g = 50: b = 255 

        ' Draw the body as a circle
        CIRCLE screen_x, screen_y, BODY_RADIUS, r, g, b
    NEXT i

    ' Flip the screen to show what we've drawn
    SCREENFLIP
    SLEEP 1

NEXT A

PRINT
PRINT "--- Simulation Complete ---"

' --- End of File ---

' ==========================================================
' == Using the ADAM Optimizer in jdBasic
' == Goal: Train a neural network to learn the function y = x^3 - x^2 + 2
' ==========================================================

DLLIMPORT "aifunc"

CLS
PRINT "--- Neural Network with ADAM Optimizer ---"
PRINT

' --- 1. Generate Training Data ---
' We will create data points for the function y = x^3 - x^2 + 2
' so the network can learn to approximate it.
PRINT "Generating training data..."

' Generate 100 data points from x = -2 to x = 2
NUM_POINTS = 100
X_FLAT_DATA = []
Y_FLAT_DATA = []
FOR I = 0 TO NUM_POINTS - 1
    ' Create x values between -2 and 2
    x_val = -2 + 4 * (I / (NUM_POINTS - 1))
    ' Calculate y = x^3 - x^2 + 2, with some small random noise
    y_val = (x_val^3) - (x_val^2) + 2 + (RND(1) - 0.5) * 0.1
    
    ' Append scalar values to flat 1D arrays first.
    ' Using APPEND with an array as the second argument would flatten the result.
    X_FLAT_DATA = APPEND(X_FLAT_DATA, x_val)
    Y_FLAT_DATA = APPEND(Y_FLAT_DATA, y_val)
NEXT I

' Reshape the flat data into 2D column vectors (matrices of size N x 1).
' This is the correct way to create rank-2 tensors for MATMUL.
X_DATA = RESHAPE(X_FLAT_DATA, [NUM_POINTS, 1])
Y_DATA = RESHAPE(Y_FLAT_DATA, [NUM_POINTS, 1])

' Convert the 2D data arrays into Tensors. This is crucial for
' enabling automatic differentiation (autodiff).
INPUTS = TENSOR.FROM(X_DATA)
TARGETS = TENSOR.FROM(Y_DATA)

PRINT "Data generated."
PRINT


' --- 2. Define the Neural Network Model ---
' The model is a standard Map data structure that holds the layers.
MODEL = {}

' We'll use a simple feed-forward network with two hidden layers.
' Input -> Dense(20) -> ReLU -> Dense(20) -> ReLU -> Output
MODEL{"layer1"} = TENSOR.CREATE_LAYER("DENSE", {"input_size": 1, "units": 20})
MODEL{"layer2"} = TENSOR.CREATE_LAYER("DENSE", {"input_size": 20, "units": 20})
MODEL{"output_layer"} = TENSOR.CREATE_LAYER("DENSE", {"input_size": 20, "units": 1})

PRINT "Model created."
PRINT


' --- 3. Setup the ADAM Optimizer and Training Parameters ---
' Here we create the ADAM optimizer instead of SGD.
' We provide the learning rate and the beta parameters.
' beta1: decay rate for the first moment estimate (momentum)
' beta2: decay rate for the second moment estimate (RMSprop)
ADAM_OPTIONS = {"learning_rate": 0.01, "beta1": 0.9, "beta2": 0.999}
OPTIMIZER = TENSOR.CREATE_OPTIMIZER("ADAM", ADAM_OPTIONS)

EPOCHS = 8000 ' The number of times to iterate over the training data.

PRINT "ADAM Optimizer configured."
PRINT


' --- 4. Define Helper Functions ---

' The forward pass function takes the model and an input tensor,
' and returns the model's prediction. It uses the ReLU activation function.
FUNC MODEL_FORWARD(current_model, input_tensor)
    ' Pass through Layer 1
    l1_out = TENSOR.MATMUL(input_tensor, current_model{"layer1"}{"weights"}) + current_model{"layer1"}{"bias"}
    l1_activated = TENSOR.RELU(l1_out)
    
    ' Pass through Layer 2
    l2_out = TENSOR.MATMUL(l1_activated, current_model{"layer2"}{"weights"}) + current_model{"layer2"}{"bias"}
    l2_activated = TENSOR.RELU(l2_out)

    ' Pass through Output Layer (no activation, as it's a regression problem)
    output = TENSOR.MATMUL(l2_activated, current_model{"output_layer"}{"weights"}) + current_model{"output_layer"}{"bias"}
    
    RETURN output
ENDFUNC

' The loss function measures how wrong the model's predictions are.
' We use Mean Squared Error (MSE), which is standard for regression.
FUNC MSE_LOSS(predicted_tensor, actual_tensor)
    errors = actual_tensor - predicted_tensor
    squared_errors = errors ^ 2
    ' Return the average of the squared errors.
    RETURN SUM(squared_errors) / LEN(TENSOR.TOARRAY(errors))[0]
ENDFUNC


' --- 5. The Training Loop ---
PRINT "--- Starting Training with ADAM ---"

FOR epoch = 1 TO EPOCHS
    ' --- a) Forward Pass ---
    ' Get the model's current predictions for the training inputs.
    PREDICTIONS = MODEL_FORWARD(MODEL, INPUTS)

    ' --- b) Calculate Loss ---
    ' Calculate how far off the predictions are from the actual targets.
    ' The result is a Tensor that is the root of our computation graph.
    LOSS = MSE_LOSS(PREDICTIONS, TARGETS)
    
    ' --- c) Backpropagation ---
    ' This one command calculates the gradient (derivative) of the loss
    ' with respect to every parameter (weight and bias) in the model.
    TENSOR.BACKWARD LOSS

    ' --- d) Update Parameters with ADAM ---
    ' The TENSOR.UPDATE function will see that the optimizer is of type "ADAM"
    ' and apply the correct update logic, managing the momentum (m) and
    ' variance (v) states internally.
    'MODEL = TENSOR.UPDATE(MODEL, OPTIMIZER)

    MODEL = ADAM.UPDATE(MODEL, OPTIMIZER)

    ' --- e) Print Progress ---
    IF epoch MOD 500 = 0 THEN
        PRINT "Epoch:"; epoch; ", Loss:"; TENSOR.TOARRAY(LOSS)[0]
    ENDIF
NEXT epoch

PRINT
PRINT "--- Training Complete ---"
PRINT


' --- 6. Verification and Final Predictions ---
PRINT "--- Verifying Final Predictions ---"
final_predictions = MODEL_FORWARD(MODEL, INPUTS)
final_predictions_array = TENSOR.TOARRAY(final_predictions)

PRINT "Sample of Inputs, Targets, and Predictions:"
PRINT "-------------------------------------------"
PRINT "  Input  |  Target  | Predicted"
PRINT "-------------------------------------------"
FOR i = 0 TO 9
    ' *** FIX: Corrected array indexing from [0,i] to [i,0] ***
    x_val_str = FORMAT$("{:7.3f}", X_DATA[i,0])
    y_val_str = FORMAT$("{:8.3f}", Y_DATA[i,0])
    pred_val_str = FORMAT$("{:9.3f}", final_predictions_array[i,0])
    PRINT x_val_str; " |"; y_val_str; " |"; pred_val_str
NEXT i
PRINT "-------------------------------------------"

' --- End of File ---

' =================================================================
' NeReLa Basic Program to Read Records from an Access Database
' =================================================================

' --- IMPORTANT ---
' You must change this path to the full, correct path of your
' Access database file.
db_path = "Orders.accdb"
table_name = "Orders"

PRINT "--- Access Database Reader ---"
PRINT "Connecting to: "; db_path
PRINT ""

' 1. Create the necessary ADO COM objects.
'    The Connection object manages the connection to the database.
'    The Recordset object holds the data retrieved from a table.
conn = CREATEOBJECT("ADODB.Connection")
rs = CREATEOBJECT("ADODB.Recordset")

' 2. Define the connection string.
'    For modern .accdb files, you need the "ACE" provider.
'    This requires the Microsoft Access Database Engine to be installed.
conn_str = "Provider=Microsoft.ACE.OLEDB.12.0;Data Source=" + db_path

' 3. Open the connection to the database.
'    This is like logging into the database file.
stop
conn.Open(conn_str)
PRINT "Connection successful."

' 4. Define the SQL query to select all records from the table.
sql = "SELECT * FROM " + table_name

' 5. Open the recordset.
'    This executes the SQL query on the opened connection and
'    loads the results into the 'rs' object. The cursor is now
'    at the first record.
rs.Open(sql, conn)

SETLOCALE "de-DE"
PRINT "Recordset opened. Reading data..."
PRINT "-------------------------------------"

' 6. Loop through all the records in the recordset.
'    The loop continues as long as the 'EOF' (End of File)
'    property of the recordset is FALSE.
IF NOT rs.EOF THEN
    rs.MoveFirst()
    DO WHILE NOT rs.EOF
        ' Access the data in each field by its name using the Fields collection.

        record_id = rs.Fields("ID").Value
        customer = rs.Fields("Customer").Value
        order_date = rs.Fields("OrderDate").Value
        order_Amount = rs.Fields("Amount").Value
        order_Price = rs.Fields("Price").Value
        order_Description = rs.Fields("Description").Value

        ' Print the retrieved values for the current record.
        ' Calculate the total for the current record
        order_Total = order_Amount * order_Price
        ' Define the format string.
        ' {:.2Lf} formats the number with a comma for thousands and 2 decimal places using locales
        format_str = "ID: {:6} | Customer: {:20} | Date: {} | Amount: {:.2f} | Price: {:.2Lf} {} | Total: {:>10.2Lf} {} | Desc: {}"

        ' Use the FORMAT$ function to create the output string
        output_line = FORMAT$(format_str, record_id, customer, order_date, order_Amount, order_Price, "€", order_Total, "€", order_Description)

        ' Print the single formatted line
        PRINT output_line

        ' Move the cursor to the next record in the set.
        rs.MoveNext()
    LOOP
ELSE 
    PRINT "No Records"
ENDIF 
PRINT "-------------------------------------"
PRINT "End of records."

' 7. Clean up by closing the recordset and the connection.
'    This releases the file lock and frees up resources.
rs.Close()
conn.Close()

PRINT "Database connection closed. Program finished."


' --- End of File ---

' ANDALSO, ORELSE Tests
' 

PRINT "--- Vectorized OR vs. Scalar ORELSE ---"
PRINT

arr1 = [TRUE, FALSE, FALSE, TRUE]
arr2 = [FALSE, TRUE, FALSE, TRUE]

' Vectorized OR works element-wise
PRINT "arr1 OR arr2: "; arr1 OR arr2
PRINT

' --- Short-circuiting example ---
DIM MyMap AS MAP
MyMap = NULL

' ORELSE works on scalars and short-circuits to prevent an error
' This works because (2 > 1) is TRUE, so the right side is never checked.
STOP
IF (2 > 1) ORELSE MAP.EXISTS(MyMap, "key") THEN
    PRINT "ORELSE short-circuited correctly!"
ENDIF


PRINT 
PRINT "--- ANDALSO test"
PRINT 

DIM MyMap AS MAP
MyMap = NULL ' Simulate a map that might not be initialized

' This would CRASH with normal AND because it tries MyMap{"key"}
' IF MyMap <> NULL AND MyMap{"key"} = "test" THEN PRINT "OK"

' This runs SAFELY with ANDALSO
IF MyMap <> NULL ANDALSO MAP.EXISTS(MyMap, "key") THEN
    PRINT "Map exists and has the key."
ELSE
    PRINT "Map is NULL or does not have the key. (No crash)"
ENDIF

' --- ORELSE Example ---
DIM IsAdmin AS BOOL
IsAdmin = TRUE

FUNC ExpensiveCheck()
    PRINT "(Expensive check was run!)"
    RETURN TRUE
ENDFUNC

PRINT
PRINT "Checking permissions..."
' With ORELSE, ExpensiveCheck() is never called because IsAdmin is already true.
IF IsAdmin ORELSE ExpensiveCheck() THEN
    PRINT "Access Granted."
ENDIF

' --- End of File ---

' --- Recursion and Higher-Order Functions in jdBasic ---
CLS
' ===============================================
' A recursive function calls itself to solve a problem.
' ===============================================
PRINT "--- Recursion Demo: Factorial ---"

FUNC FACTORIAL(N)
    ' The base case is essential to stop the recursion.
    IF N <= 1 THEN RETURN 1

    ' The recursive step: call itself with a smaller problem.
    RETURN N * FACTORIAL(N - 1)
ENDFUNC

PRINT "Factorial of 6 is:"; FACTORIAL(6)
PRINT ""

PRINT "--- Higher-Order Function Demo: MAP ---"
' =========================================================
' A higher-order function takes another function as an argument.
' =========================================================

' A simple function we can pass to AMAP.
FUNC SQUARE_IT(X)
    RETURN X * X
ENDFUNC

' Another simple function.
FUNC ADD_ONE(X)
    RETURN X + 1
ENDFUNC

' The MAP function. It takes a function reference (FN) and an
' array (ARR), and applies FN to every element of ARR.
FUNC AMAP(FN, ARR)
    ' Create a copy of the array to hold the results.
    RESULT_ARR = ARR

    FOR I = 0 TO LEN(ARR) - 1
        ' Get one element from the array.
        ELEMENT = ARR[I]
        ' Call the passed-in function with the element.
        NEW_VALUE = FN(ELEMENT)
        ' Store the new value back in our result array.
        RESULT_ARR[I] = NEW_VALUE
    NEXT I

    RETURN RESULT_ARR
ENDFUNC

' --- Now, let's use our MAP function! ---
V = IOTA(5)
PRINT "Original Vector V: "; V

' Pass the SQUARE_IT function to MAP
SQUARED_V = AMAP(SQUARE_IT@, V)
PRINT "After MAP(SQUARE_IT@, V): "; SQUARED_V

' Pass the ADD_ONE function to MAP
ADDED_V = AMAP(ADD_ONE@, V)
PRINT "After MAP(ADD_ONE@, V):  "; ADDED_V

' --- End of File ---

' --- APL/Functional Style Prime Sieve (Set-based) ---

PRINT "--- Calculating Primes using Set Difference ---"
LIMIT = 1000

' 1. Define the set of potential primes: all odd numbers from 3 up to the limit.
ODDS = (IOTA(LIMIT/2) - 1) * 2 + 3
PRINT "Generated " ; LEN(ODDS); " odd numbers to test."

' 2. Define the set of potential prime factors.
FACTORS = []
FOR I = 3 TO SQR(LIMIT) STEP 2
    FACTORS = APPEND(FACTORS, I)
NEXT I

' 3. Define the set of composite numbers by iterating through the factors.
COMPOSITES = []
FOR I = 0 TO LEN(FACTORS)-1
    P = FACTORS[I]
    ' Generate all odd multiples of P starting from P*P.
    FOR J = P * P TO LIMIT STEP P * 2
        COMPOSITES = APPEND(COMPOSITES, J)
    NEXT J
NEXT I

' 4. Calculate the difference between the two sets.
ODD_PRIMES = DIFF(ODDS, COMPOSITES)

' 5. The final list of primes is 2, plus all the odd primes.
ALL_PRIMES = APPEND([2], ODD_PRIMES) 

PRINT "Primes up to "; LIMIT; " are:"
PRINT ALL_PRIMES

' --- End of File ---

' ===================================================================
' == AI Artist for jdBasic
' ==
' == This program demonstrates the power of jdBasic's built-in
' == Tensor engine by training a Transformer Language Model to
' == generate abstract art.
' ==
' == HOW IT WORKS:
' == 1. A simple "drawing language" is defined (e.g., "C 100 200 50 ...").
' == 2. A Transformer LLM is trained on examples of this language.
' == 3. The trained model is then used to generate new, unique
' ==    sequences of drawing commands, creating generative art.
' ===================================================================

'TRON
TROFF

' ===================================================================
' == SHARED HELPER FUNCTIONS (Used by Training and Inference)
' ===================================================================

FUNC FORWARD_PASS(current_model, input_tokens)
    SEQ_LEN = LEN(input_tokens)[0] ' <-- FIX: Use LEN(...)[0]
    HIDDEN_DIM = LEN(TENSOR.TOARRAY(current_model{"output_norm"}{"bias"}))[1]

    one_hot = ONE_HOT_ENCODE_MATRIX(input_tokens, VOCAB_SIZE)
    x = MATMUL(TENSOR.FROM(one_hot), current_model{"embedding"}{"weights"})

    x = x + TENSOR.POSITIONAL_ENCODING(SEQ_LEN, HIDDEN_DIM)

    FOR i = 0 TO LEN(current_model{"layers"})[0] - 1 ' <-- FIX: Use LEN(...)[0]
        layer = current_model{"layers"}[i]
        norm1_out = TENSOR.LAYERNORM(x, layer{"norm1"}{"gain"}, layer{"norm1"}{"bias"})
        
        Q = MATMUL(norm1_out, layer{"attention"}{"Wq"})
        K = MATMUL(norm1_out, layer{"attention"}{"Wk"})
        V = MATMUL(norm1_out, layer{"attention"}{"Wv"})
        
        attn_scores = MATMUL(Q, TENSOR.FROM(TRANSPOSE(TENSOR.TOARRAY(K)))) / SQR(HIDDEN_DIM)
        attn_probs = TENSOR.SOFTMAX(attn_scores, TRUE)
        attention_output = MATMUL(attn_probs, V)
        x = x + attention_output

        norm2_out = TENSOR.LAYERNORM(x, layer{"norm2"}{"gain"}, layer{"norm2"}{"bias"})
        ffn1_out = TENSOR.RELU(MATMUL(norm2_out, layer{"ffn1"}{"weights"}) + layer{"ffn1"}{"bias"})
        ffn2_out = MATMUL(ffn1_out, layer{"ffn2"}{"weights"}) + layer{"ffn2"}{"bias"}
        x = x + ffn2_out
    NEXT i
    
    final_norm = TENSOR.LAYERNORM(x, current_model{"output_norm"}{"gain"}, current_model{"output_norm"}{"bias"})
    logits = MATMUL(final_norm, current_model{"output"}{"weights"}) + current_model{"output"}{"bias"}
    
    RETURN logits
ENDFUNC

FUNC ONE_HOT_ENCODE_MATRIX(token_array, size)
    rows = LEN(token_array)[0] ' <-- FIX: Extract the scalar size
    matrix = RESHAPE([0], [rows, size])
    FOR r = 0 TO rows - 1
        matrix[r, token_array[r]] = 1
    NEXT r
    RETURN matrix
ENDFUNC

FUNC SAMPLE(probs_array)
    r = RND(1) 
    cdf = 0
    num_probs = LEN(probs_array)[0] ' <-- FIX: Use LEN(...)[0]
    FOR i = 0 TO num_probs - 1
        cdf = cdf + probs_array[i]
        IF r < cdf THEN RETURN i
    NEXT i
    RETURN num_probs - 1
ENDFUNC

' --- A smarter sampling function to improve generation quality ---
FUNC SAMPLE_TOP_K(probs_array, k)
    ' 1. Get the indices that would sort the probabilities in descending order
    sorted_indices = REVERSE(grade(probs_array))
    
    ' 2. Take the top 'k' indices and their corresponding probabilities
    top_indices = TAKE(k, sorted_indices)
    top_probs = []
    FOR i = 0 TO LEN(top_indices)[0] - 1
        top_probs = APPEND(top_probs, probs_array[top_indices[i]])
    NEXT i
    
    ' 3. Re-normalize the top k probabilities so they sum to 1
    total_prob = SUM(top_probs)
    IF total_prob = 0 THEN RETURN top_indices[0] ' Failsafe
    renormalized_probs = top_probs / total_prob
    
    ' 4. Sample from this smaller, cleaner distribution
    r = RND(1)
    cdf = 0
    num_probs = LEN(renormalized_probs)[0]
    FOR i = 0 TO num_probs - 1
        cdf = cdf + renormalized_probs[i]
        IF r < cdf THEN RETURN top_indices[i] ' Return the ORIGINAL index
    NEXT i
    RETURN top_indices[num_probs - 1] ' Failsafe
ENDFUNC


' ===================================================================
' == PART 1: TRAINING THE AI MODEL (The "Brain" of the Artist)
' ===================================================================
'
' NOTE: This section is commented out by default because training
' can take time. A pre-trained 'art_model.json' is expected to
' exist. To train the model yourself, simply remove the initial
' GOTO statement and the REM comments.

'GOTO SKIP_TRAINING
l = len(dir$("_art_model.json"))[0]
if len(dir$("_art_model.json"))[0] > 0 then
    input "Training data found, skip learning?"; a$
    if ucase$(left$(a$,1)) = "Y" then
        GOTO SKIP_TRAINING
    endif
ELSE
    Print "No training data found."
Endif

REM --- Training Data: A simple language for drawing shapes ---
REM Format: "TYPE X Y SIZE R G B;"
REM C=Circle, L=Line, R=Rectangle
TRAINING_DATA$ = "C 400 300 100 255 0 0; L 100 100 700 500 0 255 0; R 200 150 400 300 120 0 255;"
TRAINING_DATA$ = TRAINING_DATA$ + "C 150 450 80 255 255 0; L 50 550 750 50 255 0 255; R 600 100 120 0 255 255;"
TRAINING_DATA$ = TRAINING_DATA$ + "L 200 150 21 55 0 150 0; R 400 500 180 50 75 0 150; L 300 200 420 120 150 255 0;"
PRINT "--- 1. Setting up Vocabulary and Training Data ---"
' Create a vocabulary of all unique characters in our drawing language.

REM --- Procedurally Generate a Large, Varied Training Dataset ---
PRINT "--- 1. Generating Diverse Training Data ---"

REM TXTWRITER "artai_training_data.txt", TRAINING_DATA$

VOCAB = []
FOR I = 0 TO LEN(TRAINING_DATA$) - 1
    CHAR$ = MID$(TRAINING_DATA$, I + 1, 1)
    IS_IN_VOCAB = 0
    if LEN(VOCAB) > 0 then
        FOR J = 0 TO LEN(VOCAB) - 1
            IF VOCAB[J] = CHAR$ THEN
                IS_IN_VOCAB = 1
                EXITFOR
            ENDIF
        NEXT J
    Endif
    IF IS_IN_VOCAB = 0 THEN
        VOCAB = APPEND(VOCAB, CHAR$)
    ENDIF
NEXT I

VOCAB_SIZE = LEN(VOCAB)[0] ' <-- FIX: Extract the scalar size

' Create a Map for fast character-to-index lookup.
VOCAB_MAP = {}
FOR I = 0 TO VOCAB_SIZE - 1
    VOCAB_MAP{VOCAB[I]} = I
NEXT I

PRINT "Vocabulary Size:"; VOCAB_SIZE

' Prepare the input and target sequences for the LLM.
' The target is the input shifted by one character.
INPUT_TOKENS = TENSOR.TOKENIZE(TRAINING_DATA$, VOCAB_MAP)
TARGET_TOKENS = APPEND(TAKE(LEN(INPUT_TOKENS)[0] - 1, DROP(1, INPUT_TOKENS)), 0) ' <-- FIX: Use LEN(...)[0]

PRINT "--- 2. Building the Transformer Model ---"
HIDDEN_DIM = 64
EMBEDDING_DIM = HIDDEN_DIM
NUM_LAYERS = 2 ' A 2-layer Transformer is sufficient for this task

MODEL = {}
MODEL{"embedding"} = TENSOR.CREATE_LAYER("EMBEDDING", {"vocab_size": VOCAB_SIZE, "embedding_dim": EMBEDDING_DIM})
MODEL{"output_norm"} = TENSOR.CREATE_LAYER("LAYER_NORM", {"dim": HIDDEN_DIM})
MODEL{"output"} = TENSOR.CREATE_LAYER("DENSE", {"input_size": HIDDEN_DIM, "units": VOCAB_SIZE})
MODEL{"layers"} = []
FOR i = 0 TO NUM_LAYERS - 1
    layer = {}
    layer{"attention"} = TENSOR.CREATE_LAYER("ATTENTION", {"embedding_dim": EMBEDDING_DIM})
    layer{"norm1"} = TENSOR.CREATE_LAYER("LAYER_NORM", {"dim": HIDDEN_DIM})
    layer{"ffn1"} = TENSOR.CREATE_LAYER("DENSE", {"input_size": HIDDEN_DIM, "units": HIDDEN_DIM * 2})
    layer{"ffn2"} = TENSOR.CREATE_LAYER("DENSE", {"input_size": HIDDEN_DIM * 2, "units": HIDDEN_DIM})
    layer{"norm2"} = TENSOR.CREATE_LAYER("LAYER_NORM", {"dim": HIDDEN_DIM})
    MODEL{"layers"} = APPEND(MODEL{"layers"}, layer)
NEXT i

' --- 3. The Training Loop ---
PRINT "--- 3. Starting Training (this may take a few minutes)... ---"
OPTIMIZER = TENSOR.CREATE_OPTIMIZER("SGD", {"learning_rate": 0.05})
EPOCHS = 5000

FOR EPI = 1 TO EPOCHS
    ' Forward pass through the entire model
    logits_tensor = FORWARD_PASS(MODEL, INPUT_TOKENS)
    
    ' Prepare target tensor
    target_one_hot = ONE_HOT_ENCODE_MATRIX(TARGET_TOKENS, VOCAB_SIZE)
    target_tensor = TENSOR.FROM(target_one_hot)
    
    ' Calculate loss, backpropagate, and update the model
    loss_tensor = TENSOR.CROSS_ENTROPY_LOSS(logits_tensor, target_tensor)
    TENSOR.BACKWARD loss_tensor
    MODEL = TENSOR.UPDATE(MODEL, OPTIMIZER)

    IF EPI MOD 100 = 0 THEN
        PRINT "Epoch:"; EPI; ", Loss: "; TENSOR.TOARRAY(loss_tensor)[0]
    ENDIF
NEXT EPI

PRINT "--- 4. Training Complete. Saving model... ---"
' --- FIX: Save the vocabulary along with the model parameters ---
MODEL{"vocab"} = VOCAB
MODEL{"vocab_map"} = VOCAB_MAP
TENSOR.SAVEMODEL MODEL, "_art_model.json"
PRINT "Model saved to _art_model.json"
PRINT ""


' ===================================================================
' == PART 2: THE GENERATIVE ARTIST
' ===================================================================

SKIP_TRAINING:

' --- 2. Setup Graphics and Generation Loop ---
SCREEN 800, 600, "jdBasic AI Artist"
CLS 10, 15, 20 ' Dark background

PRINT "--- AI Artist Initializing ---"
' --- 1. Load the Pre-Trained Model ---
PRINT "Loading pre-trained AI model 'art_model.json'..."
ARTIST_MODEL = TENSOR.LOADMODEL("_art_model.json")
IF LEN(ARTIST_MODEL) = 0 THEN
    PRINT "ERROR: Could not load 'art_model.json'."
    PRINT "Please run the training section first by removing the GOTO."
    END
ENDIF
PRINT "Model loaded successfully."
' --- FIX: Re-create the vocabulary from the loaded model file ---
VOCAB = ARTIST_MODEL{"vocab"}
VOCAB_MAP = ARTIST_MODEL{"vocab_map"}
VOCAB_SIZE = LEN(VOCAB)[0] ' <-- FIX: Re-initialize global vars from loaded model

generated_command$ = "C" ' Start with a seed to generate a Circle
PRINT "Seed command: '"; generated_command$; "'"
PRINT "Press ESC to quit."

DO
    ' --- a. Generate the next character using the AI ---
    inference_tokens = TENSOR.TOKENIZE(generated_command$, VOCAB_MAP)
    all_logits = FORWARD_PASS(ARTIST_MODEL, inference_tokens)
    
    ' Get the logits for the very last character in the sequence
    last_logits_vec = SLICE(TENSOR.TOARRAY(all_logits), 0, LEN(inference_tokens)[0] - 1) 
    TEMPERATURE = 1.2
    last_logits_vec = last_logits_vec / TEMPERATURE

    ' Convert logits to probabilities and sample the next character
    'probs = TENSOR.SOFTMAX(TENSOR.FROM(last_logits_vec))
    'next_token_id = SAMPLE(TENSOR.TOARRAY(probs))
    probs = TENSOR.TOARRAY(TENSOR.SOFTMAX(TENSOR.FROM(last_logits_vec))) 
    next_token_id = SAMPLE_TOP_K(probs, 5)
    next_char$ = VOCAB[next_token_id]
    
    generated_command$ = generated_command$ + next_char$
   
    ' --- b. Check if a command is complete ---
    IF next_char$ = ";" THEN
        PRINT "AI Generated Command: "; generated_command$
        
        ' --- c. Parse and Execute the Drawing Command ---
        parts = SPLIT(TRIM$(LEFT$(generated_command$, LEN(generated_command$)-1)), " ")
        
        IF LEN(parts)[0] = 7 THEN 
            TYPE$ = UCASE$(parts[0])
            x = VAL(parts[1]) 
            y = VAL(parts[2]) 
            size = VAL(parts[3])
            r = VAL(parts[4]) 
            g = VAL(parts[5]) 
            b = VAL(parts[6])

            IF TYPE$ = "C" THEN
                CIRCLE x, y, size, r, g, b
            ENDIF
            IF TYPE$ = "R" THEN
                RECT x, y, size, size/2, r, g, b, TRUE
            ENDIF
            IF TYPE$ = "L" THEN
                ' For lines, interpret 'size' as a second point offset
                LINE x, y, x+size, y+size, r, g, b
            ENDIF
            
            SCREENFLIP
            generated_command$ = parts[0]
        ELSE 
            PRINT "Invalid command generated. Resetting seed..."
            ' Reset with a random shape to encourage variety
            shape_choice = RND(1)
            IF shape_choice < 0.33 THEN
                generated_command$ = "C"
            ELSEIF shape_choice < 0.66 THEN 
                generated_command$ = "R"
            ELSE
                generated_command$ = "L"
            ENDIF
        ENDIF
    ENDIF

    ' Check for exit key
    IF INKEY$() = CHR$(27) THEN EXITDO
    SLEEP 10 ' Small delay
LOOP
' --- End of File ---

' ================================================================
' NeReLaBasic (jdBasic) ASYNC/AWAIT Demonstration
' This program shows how to run tasks in the background
' and wait for their results without blocking the main program.
' ================================================================

PRINT "--- Starting ASYNC/AWAIT Demonstration ---"
PRINT

' ================================================================
'          A S Y N C   F U N C T I O N   D E F I N I T I O N S
' ================================================================

' This function simulates a "download" that takes some time.
ASYNC FUNC DOWNLOADFILE(url$, duration)
  PRINT "  [Task 1] Starting download from "; url$
  ' Simulate work by looping
  FOR i = 1 TO duration
    PRINT "  [Task 1] ... downloading chunk "; i; " of "; duration; " ..."
  NEXT i
  PRINT "  [Task 1] Download finished."
  RETURN "Download of " + url$ + " successful."
ENDFUNC

' This function simulates a "data processing" job.
ASYNC FUNC PROCESSDATA(dataset$, duration)
  PRINT "    [Task 2] Starting to process data from "; dataset$
  ' Simulate work by looping
  FOR i = 1 TO duration
    PRINT "    [Task 2] ... processing record block "; i; " of "; duration; " ..."
  NEXT i
  PRINT "    [Task 2] Data processing finished."
  RETURN "Processed " + dataset$ + " and found 42 insights."
ENDFUNC

' --- Step 1: Start the asynchronous tasks ---
' We call two ASYNC functions. This creates two new tasks that
' start running in the background. The calls return immediately
' with a "Task Reference" handle, which we store in variables.

PRINT "Main: Kicking off background tasks..."
task1 = DOWNLOADFILE("https://example.com/data.zip", 5)
task2 = PROCESSDATA("some_large_dataset.csv", 3)
PRINT "Main: Background tasks have been started."
PRINT

' --- Step 2: Main program continues its own work ---
' While the background tasks are running, the main program is not
' blocked. It can continue to execute other commands.
PRINT "Main: Now doing other work while tasks run in the background."
FOR i = 1 TO 4
  PRINT "Main: ... processing main task step "; i; " ..."
  ' In a real program, you could do other things here,
  ' like updating the UI or handling user input.
NEXT i
PRINT "Main: Finished with other work."
PRINT

' --- Step 3: Wait for the tasks to complete and get results ---
' Now we use AWAIT. This will pause the main program until the
' specified task is finished. It then returns the value from
' the task's RETURN statement.

PRINT "Main: Now waiting for Task 1 to complete..."
result1 = AWAIT task1
PRINT "Main: Task 1 finished with result: '"; result1; "'"
PRINT

PRINT "Main: Now waiting for Task 2 to complete..."
result2 = AWAIT task2
PRINT "Main: Task 2 finished with result: '"; result2; "'"
PRINT

PRINT "--- Demonstration Complete ---"


' --- End of File ---

PRINT "--- Bitwise Operator Showcase ---"
PRINT

A = %0101  
B = %0011  

PRINT "A = 5 (%0101), B = 3 (%0011)"
PRINT "-----------------------------"
PRINT "A BAND B: "; A BAND B  ' %0101 AND %0011 = %0001 -> 1
PRINT "A BOR B:  "; A BOR B   ' %0101 OR  %0011 = %0111 -> 7
PRINT "A BXOR B: "; A BXOR B  ' %0101 XOR %0011 = %0110 -> 6
PRINT

PRINT "--- Vectorized Example ---"
V = [1, 2, 3, 4, 5]
PRINT "V = "; V
PRINT "V BAND 3: "; V BAND 3
PRINT "V BOR 10: "; V BOR 10 ' 10 is %1010


' --- End of File ---

' ===================================================================
' == jdBASIC Generic Data Plotting Library
' == Version 2.0
' ===================================================================
'
' This library provides a subroutine, DATA_PLOTTER, to draw a 2D
' bar or line chart from a 2D data array (e.g., from CSVREADER).
'
' -------------------------------------------------------------------

SUB DATA_PLOTTER(DATA_ARRAY, PLOT_TYPE$, TITLE$, X_LABEL_COL, Y_VALUE_COL)
    ' --- Parameters ---
    ' DATA_ARRAY:    A 2D array containing the data to plot.
    ' PLOT_TYPE$:    A string, either "BAR" or "LINE".
    ' TITLE$:        A string to display as the title of the graph.
    ' X_LABEL_COL:   The 0-based column index for x-axis labels.
    ' Y_VALUE_COL:   The 0-based column index for y-axis values.
    ' ----------------------------------------------------------------

    ' --- Configuration ---
    SCREEN_W = 800
    SCREEN_H = 600
    MARGIN = 80 ' Increased margin for labels
    
    PLOT_W = SCREEN_W - (2 * MARGIN)
    PLOT_H = SCREEN_H - (2 * MARGIN)
    PLOT_LEFT = MARGIN
    PLOT_TOP = MARGIN
    PLOT_BOTTOM = PLOT_TOP + PLOT_H

    ' --- Data Extraction & Analysis ---
    X_LABELS = SLICE(DATA_ARRAY, 1, X_LABEL_COL)
    Y_VALUES = SLICE(DATA_ARRAY, 1, Y_VALUE_COL)
    
    NUM_POINTS = LEN(Y_VALUES)[0] 'Len returns a Array, we need a scalar!
    IF NUM_POINTS = 0 THEN
        PRINT "Error: No data to plot."
        RETURN
    ENDIF

    Y_MAX = MAX(Y_VALUES) * 1.1 ' Find max value and add 10% for padding
    Y_MIN = 0 ' For bar and line charts, Y-axis starts at 0

    ' --- Coordinate Mapping Functions ---
    func MAP_Y(y)
        return PLOT_BOTTOM - (y - Y_MIN) * PLOT_H / (Y_MAX - Y_MIN)
    endfunc

    ' --- Drawing ---
    SCREEN SCREEN_W, SCREEN_H, "jdBASIC Data Plotter"
    CLS 20, 30, 40 ' Dark background

    ' Draw Title and Bounding Box
    TEXT 10, 10, TITLE$, 220, 220, 255
    RECT PLOT_LEFT, PLOT_TOP, PLOT_W, PLOT_H, 60, 90, 110, FALSE

    ' Draw Y-Axis and its labels
    LINE PLOT_LEFT, PLOT_TOP, PLOT_LEFT, PLOT_BOTTOM, 120, 150, 170
    TEXT PLOT_LEFT - 40, PLOT_BOTTOM - 15, STR$(Y_MIN), 180, 180, 180
    TEXT PLOT_LEFT - 40, PLOT_TOP, STR$(Y_MAX), 180, 180, 180
    
    ' Draw X-Axis
    LINE PLOT_LEFT, PLOT_BOTTOM, PLOT_LEFT + PLOT_W, PLOT_BOTTOM, 120, 150, 170

    ' --- Plotting Logic ---
    IF UCASE$(PLOT_TYPE$) = "BAR" THEN
        BAR_WIDTH = (PLOT_W / NUM_POINTS) * 0.8 ' 80% of available space
        BAR_SPACING = (PLOT_W / NUM_POINTS) * 0.2

        FOR i = 0 TO NUM_POINTS - 1
            x_pos = PLOT_LEFT + (i * (BAR_WIDTH + BAR_SPACING)) + BAR_SPACING
            bar_height = MAP_Y(0) - MAP_Y(Y_VALUES[i])
            
            RECT x_pos, MAP_Y(Y_VALUES[i]), BAR_WIDTH, bar_height, 100, 180, 255, TRUE
            ' Draw X Label centered under the bar
            TEXT x_pos, PLOT_BOTTOM + 10, X_LABELS[i], 200, 200, 200
        NEXT i
    ENDIF
    IF UCASE$(PLOT_TYPE$) = "LINE" THEN
        POINT_SPACING = PLOT_W / (NUM_POINTS - 1)
        
        FOR i = 0 TO NUM_POINTS - 2 ' Loop to second to last point
            x1 = PLOT_LEFT + i * POINT_SPACING
            y1 = MAP_Y(Y_VALUES[i])
            
            x2 = PLOT_LEFT + (i + 1) * POINT_SPACING
            y2 = MAP_Y(Y_VALUES[i+1])

            LINE x1, y1, x2, y2, 255, 100, 100
            ' Draw X Label under the point
            TEXT x1 - 10, PLOT_BOTTOM + 10, X_LABELS[i], 200, 200, 200
        NEXT i
        ' Draw the label for the very last point
        last_x = PLOT_LEFT + (NUM_POINTS - 1) * POINT_SPACING
        TEXT last_x - 10, PLOT_BOTTOM + 10, X_LABELS[NUM_POINTS-1], 200, 200, 200
    ENDIF

    SCREENFLIP
ENDSUB


' ===================================================================
' ==                  EXAMPLE USAGE
' ===================================================================


PRINT "Plotting Bar Chart from sales_data.csv..."
SALES_ARRAY = CSVREADER("sales_data.csv", ",", TRUE) ' True = has header
PRINT SALES_ARRAY
' Plot data, type "BAR", title, col 0 for X-labels, col 1 for Y-values
DATA_PLOTTER SALES_ARRAY, "BAR", "Monthly Sales Revenue", 0, 1
SLEEP 5000 ' Pause to view

PRINT "Plotting Line Chart from stock_prices.csv..."
STOCK_ARRAY = CSVREADER("stock_prices.csv", ",", TRUE)
PRINT STOCK_ARRAY
' Plot data, type "LINE", title, col 0 for X-labels, col 1 for Y-values
DATA_PLOTTER STOCK_ARRAY, "LINE", "Stock Price Fluctuation", 0, 1
SLEEP 5000 ' Pause to view

' --- End of File ---

REM --- NeReLa Basic OpenAI Chat Client with JSON Parsing ---
REM This program uses the HTTP.POST$ function to send a prompt
REM to the OpenAI Chat Completions API and then parses the
REM JSON response to extract the message content.

CLS
PRINT "--- OpenAI API Chat Client (with History) for jdBasic ---"
PRINT

API_KEY$ = Getenv$("OPENAI_API_KEY")

IF LEN(API_KEY$) = 0 THEN
    PRINT "Error: OPENAI_API_KEY environment variable not set."
    GOTO ENDE
ENDIF

REM The API endpoint for chat completions
API_URL$ = "https://api.openai.com/v1/chat/completions"

REM Set the required HTTP headers for the OpenAI API
HTTP.SETHEADER "Content-Type", "application/json"
HTTP.SETHEADER "Authorization", "Bearer " + API_KEY$

PRINT
PRINT "Headers are set. You can now start chatting."
PRINT "Type 'exit' or 'quit' to end the program."
PRINT

' --- Initialize an array to hold the entire conversation history ---
conversation_history = []
DIM payload AS MAP ' This can stay outside the loop as it's fully redefined each time

DO
    PRINT
    INPUT "> "; USER_PROMPT$

    IF LCASE$(USER_PROMPT$) = "exit" OR LCASE$(USER_PROMPT$) = "quit" THEN
       GOTO ENDE
    ENDIF

    PRINT "Sending to OpenAI..."
    
    ' --- FIX: Declare message maps INSIDE the loop ---
    ' This creates a fresh map for each turn, preventing history from being overwritten.
    DIM user_message AS MAP
    DIM assistant_message AS MAP

    ' --- Add the user's new message to the history ---
    user_message{"role"} = "user"
    user_message{"content"} = USER_PROMPT$
    conversation_history = APPEND(conversation_history, user_message)

    ' --- Create the payload using the FULL conversation history ---
    payload{"model"} = "gpt-4o-mini"
    payload{"messages"} = conversation_history

    JSON_BODY$ = JSON.STRINGIFY$(payload)

    RESPONSE$ = HTTP.POST$(API_URL$, JSON_BODY$,"application/json")

    TRY
        RESPONSE_JSON = JSON.PARSE$(RESPONSE$)
    CATCH
        PRINT "Error in JSON.PARSE$(RESPONSE$)"
        PRINT "Error Code: "; ERR
        PRINT "Error Line: "; ERL
        PRINT "Error Message: "; ERRMSG$
    ENDTRY

    'print RESPONSE_JSON 
    AI_MESSAGE$ = RESPONSE_JSON{"choices"}[0]{"message"}{"content"}
    
    PRINT
    PRINT "AI: "; AI_MESSAGE$

    ' --- Add the AI's response to the history for the next turn ---
    assistant_message{"role"} = "assistant"
    assistant_message{"content"} = AI_MESSAGE$
    conversation_history = APPEND(conversation_history, assistant_message)

LOOP WHILE 1


ENDE:
Print "Bye."
' --- End of File ---

' ==========================================================
' == CNN Forward Pass Test in jdBasic
' == Goal: Use CONV2D and MAXPOOL2D for Edge Detection
' ==========================================================

' --- 1. Define the Input Image ---
' We'll create a simple 7x7 grayscale image with a "plus" sign in the middle.
' The shape must be [batch, channels, height, width], so [1, 1, 7, 7].
IMAGE_DATA = [[  [0, 0, 0, 1, 0, 0, 0],  [0, 0, 0, 1, 0, 0, 0],  [0, 0, 0, 1, 0, 0, 0],  [1, 1, 1, 1, 1, 1, 1],  [0, 0, 0, 1, 0, 0, 0],  [0, 0, 0, 1, 0, 0, 0],  [0, 0, 0, 1, 0, 0, 0]]]
' Reshape to the required 4D format [1, 1, 7, 7]
INPUT_IMAGE = RESHAPE(IMAGE_DATA, [1, 1, 7, 7])
INPUT_TENSOR = TENSOR.FROM(INPUT_IMAGE)

PRINT "--- Original Image (7x7) ---"
PRINT IMAGE_DATA
PRINT

' --- 2. Define the Kernels (Filters) ---
' We'll use two 3x3 Sobel operators to detect horizontal and vertical edges.
' Shape must be [out_channels, in_channels, height, width] -> [2, 1, 3, 3]

' Kernel to detect horizontal edges
K_HORIZONTAL = [  [-1, -2, -1],  [ 0,  0,  0],  [ 1,  2,  1]]

' Kernel to detect vertical edges
K_VERTICAL = [  [-1, 0, 1],  [-2, 0, 2],  [-1, 0, 1]]

' Combine them into a single 4D kernel array
KERNEL_DATA = [K_HORIZONTAL, K_VERTICAL]
KERNEL_TENSOR = TENSOR.FROM(RESHAPE(KERNEL_DATA, [2, 1, 3, 3]))

' Create a bias tensor (one bias per output channel, initialized to zero)
BIAS_TENSOR = TENSOR.FROM([0, 0])

' --- 3. Apply the Convolutional Layer ---
' We use a stride of 1 and no padding.
PRINT "--- Applying CONV2D Layer ---"
FEATURE_MAPS_TENSOR = TENSOR.CONV2D(INPUT_TENSOR, KERNEL_TENSOR, BIAS_TENSOR, 1, 0)
FEATURE_MAPS_ARRAY = TENSOR.TOARRAY(FEATURE_MAPS_TENSOR)
' Use SLICE to extract the feature maps correctly ---
' First, remove the batch dimension (dim 0, index 0) to get a 3D array [2, 5, 5]
ALL_MAPS = SLICE(FEATURE_MAPS_ARRAY, 0, 0)
' Then, slice out each 2D feature map
MAP1 = SLICE(ALL_MAPS, 0, 0)
MAP2 = SLICE(ALL_MAPS, 0, 1)

PRINT "Feature Map 1 (Horizontal Edges):"
PRINT FRMV$(MAP1)
PRINT
PRINT "Feature Map 2 (Vertical Edges):"
PRINT FRMV$(MAP2)
PRINT

' --- 4. Apply the Max Pooling Layer ---
PRINT "--- Applying MAXPOOL2D Layer (2x2 pool, stride 2) ---"
POOLED_TENSOR = TENSOR.MAXPOOL2D(FEATURE_MAPS_TENSOR, 2, 2)
POOLED_ARRAY = TENSOR.TOARRAY(POOLED_TENSOR)

' --- FIX: Use SLICE to extract the pooled maps ---
ALL_POOLED = SLICE(POOLED_ARRAY, 0, 0)
POOLED_MAP1 = SLICE(ALL_POOLED, 0, 0)
POOLED_MAP2 = SLICE(ALL_POOLED, 0, 1)

PRINT "Pooled Map 1:"
PRINT FRMV$(POOLED_MAP1)
PRINT
PRINT "Pooled Map 2:"
PRINT FRMV$(POOLED_MAP2)
PRINT

' --- End of File ---

' ==========================================================
' == COM Object test
' == Goal: Use CREATEOBJECT to create a com object
' ==========================================================

TRY
    ' Initialize a COM object
    objXL = CREATEOBJECT("Excel.Application")

    ' Access a property
    objXL.Visible = TRUE

    ' Call a method
    wb = objXL.Workbooks.Add()

    ' Set a cell value
    objcell = objXL.ActiveSheet.Cells(1, 1)
    objcell.Value = "Hello from jdBasic!"

    ' Quit Excel
    objXL.Quit()
CATCH
    PRINT "COM Error!"
    PRINT "Error Code: "; ERR
    PRINT "Error Line: "; ERL
    PRINT "Error Message: "; ERRMSG$
    PRINT "Stack: "; STACK$
ENDTRY

PRINT "Excel automation complete."

' --- End of File ---

' ==========================================================
' == Custom Operator Test
' == Goal: Show how a custom operator works.
' ==========================================================

'AtomiJD Divider
FUNC JD(x,y)
    IF Y = 0 THEN
        RETURN "Infinity"
    ELSE
        RETURN x/y
    ENDIF
ENDFUNC

PRINT 10 JD@ 5, 10 JD@ 0, iota(10) jd@ 2, iota(10) jd@ iota(10)*2, 2 jd@ [1,2,4]

' --- End of File ---

' --- CSV Data Analysis Program ---

PRINT "Loading temperature data from temps.csv..."
' Load the CSV file, skipping the header row.
TEMP_DATA = CSVREADER("temps.csv", ",", TRUE)
PRINT "Data loaded. Matrix is:"
PRINT TEMP_DATA
PRINT ""

' --- Isolate Data Columns using SLICE ---
' Column 0 is the day, 1 is min_temp, 2 is max_temp.

PRINT "Isolating data columns..."
MIN_TEMPS = SLICE(TEMP_DATA, 1, 1)
MAX_TEMPS = SLICE(TEMP_DATA, 1, 2)

PRINT "Min Temp Vector: "; MIN_TEMPS
PRINT "Max Temp Vector: "; MAX_TEMPS
PRINT ""

' --- Analyze Minimum Temperatures (Column 1) ---
PRINT "--- Min Temp Analysis ---"
MIN_AVG = SUM(MIN_TEMPS) / LEN(MIN_TEMPS)
MIN_MIN = MIN(MIN_TEMPS)
MIN_MAX = MAX(MIN_TEMPS)

PRINT "Average Minimum Temp: "; MIN_AVG
PRINT "Lowest Minimum Temp:  "; MIN_MIN
PRINT "Highest Minimum Temp: "; MIN_MAX
PRINT ""

' --- Analyze Maximum Temperatures (Column 2) ---
PRINT "--- Max Temp Analysis ---"
MAX_AVG = SUM(MAX_TEMPS) / LEN(MAX_TEMPS)
MAX_MIN = MIN(MAX_TEMPS)
MAX_MAX = MAX(MAX_TEMPS)

PRINT "Average Maximum Temp: "; MAX_AVG
PRINT "Lowest Maximum Temp:  "; MAX_MIN
PRINT "Highest Maximum Temp: "; MAX_MAX
' --- End of File ---

' Create an array of DateTime objects for project deadlines
deadlines = [CVDATE("2025-08-01"), CVDATE("2025-08-15"), CVDATE("2025-09-05")]

' Define the single project start date
start_date = CVDATE("2025-07-25")

' Use the vectorized DATEDIFF to calculate days remaining for each deadline
days_remaining = DATEDIFF("D", start_date, deadlines)

' Print the results
PRINT "Project Start Date: " + start_date
PRINT "Days remaining for deadlines:"
PRINT days_remaining

' Expected Output:
' Project Start Date: 2025-07-25 00:00:00
' Days remaining for deadlines:
' [7 21 42]
' --- End of File ---

print "--- do/while/loop test ---"
i=0
do while i < 5
 i=i+1
 print "Achim: "; I
loop
print

print "--- do/until/loop test ---"
i=0
do until i > 5
 i=i+1
 print "Achim: "; I
loop
print

print "--- do/loop/while test ---"
i=0
do
 i=i+1
 print "Achim: "; I
loop while i < 5
print

print "--- do/loop/until exit do test ---"
i=0
do
 i=i+1
 if i = 3 THEN
    print "Exit do at i: "; I
    exitdo
 endif
 j = 0
 do until j > 4
    j = j + 1
    if j = 2 THEN
        print "inner exit do by: "; j
        exitdo
    endif
 loop
 print "Achim: "; I
loop until i > 5

print "--- test done ---"


' --- End of File ---

FOR i = 1 TO 10
 if I = 1 then 
    PRINT "Outer 1"
 elseif I = 2 then
    PRINT "Outer Elseif 2"
 elseif I = 3 then
    PRINT "Outer Elseif 3"
 elseif I = 4 then
    PRINT "Outer Elseif 4"    
    FOR J = 1 TO 10
        IF J = 2 THEN
            PRINT "Inner J=2"
        ELSEIF J = 3 THEN
            PRINT "Inner Elseif 3"
        ELSEIF J = 4 THEN
            PRINT "Inner Elseif 4"
        ELSE
            PRINT "Inner Else "; J
        ENDIF
    NEXT J
 elseif I = 5 then
    PRINT "Outer Elseif 5"
 ELSE 
    PRINT "Outer greater then 5: "; I
 ENDIF
NEXT I

' --- End of File ---

PRINT "lall"
END

' --- End of File ---

'

DIM A[5]
TRY
    A[6] = 10 ' This will cause an "Array out of bounds" error
CATCH
    PRINT "Error occurred!"
    PRINT "Code: "; ERR
    PRINT "Line: "; ERL
    PRINT "Message: "; ERRMSG$
ENDTRY

PRINT "Program finished normally."

' --- End of File ---

' Event Handling Demo

ON "MY_CUSTOM_EVENT" CALL HandleCustomEvent
ON "KEYDOWN" CALL HandleKeys
ON "QUIT" CALL HandleQuit

SUB HandleCustomEvent(data)
  PRINT "Custom event received! Data: "; data[0]
ENDSUB

SUB HandleQuit(data)
  PRINT "Program will be terminated."
  END
ENDSUB

SUB HandleKeys(data)
  PRINT "Key down! Scancode: "; data[0]{"scancode"}
  IF data[0]{"scancode"} = 27 THEN RAISEEVENT "QUIT", 0 ' ESC key
ENDSUB

PRINT "Event system is active. Press keys or wait for events."
PRINT "Raising a custom event in 3 seconds..."

SLEEP 1000
RAISEEVENT "MY_CUSTOM_EVENT", "Hello from the main program!"

DO
  ' Main program loop
  sleep 15
LOOP

' --- End of File ---

PRINT "Factorial of 5 is: "; FAC(5)
PRINT "Factorial of 10 is: "; FAC(10)
PRINT "Factorial of 0 is: "; FAC(0)
PRINT "Factorial of 1 is: "; FAC(1)

' Test a larger value
PRINT "Factorial of 170 is: "; FAC(170)

SETLOCALE "de_DE"

' Program to calculate the odds for the German Lotto "6 aus 49"
' This uses the FAC() factorial function and the combination formula.
'
' The formula for combinations ("n choose k") is:
' C(n, k) = n! / (k! * (n-k)!)

PRINT "--- German Lotto '6 aus 49' Odds Calculator ---"
PRINT

' --- Part 1: Calculate the odds of getting 6 correct numbers ---
n = 49  ' Total numbers to choose from
k = 6   ' Numbers to choose

PRINT "Calculating the number of ways to choose"; k; "numbers from a set of"; n; "..."
PRINT "Formula: FAC(n) / (FAC(k) * FAC(n - k))"
PRINT

' Calculate n! / (k! * (n-k)!) using the FAC function
combinations = FAC(n) / (FAC(k) * FAC(n - k))

PRINT "Total possible combinations for 6 numbers: "; combinations
PRINT "The chance of matching all 6 numbers is 1 in "; combinations
PRINT "--------------------------------------------------------"

' --- Part 2: Include the "Superzahl" for the jackpot ---
' The German Lotto jackpot requires matching the 6 numbers AND an
' additional "Superzahl", which is a digit from 0 to 9 (10 possibilities).

PRINT
PRINT "Calculating jackpot odds including the Superzahl (0-9)..."
PRINT

superzahl_options = 10
jackpot_combinations = combinations * superzahl_options

PRINT "Total possible jackpot combinations (6 numbers + Superzahl):"; jackpot_combinations
PRINT "The chance of winning the jackpot is 1 in "; jackpot_combinations; "!"

' --- End of File ---

' NeReLaBasic - 1D Finite Element Method Example
' ------------------------------------------------
' This program calculates the displacement of nodes in a simple
' 1D bar system made of two elements, fixed at one end and with
' a force applied at the other.
'
' System:
'
'  Node 0 -------- Elem 0 -------- Node 1 -------- Elem 1 -------- Node 2
'  (Fixed)                                                        (Force ->)
'
'=============================================================================
' 1. SETUP AND DEFINE CONSTANTS
'=============================================================================
PRINT "--- 1. Defining Material and Geometric Properties ---"
E = 210000  ' Young's Modulus (e.g., for steel, in N/mm^2)
A = 100     ' Cross-sectional Area (in mm^2)
L = 200     ' Length of one element (in mm)

'=============================================================================
' 2. ELEMENT-LEVEL CALCULATIONS (USING NUMERICAL INTEGRATION)
'=============================================================================
PRINT "--- 2. Calculating Element Stiffness Matrix using INTEGRATE ---"

' For a 2-node 1D bar element, the strain-displacement matrix [B] is derived
' from the derivatives of the shape functions, N1 and N2.
' N1(xi) = 0.5 * (1 - xi)  =>  dN1/dx = -1/L
' N2(xi) = 0.5 * (1 + xi)  =>  dN2/dx =  1/L
' So, [B] = [ -1/L   1/L ]

' The stiffness matrix [k] is the integral of [B]^T * E * [B] * A over the element length.
' This gives us a function to integrate. For k(1,1), the integrand is (-1/L) * E * (-1/L) * A
' which simplifies to a constant: E*A/L^2

FUNC INTEGRAND(X)
    ' x is the coordinate along the element, but our integrand is constant.
    RETURN (E * A) / (L * L)
ENDFUNC

' The domain for integration is the length of the element [0, L]
DIM domain[2]
domain[0] = 0
domain[1] = L

' Integrate the constant function over the domain.
' The result will be (E*A/L^2) * L = E*A/L
k11 = INTEGRATE(INTEGRAND@, domain, 1)

' The element stiffness matrix for a 1D bar is:
' k = (E*A/L) * [[ 1, -1],
'                [-1,  1]]
' We calculated the k11 term, the others follow from it.
DIM k_elem[2, 2]
k_elem[0,0] = k11
k_elem[0,1] = -k11
k_elem[1,0] = -k11
k_elem[1,1] = k11

PRINT "Element Stiffness Matrix [k]:"
PRINT k_elem
PRINT ""

'=============================================================================
' 3. ASSEMBLY OF GLOBAL STIFFNESS MATRIX
'=============================================================================
PRINT "--- 3. Assembling Global Stiffness Matrix [K] ---"

' Define the number of nodes and elements in the system
num_nodes = 3
num_elements = 2

' Define the element connectivity table. Each row represents an element,
' and the columns contain the global node indices it connects.
DIM connect[2, 2]
connect[0, 0] = 0 : connect[0, 1] = 1 ' Element 0 connects nodes 0 and 1
connect[1, 0] = 1 : connect[1, 1] = 2 ' Element 1 connects nodes 1 and 2

' Our system has 3 nodes, so the global matrix is 3x3.
DIM K[3, 3] ' Initializes to all zeros

' --- Loop-based Assembly Procedure ---
' This is a more general approach that can scale to any number of elements.
FOR e = 0 TO num_elements - 1
    FOR i = 0 TO 1 ' Local node i
        FOR j = 0 TO 1 ' Local node j
            ' Get the global degrees of freedom (DOF) indices
            global_row = connect[e, i]
            global_col = connect[e, j]
            
            ' Add the contribution from the local element matrix to the global matrix
            K[global_row, global_col] = K[global_row, global_col] + k_elem[i, j]
        NEXT j
    NEXT i
NEXT e

PRINT "Global Stiffness Matrix [K] before BC:"
PRINT K
PRINT ""

'=============================================================================
' 4. APPLYING BOUNDARY CONDITIONS AND LOADS
'=============================================================================
PRINT "--- 4. Applying Boundary Conditions and Loads ---"

' Define the global force vector {F}
DIM F[3]
F[0] = 0 ' Reaction force at fixed support (unknown for now)
F[1] = 0 ' No force at node 1
F[2] = 5000 ' Applied force of 5000 N at node 2

' Apply Boundary Conditions (BC): Node 0 is fixed (displacement u0 = 0)
' This is done by modifying the [K] matrix and {F} vector.
' We zero out the row and column for the fixed DOF and put a 1 on the diagonal.
K[0,0] = 1
K[0,1] = 0
K[0,2] = 0
K[1,0] = 0
K[2,0] = 0

' And set the corresponding entry in the force vector to the known displacement.
F[0] = 0 ' Displacement at node 0 is 0.

PRINT "Global Stiffness Matrix [K] after BC:"
PRINT K
PRINT "Force Vector {F} after BC:"
PRINT F
PRINT ""

'=============================================================================
' 5. SOLVING THE SYSTEM
'=============================================================================
PRINT "--- 5. Solving the System [K]{u} = {F} ---"

' Use our new SOLVE function to find the displacement vector {u}
DIM u[3]
u = SOLVE(K, F)

PRINT "Solution (Displacement Vector) {u}:"
PRINT u
PRINT ""
PRINT "Displacement at Node 1 (u1):", u[1]; " mm"
PRINT "Displacement at Node 2 (u2):", u[2]; " mm"

' --- End of File ---

' This function defines the core logic for one step of the Fibonacci sequence.
' It takes the sequence so far (the accumulator) and appends the next number.
' The second argument, 'i', comes from the IOTA array and is ignored;
' it's only there to satisfy the REDUCE function's signature.
FUNC NextFib(acc_array, i)
    ' Calculate the next number by summing the last two elements of the array.
    next_val = acc_array[LEN(acc_array)-1] + acc_array[LEN(acc_array)-2]
    
    ' Return a new array with the next number appended.
    RETURN APPEND(acc_array, next_val)
ENDFUNC

' --- Fibonacci Sequence Program ---
PRINT
PRINT "Fibonacci Sequence Program"
PRINT

' 1. Define the initial state for the reduction. This is the seed of our sequence.
initial_sequence = [0, 1]

' 2. Define how many MORE numbers we want to generate.
'    We already have 2.
iterations = IOTA(20)

' 3. Use REDUCE to generate the full sequence.
'    - It starts with 'initial_sequence'.
'    - For each number in 'iterations', it calls NextFib.
'    - The result of NextFib becomes the new accumulator for the next step.
fib_sequence = REDUCE(NextFib@, iterations, initial_sequence)

' 4. Print the final result.
PRINT "Fibonacci sequence generated with REDUCE:"
PRINT fib_sequence

PRINT "Test done."
' --- End of File ---

export MODULE FSO

fs = 0

export sub init()
    fs = CreateObject("Scripting.FileSystemObject")
endsub

export func FileExists(name)
    if fs = 0 then
        init
    endif
    return fs.FileExists(name)
endfunc

export sub deinit()
    fs = ""
endsub


' --- End of File ---

' --- Example for MAP and FILTER ---

FUNC SQUARE(x)
  RETURN x * x
ENDFUNC

FUNC IS_EVEN(n)
  RETURN (n MOD 2) = 0
ENDFUNC

' Create an initial array of numbers
MyNumbers = IOTA(10)
PRINT "Original Array: "; FRMV$(MyNumbers)
PRINT

' Use MAP to transform every element
SquaredNumbers = SELECT(SQUARE@, MyNumbers)
PRINT "After MAP(SQUARE@, ...): "; FRMV$(SquaredNumbers)
PRINT

' Use FILTER to keep only the even numbers
EvenNumbers = FILTER(IS_EVEN@, MyNumbers)
PRINT "After FILTER(IS_EVEN@, ...): "; FRMV$(EvenNumbers)
PRINT

' You can chain these operations together!
' Let's get the squares of only the even numbers.
result = SELECT(SQUARE@,FILTER(IS_EVEN@, MyNumbers))
PRINT "Squares of even numbers: "; FRMV$(result)

' Expected Output:
' Original Array:           1 2 3 4 5 6 7 8 9 10
'
' After MAP(SQUARE@, ...):  1 4 9 16 25 36 49 64 81 100
'
' After FILTER(IS_EVEN@, ...): 2 4 6 8 10
'
' Squares of even numbers:  4 16 36 64 100

' --- End of File ---

' Example 1: Basic replacement
PRINT FORMAT$("Hello, {}. Welcome to {}!", "World", "jdBasic")
' Output: Hello, World. Welcome to jdBasic!

' Example 2: Positional arguments
PRINT FORMAT$("Second arg: {1}, First arg: {0}", "First", "Second")
' Output: Second arg: Second, First arg: First

' Example 3: Number formatting (padding, precision, hex)
val = 42

PRINT FORMAT$("Pi is approx. {:0.4f}", pi)
PRINT FORMAT$("The value is [{:5d}]", val)
PRINT FORMAT$("The value in hex is {:#x}", val)


' Example 4: Formatting a complex type (like an array)
a = RESHAPE(IOTA(4), [2,2])
PRINT FORMAT$("My matrix is: {}", a)


' --- ALIGNMENT EXAMPLES (Corrected) ---
s$ = "jdBasic"
width = 20

PRINT "1: Left, 2: Right, 3: Centered"
PRINT FORMAT$("|{:<" + STR$(width) + "}|", s$) ' Left aligned
PRINT FORMAT$("|{:>" + STR$(width) + "}|", s$) ' Right aligned
PRINT FORMAT$("|{:^" + STR$(width) + "}|", s$) ' Center aligned


' --- FILLING EXAMPLES ---
word$ = "Hello"

PRINT FORMAT$("Fill with '*': {:*<15}", word$)
PRINT FORMAT$("Fill with '-': {:->15}", word$)
PRINT FORMAT$("Fill with '.': {:.^15}", word$)


' --- NUMBER ALIGNMENT ---
n1 = 123
n2 = 45.678

' Right-align in a field of 10, filling with spaces
PRINT FORMAT$("Value: [{:>10}]", n1)

' Right-align and pad with zeros to a width of 10
PRINT FORMAT$("Value: [{:0>10}]", n1)

' Align and format a floating point number at the same time
PRINT FORMAT$("Price: [{:>12.2f}]", n2)
PRINT FORMAT$("Price: [{:0>12.2f}]", n2)

' --- End of File ---

PRINT "Nested Foor Test"

FUNC LALL(A)
    PRINT "A: "; A
    FOR I = 1 TO 3
        PRINT "Inner I: ";I
    NEXT I
    RETURN  A*I
ENDFUNC

FOR I = 1 TO 10
    PRINT "Outer I: "; I
    PRINT "LALL: "; LALL(I)
NEXT i

' --- End of File ---

Print "FRMV$ Test"

A = IOTA(12)
A = RESHAPE(A, [3,4])

Print FRMV$(A)


' --- End of File ---

REM --- String and Math Function Test ---

GREETING$ = "   Hello, World!   "
PRINT "Original: '"; GREETING$; "'"
PRINT "Trimmed: '"; TRIM$(GREETING$); "'"
PRINT "Length of trimmed: "; LEN(TRIM$(GREETING$))
PRINT

PRINT "LEFT 5: "; LEFT$(TRIM$(GREETING$), 5)
PRINT "RIGHT 6: "; RIGHT$(TRIM$(GREETING$), 6)
PRINT "MID from 8 for 5: "; MID$(TRIM$(GREETING$), 8, 5)

PRINT "LOWER: "; LCASE$("THIS IS A TEST")
PRINT "UPPER: "; UCASE$("this is a test")
PRINT

PRINT "ASCII for 'A' is "; ASC("A")
PRINT "Character for 66 is "; CHR$(66)
PRINT

HAYSTACK$ = "the quick brown fox jumps over the lazy dog"
PRINT "Position of 'fox' is "; INSTR(HAYSTACK$, "fox")
PRINT "Position of 'the' after pos 5 is "; INSTR(5, HAYSTACK$, "the")
PRINT

PRINT "--- Math Test ---"
X = 90
PRINT "The square root of ";X;" is "; SQR(X)

' Note: SIN/COS/TAN work in radians, not degrees
PI = 3.14159
PRINT "The sine of PI/2 is roughly "; SIN(PI / 2)

PRINT "--- TEST COMPLETE ---"

' --- End of File ---

' jdBasic Game of Life - Optimized with CONVOLVE
' Initial State: A "Glider"
board = PLACE(RESHAPE([0], [10, 10]), [[0, 1, 0], [0, 0, 1], [1, 1, 1]], [1, 1])
' Define the 3x3 kernel to sum up all neighbors including the cell itself.
kernel = RESHAPE([1], [3,3])
FOR I = 1 to 100
    CLS
    PRINT "jdBasic Game of Life"
    PRINT FRMV$(board) 
    board = (((board = 0) AND (CONVOLVE(board, kernel, 1) = 3)) OR ((board = 1) AND (CONVOLVE(board, kernel, 1) = 3 OR CONVOLVE(board, kernel, 1) = 4))) * 1 
    SLEEP 500
NEXT

' --- End of File ---

'jdBasic Game of Life APL like implementations

func GameOfLife(board)
    ' 1. Create all 8 neighbors by rotating the board.
    ' This is the equivalent of the APL neighbor calculation.
    N1 = ROTATE(board, [-1, -1]) ' Top-left
    N2 = ROTATE(board, [-1,  0]) ' Top-center
    N3 = ROTATE(board, [-1,  1]) ' Top-right
    N4 = ROTATE(board, [ 0, -1]) ' Mid-left
    N5 = ROTATE(board, [ 0,  1]) ' Mid-right
    N6 = ROTATE(board, [ 1, -1]) ' Bot-left
    N7 = ROTATE(board, [ 1,  0]) ' Bot-center
    N8 = ROTATE(board, [ 1,  1]) ' Bot-right
    ' 2. Sum the 8 neighbor matrices to get the neighbor count for each cell.
    neighbor_count = N1 + N2 + N3 + N4 + N5 + N6 + N7 + N8
    ' 3. Apply the Game of Life rules using element-wise logic.
    ' Rule 1: A cell is born if it's currently dead AND has exactly 3 neighbors.
    births = (board = 0) AND (neighbor_count = 3)
    ' Rule 2: A cell survives if it's currently alive AND has 2 or 3 neighbors.
    survivals = (board = 1) AND ((neighbor_count = 2) OR (neighbor_count = 3))
    ' 4. The new board is the combination of all cells that are born or survive.
    new_board = births OR survivals
    RETURN new_board
endfunc

' Initial State: A "Glider"
DIM board[10, 10]
board[1, 2] = 1
board[2, 3] = 1
board[3, 1] = 1
board[3, 2] = 1
board[3, 3] = 1

FOR I = 1 to 100
    CLS
    PRINT "Next Generation:"
    PRINT FRMV$(board)
    board = GameOfLife(board) * 1
    SLEEP 500
NEXT

' --- End of File ---

' jdBasic Game of Life - Optimized with CONVOLVE
' 1. Vars

SCREEN_W = 1000
SCREEN_H = 1000

CALC_W = 100
CALC_H = 100
DX = SCREEN_W / CALC_W
DY = SCREEN_H / CALC_H

SIZE = 100

' 2. Initialize Graphics ---
PRINT "Initializing graphics screen..."
SCREEN SCREEN_W, SCREEN_H, "Game of Life in jdBasic (Vectorized)"
CLS 0, 0, 0 ' Clear screen to black

' 3. Initial State: A "Glider"

board = PLACE(RESHAPE([0], [SIZE, SIZE]), [[0, 1, 0], [0, 0, 1], [1, 1, 1]], [1, 1])

' 4. Define the 3x3 kernel to sum up all neighbors including the cell itself.
kernel = RESHAPE([1], [3,3])
do
    board = (((board = 0) AND (CONVOLVE(board, kernel, 1) = 3)) OR ((board = 1) AND (CONVOLVE(board, kernel, 1) = 3 OR CONVOLVE(board, kernel, 1) = 4))) * 1 
    CLS
    PLOTRAW 0, 0, board * 120030, DX, DY
    SCREENFLIP
    SLEEP 100
    a$ = inkey$()
loop until a$ > ""

' --- End of File ---

' jdBasic Bouncing Rainbow Lines
' A vectorized animation demonstrating physics and color gradients.

' -------------------------------------------------
' 1. SETUP & INITIALIZATION
' -------------------------------------------------
SCREEN_W = 1920
SCREEN_H = 1080
MAX_LINES = 500
LINES_PER_FRAME = 1 ' How many new lines to add each frame

' --- Initialize Graphics ---
PRINT "Initializing graphics screen..."
SCREEN SCREEN_W, SCREEN_H, "Bouncing Rainbow Lines"
CLS 0, 0, 0 ' Clear screen to black

' --- Initialize Position & Velocity Matrices for ALL possible lines ---
PRINT "Generating initial positions and velocities..."

' Create a dummy 1D vector to define the number of random values to generate.
dummy_col = RESHAPE([0], [MAX_LINES])

' Generate the X and Y columns separately, scale them, and then stack them.
P1 = STACK(1, RND(dummy_col) * SCREEN_W, RND(dummy_col) * SCREEN_H)
P2 = STACK(1, RND(dummy_col) * SCREEN_W, RND(dummy_col) * SCREEN_H)

' V1 and V2 hold the velocities.
dummy_shape_2d = RESHAPE([0], [MAX_LINES, 2])
V1 = (RND(dummy_shape_2d) - 0.5) * 8
V2 = (RND(dummy_shape_2d) - 0.5) * 8

' --- Animation Loop Variables ---
num_lines = 1
time_step = 0

' -------------------------------------------------
' 2. MAIN ANIMATION LOOP
' -------------------------------------------------
PRINT "Starting animation loop... Press any key to exit."
DO
    ' --- Clear the screen for the new frame ---
    CLS 0, 0, 0

    ' --- Increment the number of active lines ---
    IF num_lines < MAX_LINES THEN
        num_lines = num_lines + LINES_PER_FRAME
        IF num_lines > MAX_LINES THEN num_lines = MAX_LINES
    ENDIF

    ' --- Update all positions with their velocities in one operation ---
    P1 = P1 + V1
    P2 = P2 + V2

    ' --- Vectorized Bouncing Logic ---
    p1_bounce_x = (SLICE(P1, 1, 0) < 0) OR (SLICE(P1, 1, 0) > SCREEN_W)
    p1_bounce_y = (SLICE(P1, 1, 1) < 0) OR (SLICE(P1, 1, 1) > SCREEN_H)
    p2_bounce_x = (SLICE(P2, 1, 0) < 0) OR (SLICE(P2, 1, 0) > SCREEN_W)
    p2_bounce_y = (SLICE(P2, 1, 1) < 0) OR (SLICE(P2, 1, 1) > SCREEN_H)

    v1_x_flipped = SLICE(V1, 1, 0) * (1 - 2 * p1_bounce_x)
    v1_y_flipped = SLICE(V1, 1, 1) * (1 - 2 * p1_bounce_y)
    v2_x_flipped = SLICE(V2, 1, 0) * (1 - 2 * p2_bounce_x)
    v2_y_flipped = SLICE(V2, 1, 1) * (1 - 2 * p2_bounce_y)

    V1 = STACK(1, v1_x_flipped, v1_y_flipped)
    V2 = STACK(1, v2_x_flipped, v2_y_flipped)

    ' --- Vectorized Rainbow Color Generation ---
    hue = (IOTA(num_lines) / num_lines) * 2 * PI
    r = (SIN(hue + time_step) * 127.5) + 127.5
    g = (SIN(hue + time_step + (2 * PI / 3)) * 127.5) + 127.5
    b = (SIN(hue + time_step + (4 * PI / 3)) * 127.5) + 127.5
    colors = STACK(1, r, g, b)

    ' --- Prepare Matrices for Drawing ---
    ' Select the first 'num_lines' rows from the main position matrices.
    ' This is the correct way to get a sub-matrix.
    active_p1 = SLICE(P1, 0, 0, num_lines)
    active_p2 = SLICE(P2, 0, 0, num_lines)

    ' Extract each column of coordinate data. This now works because active_p1/p2 have the correct shape.
    x1_col = SLICE(active_p1, 1, 0)
    y1_col = SLICE(active_p1, 1, 1)
    x2_col = SLICE(active_p2, 1, 0)
    y2_col = SLICE(active_p2, 1, 1)

    ' Explicitly RESHAPE the columns into 1D vectors for STACK.
    x1_vec = RESHAPE(x1_col, [num_lines])
    y1_vec = RESHAPE(y1_col, [num_lines])
    x2_vec = RESHAPE(x2_col, [num_lines])
    y2_vec = RESHAPE(y2_col, [num_lines])

    ' Combine the 1D vectors into a single (num_lines x 4) matrix for drawing.
    lines_to_draw = STACK(1, x1_vec, y1_vec, x2_vec, y2_vec)

    ' --- Draw all active lines in one command ---
    LINE lines_to_draw, colors

    ' --- Update the screen and advance time ---
    SCREENFLIP
    time_step = time_step + 0.05
    SLEEP 16 ' Aim for ~60 FPS

    ' --- Check for user input to exit the loop ---
    a$ = INKEY$()
LOOP UNTIL a$ > ""

' --- Clean up ---
PRINT "Animation finished."

' --- End of File ---

print "--- Web Test Program ---"
print

' Test a simple GET request to an API that returns JSON

API_URL$ = "https://jsonplaceholder.typicode.com/todos/1"

TRY
    JSON_DATA$ = HTTP.GET$(API_URL$)
CATCH
    PRINT "Error fetching URL: "; API_URL$; " (Error: "; ERR; ")"
FINALLY
    PRINT "HTTP Status Code: "; HTTP.STATUSCODE()
    PRINT "Received JSON:"; JSON_DATA$
ENDTRY

' Test setting headers (e.g., for a simple authentication)
PRINT "Testing HTTP.CLEARHEADERS..."

HTTP.CLEARHEADERS
PRINT "Testing HTTP.SETHEADER..."

HTTP.SETHEADER "X-Custom-Header", "MyCustomValue" 
HTTP.SETHEADER "Accept", "application/json" 

' Try another GET request with headers
API_URL2$ = "https://httpbin.org/headers" ' This API echoes back headers
PRINT "Fetching headers from httpbin.org/headers..."

TRY
    HEADER_RESPONSE$ = HTTP.GET$(API_URL2$)
CATCH
    PRINT "Error fetching URL: "; API_URL2$; " (Error: "; ERR; ")"
FINALLY
    PRINT "HTTP Status Code: "; HTTP.STATUSCODE()
    PRINT "Headers Received:"; HEADER_RESPONSE$
ENDTRY

PRINT "--- Web Test Complete ---"

' --- End of File ---

' ===================================================================
' == jdBasic Masked Input Field Library (Event-Driven & Native Cursor)
' ==
' == This version uses the console's native cursor for a more
' == professional look and feel, removing the manual "_" cursor.
' ===================================================================

' --- Global variables used by the event handler to manage state ---
DIM G_BUFFER$ AS STRING
DIM G_CURSOR_POS AS INTEGER
DIM G_MAX_LENGTH AS INTEGER
DIM G_MASK_CHARS$ AS STRING
DIM G_POS_X AS INTEGER
DIM G_POS_Y AS INTEGER
DIM G_CAPTION$ AS STRING
DIM G_INPUT_COMPLETE AS BOOLEAN

' ===================================================================
' == The Main Input Function (Setup and Wait)
' ===================================================================

FUNC JDINPUT$(X, Y, Mask$, Caption$)
    ' --- 1. Turn on the system cursor for the input operation ---
    CURSOR 1

    ' --- 2. Parse the Mask and Initialize Global State ---
    MaskInfo = ParseMask(Mask$)
    G_MAX_LENGTH = MaskInfo{"length"}
    G_MASK_CHARS$ = MaskInfo{"chars"}
    G_BUFFER$ = ""
    G_CURSOR_POS = 0
    G_POS_X = X
    G_POS_Y = Y
    G_CAPTION$ = Caption$
    G_INPUT_COMPLETE = FALSE

    ' --- 3. Perform the initial draw ---
    DrawInputField

    ' --- 4. Register the Event Handler ---
    ON "KEYDOWN" CALL HandleKey

    ' --- 5. Wait for Completion ---
    DO
        SLEEP 50 ' Yield CPU time
    LOOP UNTIL G_INPUT_COMPLETE

    ' --- 6. Cleanup and Return ---
    CURSOR 0           ' Hide the cursor again
    
    ' Erase the input field line from the screen
    LOCATE G_POS_Y, G_POS_X
    PRINT "                                                                                "

    RETURN G_BUFFER$
ENDFUNC

' ===================================================================
' == Event Handler and Helper Subroutines
' ===================================================================

SUB HandleKey(KeyData)
    ' This subroutine is the core of the logic, called only on key press.
    
    ' --- CORRECTED: Access the Map at index 0 of the KeyData array ---
    KeyAsc = KeyData[0]{"scancode"}
    KeyChar$ = KeyData[0]{"key"}

    ' --- Key Handling Logic ---
    IF KeyAsc = 13 THEN ' Enter key
        G_INPUT_COMPLETE = TRUE
        RETURN
    
    ELSEIF KeyAsc = 8 THEN ' Backspace
        IF G_CURSOR_POS > 0 THEN
            G_BUFFER$ = LEFT$(G_BUFFER$, G_CURSOR_POS - 1) + RIGHT$(G_BUFFER$, LEN(G_BUFFER$) - G_CURSOR_POS)
            G_CURSOR_POS = G_CURSOR_POS - 1
        ENDIF
    ELSEIF KeyAsc = 275 THEN ' Right Arrow
        IF G_CURSOR_POS < LEN(G_BUFFER$) THEN G_CURSOR_POS = G_CURSOR_POS + 1
    ELSEIF KeyAsc = 276 THEN ' Left Arrow
        IF G_CURSOR_POS > 0 THEN G_CURSOR_POS = G_CURSOR_POS - 1
    ELSEIF KeyAsc = 279 THEN ' End Key
        G_CURSOR_POS = LEN(G_BUFFER$)
    ELSEIF KeyAsc = 280 THEN ' Home Key
        G_CURSOR_POS = 0
    ELSEIF KeyAsc = 281 THEN ' Delete Key
        IF G_CURSOR_POS < LEN(G_BUFFER$) THEN
            G_BUFFER$ = LEFT$(G_BUFFER$, G_CURSOR_POS) + RIGHT$(G_BUFFER$, LEN(G_BUFFER$) - G_CURSOR_POS - 1)
        ENDIF
    ELSE ' --- Handle Printable Characters ---
        IF LEN(G_BUFFER$) < G_MAX_LENGTH AND KeyAsc >= 32 AND KeyAsc <= 126 THEN
            MaskChar$ = MID$(G_MASK_CHARS$, G_CURSOR_POS + 1, 1)
            IsAllowed = FALSE
            IF MaskChar$ = "@" AND INSTR("ABCDEFGHIJKLMNOPQRSTUVWXYZÄÖÜ0123456789 ", UCASE$(KeyChar$)) > 0 THEN IsAllowed = TRUE
            IF MaskChar$ = "#" AND INSTR("0123456789", KeyChar$) > 0 THEN IsAllowed = TRUE
            IF MaskChar$ = KeyChar$ THEN IsAllowed = TRUE

            IF IsAllowed THEN
                G_BUFFER$ = LEFT$(G_BUFFER$, G_CURSOR_POS) + KeyChar$ + RIGHT$(G_BUFFER$, LEN(G_BUFFER$) - G_CURSOR_POS)
                G_CURSOR_POS = G_CURSOR_POS + 1
            ENDIF
        ENDIF
    ENDIF

    ' --- Redraw the field ONLY after a key has been processed ---
    DrawInputField
ENDSUB

SUB DrawInputField()
    ' This subroutine handles all screen drawing for the input field.
    ' It no longer draws a manual cursor.
    
    ' Go to the start of the line to redraw it
    LOCATE G_POS_Y, G_POS_X
    
    Display$ = G_CAPTION$ + "["
    FOR i = 0 TO G_MAX_LENGTH - 1
        IF i < LEN(G_BUFFER$) THEN
            Display$ = Display$ + MID$(G_BUFFER$, i + 1, 1)
        ELSE
            Display$ = Display$ + " " ' Use space for empty chars
        ENDIF
    NEXT i
    Display$ = Display$ + "]"
    
    PRINT Display$; ' Use semicolon to prevent newline
    
    ' --- NEW: Position the actual system cursor ---
    ' Calculate the target column for the cursor
    CursorCol = G_POS_X + LEN(G_CAPTION$) + 1 + G_CURSOR_POS
    LOCATE G_POS_Y, CursorCol
ENDSUB

FUNC ParseMask(Mask$)
    ' This function analyzes the mask string and returns a Map.
    Result = {}
    
    IF INSTR(Mask$, ":") > 0 THEN
        Parts = SPLIT(Mask$, ":")
        Length = VAL(Parts[1])
        CharType$ = Parts[0]
        Result{"length"} = Length
        Result{"chars"} = ""
        FOR i = 1 TO Length
            Result{"chars"} = Result{"chars"} + CharType$
        NEXT i
    ELSE
        Result{"length"} = LEN(Mask$)
        Result{"chars"} = Mask$
    ENDIF

    RETURN Result
ENDFUNC

' ===================================================================
' == Main Program - Example Usage
' ===================================================================

CLS
PRINT "--- jdBasic Masked Input Field Demo (Native Cursor) ---"
PRINT

' --- Example 1: Alphanumeric input for a name ---
PRINT "Enter your name (max 20 chars)."
Name$ = JDINPUT$(2, 2, "@:20", "Name: ")
PRINT
PRINT "Hello, "; Name$; "!"
PRINT

' --- Example 2: Numeric input for a price ---
PRINT "Enter a price (e.g., 1234.56)."
Price$ = JDINPUT$(2, 7, "####0.##", "Price: ")
PRINT
PRINT "The price you entered is: "; Price$
PRINT

PRINT "--- Demo Complete ---"

CURSOR 1

END

' --- End of File ---

' Test program for the new INTEGRATE function

' 1. Define the function we want to integrate.
'    It must take exactly one argument.
FUNC SQUARE(X)
    RETURN X * X
ENDFUNC

' 2. Set up the integration parameters
PRINT "Integrating f(x) = x^2 from 0 to 3..."
DIM limits[2]
limits[0] = 0 ' Lower bound
limits[1] = 3 ' Upper bound

' 3. Call the INTEGRATE function
'    - @SQUARE is a reference to our function
'    - limits is the array with the domain [0, 3]
'    - 3 is the order (number of Gauss points). Higher is more accurate.
result = INTEGRATE(SQUARE@, limits, 3)

PRINT "Analytical result should be 9.0"
PRINT "Numerical result:", result
PRINT ""

' --- Another example: f(x) = sin(x) from 0 to PI ---
' The analytical result is -cos(x) | 0 to PI = (-(-1)) - (-1) = 2
PRINT "Integrating f(x) = SIN(x) from 0 to PI..."
limits[0] = 0
limits[1] = 3.14159265

result = INTEGRATE(SIN@, limits, 5)

PRINT "Analytical result should be 2.0"
PRINT "Numerical result:", result
' --- End of File ---

REM =============================================================
REM JD'S INVADERS, TRANSLATED TO NERELA BASIC
REM Original Python version by 'jd'
REM Translation and adaptation by Gemini
REM Correct Gemini's hallucination and misunderstanding by jd
REM =============================================================

REM --- GAME CONFIGURATION ---
MAX_ALIENS = 40
MAX_BLOCKS = 4
ALIEN_COLS = 8
ALIEN_ROWS = 5

REM --- DATA STRUCTURES (REPLACING PYTHON CLASSES) ---

REM -- ALIEN DATA --
DIM AX[MAX_ALIENS]
DIM AY[MAX_ALIENS]
DIM AIX[MAX_ALIENS]
DIM AIY[MAX_ALIENS] ' Initial positions
DIM AP[MAX_ALIENS] ' Points
DIM AD[MAX_ALIENS] ' Direction
DIM AT[MAX_ALIENS] ' Type (0, 1, or 2)
DIM AV[MAX_ALIENS] ' Visible (1=true, 0=false)

REM -- PLAYER DATA --
DIM PX AS INTEGER
DIM PY AS INTEGER
DIM PDIR AS INTEGER
DIM PVIS AS INTEGER
DIM PRES AS INTEGER

REM -- PLAYER MISSILE DATA --
DIM PMX AS INTEGER
DIM PMY AS INTEGER
DIM PMDIR AS INTEGER
DIM PMVIS AS INTEGER
DIM PMFIRE AS INTEGER

REM -- ALIEN MISSILE DATA --
DIM AMX AS INTEGER
DIM AMY AS INTEGER
DIM AMDIR AS INTEGER
DIM AMVIS AS INTEGER
DIM AMFIRE AS INTEGER
CANDIDATE = -1

REM -- BLOCK DATA --
DIM BX[MAX_BLOCKS]
DIM BY[MAX_BLOCKS]
DIM BH[MAX_BLOCKS] ' Hits / Frame
DIM BV[MAX_BLOCKS] ' Visible

REM -- GLOBAL GAME STATE --
DIM SCORE AS INTEGER
DIM LIVES AS INTEGER
DIM SPEED AS INTEGER
DIM GAMEOVER AS INTEGER
DIM DIFFICULTY AS INTEGER
DIM FRAME AS INTEGER
DIM SFRAME AS INTEGER

REM --- SPRITE GRAPHICS ---
DIM PLAYER_T[2]
PLAYER_T[0] = " ▞▚ " ' Player, Line 0
PLAYER_T[1] = "▛▀▀▜" ' Player, Line 1

' Define Block Sprites as 2-line arrays
DIM BLOCK_A_T[2]
BLOCK_A_T[0] = "▗▇▇▖" ' Block A (Full), Line 0
BLOCK_A_T[1] = "████" ' Block A (Full), Line 1

DIM BLOCK_B_T[2]
BLOCK_B_T[0] = "    " ' Block B (Half), Line 0 (top damaged)
BLOCK_B_T[1] = "████" ' Block B (Half), Line 1 (bottom remains)

DIM BLOCK_C_T[2]
BLOCK_C_T[0] = "    " ' Block C (More Damaged), Line 0
BLOCK_C_T[1] = "▚▞▚▞" ' Block C (More Damaged), Line 1

DIM ALIEN_T[12]

ALIEN_T[0] = "▗▇▇▖"
ALIEN_T[1] = "▞  ▚"
ALIEN_T[2] = "▗▇▇▖"
ALIEN_T[3] = "▚  ▞"
ALIEN_T[4] = "▗▇▇▖"
ALIEN_T[5] = " ▚▞ "
ALIEN_T[6] = "▗▇▇▖"
ALIEN_T[7] = " ▞▚"
ALIEN_T[8] = "▛▀▀▜"
ALIEN_T[9] = "▚▅▅▞"
ALIEN_T[10] = "▛▀▀▜"
ALIEN_T[11] = "▚  ▞"

ALIEN_A1$ = "▗▇▇▖▞  ▚"
ALIEN_A2$ = "▗▇▇▖▚  ▞"
ALIEN_B1$ = "▗▇▇▖ ▚▞ "
ALIEN_B2$ = "▗▇▇▖ ▞▚"
ALIEN_C1$ = "▛▀▀▜▚▅▅▞"
ALIEN_C2$ = "▛▀▀▜▚  ▞"
PLAYER$ = " ▞▚ ▛▀▀▜"
P_MISSILE$ = "|"
A_MISSILE$ = "┇"
BLOCK_A$ = "▗▇▇▖████"
BLOCK_B$ = "    ████"
BLOCK_C$ = "    ▚▞▚▞"

REM ======================================================================
REM INITIALIZATION
REM ======================================================================


SUB INIT_LEVEL()
    GAMEOVER = 0
    SPEED = 6
    FRAME = 0
    SFRAME = 0
    
    REM --- CREATE ALIENS ---
    I = 0
    FOR R = 0 TO ALIEN_ROWS - 1
        FOR C = 0 TO ALIEN_COLS - 1
            AIX[I] = 8 + (C * 8)
            AIY[I] = 4 + (R * 3)
            AX[I] = AIX[I]
            AY[I] = AIY[I]
            AD[I] = 1
            AV[I] = 1
            IF R = 0 THEN
                AT[I] = 0
                AP[I] = 500
            ENDIF
            IF R = 1 OR R = 2 THEN
                AT[I] = 1
                AP[I] = 300
            ENDIF
            IF R > 2 THEN
                AT[I] = 2
                AP[I] = 100
            ENDIF
            I = I + 1
        NEXT C
    NEXT R
    
    REM --- CREATE BLOCKS ---
    FOR J = 0 TO 3
        BX[J] = 12 + (J * 17)
        BY[J] = 30
        BH[J] = 0
        BV[J] = 1
    NEXT J

    REM --- INIT PLAYER ---
    PX = 40
    PY = 35
    PDIR = 0
    PVIS = 1
    PRES = 0
    
    REM --- INIT MISSILES ---
    PMVIS = 0
    PMFIRE = 0
    AMVIS = 0
    AMFIRE = 0
ENDSUB

SUB INIT_GAME()
    OPTION "NOPAUSE"
    LIVES = 3
    SCORE = 0
    DIFFICULTY = 10
    INIT_LEVEL
ENDSUB

SUB FIRE_PLAYER_MISSILE()
    PMX = PX + 2
    PMY = PY - 1
    PMVIS = 1
    PMFIRE = 1
ENDSUB

SUB FIRE_ALIEN_MISSILE(I)
    AMX = AX[I] + 2
    AMY = AY[I] + 2
    AMVIS = 1
    AMFIRE = 1
ENDSUB

SUB PLAYER_DIE()
    PVIS = 0
    PRES = 5 ' Respawn timer
    LIVES = LIVES - 1
    IF LIVES < 0 THEN 
       GAMEOVER = 2
    ENDIF
ENDSUB

REM ======================================================================
REM GAME LOGIC AND UPDATES
REM ======================================================================

SUB UPDATE_GAME()

    REM --- MOVE PLAYER ---
    IF PVIS = 1 THEN
        PX = PX + PDIR
        IF PX < 2 THEN 
           PX = 2
        ENDIF
        IF PX > 75 THEN 
           PX = 75
        ENDIF
        PDIR = 0
    ELSE
        PRES = PRES - 1
        IF PRES = 0 THEN 
           PVIS = 1
        ENDIF
    ENDIF

    REM --- MOVE PLAYER MISSILE ---
    IF PMVIS = 1 THEN
        PMY = PMY - 1
        IF PMY < 3 THEN 
	   PMVIS = 0 
           PMFIRE = 0
        ENDIF
        ' Check for hit
        FOR I = 0 TO MAX_ALIENS - 1
            IF AV[I] = 1 THEN
                IS_HIT = HIT(PMX, PMY, AX[I], AY[I])
                IF IS_HIT = 1 THEN
                    AV[I] = 0
                    PMVIS = 0
                    PMFIRE = 0
                    SCORE = SCORE + AP[I]
                ENDIF
            ENDIF
        NEXT I
    ENDIF

    REM --- MOVE ALIENS ---
    MOVE_DOWN = 0
    FOR I = 0 TO MAX_ALIENS - 1
        IF AV[I] = 1 THEN
            IF AX[I] + AD[I] < 2 OR AX[I] + AD[I] > 75 THEN MOVE_DOWN = 1
        ENDIF
    NEXT I

    IF MOVE_DOWN = 1 THEN
        FOR I = 0 TO MAX_ALIENS - 1
            AY[I] = AY[I] + 1
            AD[I] = AD[I] * -1
        NEXT I
        IF SPEED > DIFFICULTY THEN 
           SPEED = SPEED - 1
        ENDIF
    ELSE
        FOR I = 0 TO MAX_ALIENS - 1
            IF AV[I] = 1 THEN 
		AX[I] = AX[I] + AD[I]
	    ENDIF
        NEXT I
    ENDIF

    

    REM --- ALIEN LOGIC (FIRE, GAME OVER CHECK) ---
    ALIVE_COUNT = 0
    FOR I = 0 TO MAX_ALIENS - 1
        IF AV[I] = 1 THEN
            ALIVE_COUNT = ALIVE_COUNT + 1
            IF AY[I] > 32 THEN 
               GAMEOVER = 2 ' Aliens reached bottom
            ENDIF
            ' Randomly decide to fire
            IF AMFIRE = 0 AND RND(1) * 100 < 5 THEN
                CANDIDATE = I
            ENDIF
        ENDIF
    NEXT I

    IF AMFIRE = 0 AND CANDIDATE > -1 THEN 
       FIRE_ALIEN_MISSILE CANDIDATE
    ENDIF
    IF ALIVE_COUNT = 0 AND GAMEOVER = 0 THEN 
       GAMEOVER = 1 ' Level complete
    ENDIF
    REM --- MOVE ALIEN MISSILE ---
    IF AMVIS = 1 THEN
        AMY = AMY + 1
        IF AMY > 36 THEN 
           AMVIS = 0
           AMFIRE = 0
        ENDIF
        ' Check player hit
        IF PVIS = 1 AND HIT(AMX, AMY, PX, PY) = 1 THEN
            PLAYER_DIE
            AMVIS = 0
            AMFIRE = 0
        ENDIF
        ' Check block hit
        FOR I = 0 TO MAX_BLOCKS - 1
            IF BV[I] = 1 AND HIT(AMX, AMY, BX[I], BY[I]) = 1 THEN
                BH[I] = BH[I] + 1
                IF BH[I] > 2 THEN 
		   BV[I] = 0
                ENDIF
                AMVIS = 0
                AMFIRE = 0
            ENDIF
        NEXT I
    ENDIF
ENDSUB

FUNC HIT(X1, Y1, X2, Y2)
    REM Simple box collision. Returns 1 if hit, 0 otherwise.
    IF Y1 >= Y2 AND Y1 < Y2 + 2 THEN
        IF X1 >= X2 AND X1 < X2 + 4 THEN
            RETURN 1
        ENDIF
    ENDIF
    RETURN 0
ENDFUNC



REM ======================================================================
REM RENDERING
REM ======================================================================

sub print_alien(i, f, t)
    LOCATE AY[I], AX[I]
    print ALIEN_T[t*4+f*2]
    LOCATE AY[I]+1, AX[I]
    print ALIEN_T[t*4+1+f*2]
endsub

SUB PRINT_PLAYER()
    LOCATE PY, PX
    PRINT PLAYER_T[0]
    LOCATE PY+1, PX
    PRINT PLAYER_T[1]
ENDSUB

SUB PRINT_BLOCK(I, HITS)
    LOCATE BY[I], BX[I]
    IF HITS = 0 THEN
        PRINT BLOCK_A_T[0]
        LOCATE BY[I]+1, BX[I]
        PRINT BLOCK_A_T[1]
    ENDIF
    IF HITS = 1 THEN
        PRINT BLOCK_B_T[0]
        LOCATE BY[I]+1, BX[I]
        PRINT BLOCK_B_T[1]
    ENDIF
    IF HITS = 2 THEN
        PRINT BLOCK_C_T[0]
        LOCATE BY[I]+1, BX[I]
        PRINT BLOCK_C_T[1]
    ENDIF
ENDSUB


SUB RENDER_SCREEN()
    CLS
    COLOR 7, 0
    LOCATE 1, 1
    PRINT "LIVES: " + STR$(LIVES);
    LOCATE 1, 35
    PRINT "JD INVADERS";
    LOCATE 1, 68
    PRINT "SCORE: " + STR$(SCORE);
    LOCATE 2, 1
    PRINT "--------------------------------------------------------------------------------";

    REM -- DRAW ALIENS --
    FOR I = 0 TO MAX_ALIENS - 1
        IF AV[I] = 1 THEN
            TYPE = AT[I]
            IF TYPE = 0 THEN 
               COLOR 1, 0 ' Red
	    ENDIF
            IF TYPE = 1 THEN 
               COLOR 2, 0 ' Green
	    ENDIF
            IF TYPE = 2 THEN 
               COLOR 6, 0 ' Cyan
            ENDIF
	    PRINT_ALIEN I, FRAME, TYPE
        ENDIF
    NEXT I
    
    REM -- DRAW BLOCKS --
    COLOR 1, 0 ' Gray
    FOR I = 0 TO MAX_BLOCKS - 1 
        IF BV[I] = 1 THEN 
            HITS = BH[I] 
            PRINT_BLOCK I, HITS 
        ENDIF
    NEXT I 

    REM -- DRAW PLAYER --
    IF PVIS = 1 THEN
        COLOR 4, 0 ' Blue
	PRINT_PLAYER 
    ENDIF
    
    REM -- DRAW MISSILES --
    IF PMVIS = 1 THEN
        COLOR 7, 0 ' White
        LOCATE PMY, PMX
	PRINT P_MISSILE$;
    ENDIF
    IF AMVIS = 1 THEN
        COLOR 1, 0 ' Red
        LOCATE AMY, AMX
	PRINT A_MISSILE$;
    ENDIF

    REM -- DRAW GAME OVER MESSAGES --
    IF GAMEOVER > 0 THEN
        COLOR 7, 0
        LOCATE 20, 35
	PRINT "GAME OVER"
        IF GAMEOVER = 1 THEN
            LOCATE 22, 28
	    PRINT "PRESS 'N' FOR NEXT LEVEL"
        ELSE
            LOCATE 22, 36
	    PRINT "YOU LOST"
            LOCATE 23, 29
	    PRINT "PRESS 'N' TO RESTART"
        ENDIF
    ENDIF
ENDSUB


REM ======================================================================
REM MAIN GAME LOOP
REM ======================================================================
SUB GAME_LOOP()
MAIN_LOOP:
    
    K$ = INKEY$()
    IF K$ = "z" or asc(k$) = 27 THEN 
	GOTO END_GAME
    ENDIF
    IF GAMEOVER > 0 THEN
        IF K$ = "n" THEN
            IF GAMEOVER = 1 THEN
                LIVES = LIVES + 1
                INIT_LEVEL
            ELSE
                INIT_GAME
            ENDIF
        ENDIF
    ENDIF

    IF PVIS = 1 THEN
        IF K$ = "a" THEN 
	   PDIR = -1
	ENDIF
        IF K$ = "d" THEN 
	   PDIR = 1
	ENDIF
        IF K$ = " " AND PMFIRE = 0 THEN 
	   FIRE_PLAYER_MISSILE
	ENDIF
    ENDIF
    
    IF GAMEOVER = 0 THEN
        SFRAME = SFRAME + 1
        IF SFRAME > SPEED THEN
            UPDATE_GAME
	    RENDER_SCREEN
            SFRAME = 0
	    FRAME = FRAME + 1
	    IF FRAME > 1 then
	       FRAME = 0
	    ENDIF
        ENDIF
    ENDIF

    
    
    SLEEP 20
    GOTO MAIN_LOOP

END_GAME:
    CURSOR 1
    CLS
ENDSUB



CLS
CURSOR 0
INIT_GAME
GAME_LOOP

' --- End of File ---

  REM =================================================================
REM JD'S INVADERS - MODERNIZED & VECTORIZED (ADVANCED)
REM Refactored to use a Structure-of-Arrays (SoA) design with
REM advanced array-oriented functions for collision detection.
REM =================================================================

REM --- GAME CONFIGURATION ---
MAX_ALIENS = 40
MAX_BLOCKS = 4
ALIEN_COLS = 8
ALIEN_ROWS = 5

REM =================================================================
REM DATA STRUCTURES (SoA - Structure of Arrays)
REM =================================================================

TYPE T_Alien
  X             ' Array of X positions
  Y             ' Array of Y positions
  InitialX      ' Array of initial X
  InitialY      ' Array of initial Y
  Points        ' Array of point values
  Direction     ' Array of directions
  Species       ' Array of types
  Visible       ' Boolean array of visibility
ENDTYPE

TYPE T_Player
  X AS DOUBLE
  Y AS DOUBLE
  Direction AS DOUBLE
  Visible AS BOOLEAN
  RespawnTimer AS DOUBLE
ENDTYPE

TYPE T_Missile
  X AS DOUBLE
  Y AS DOUBLE
  Visible AS BOOLEAN
  IsFiring AS BOOLEAN
ENDTYPE

TYPE T_Block
  X           ' Array of X positions
  Y           ' Array of Y positions
  Hits        ' Array of hit counts
  Visible     ' Boolean array of visibility
ENDTYPE

REM --- DECLARE DATA VARIABLES ---
DIM Aliens AS T_Alien
DIM Blocks AS T_Block
DIM Player AS T_Player
DIM PlayerMissile AS T_Missile
DIM AlienMissile AS T_Missile

REM -- GLOBAL GAME STATE --
DIM SCORE AS INTEGER
DIM LIVES AS INTEGER
DIM SPEED AS INTEGER
DIM GAMEOVER AS INTEGER
DIM DIFFICULTY AS INTEGER
DIM FRAME AS INTEGER
DIM SFRAME AS INTEGER

REM --- SPRITE GRAPHICS ---
DIM PLAYER_T[2]
PLAYER_T[0] = " ▞▚ "
PLAYER_T[1] = "▛▀▀▜"

DIM BLOCK_A_T[2] : BLOCK_A_T[0] = "▗▇▇▖" : BLOCK_A_T[1] = "████"
DIM BLOCK_B_T[2] : BLOCK_B_T[0] = "    " : BLOCK_B_T[1] = "████"
DIM BLOCK_C_T[2] : BLOCK_C_T[0] = "    " : BLOCK_C_T[1] = "▚▞▚▞"

DIM ALIEN_T[12]
ALIEN_T[0] = "▗▇▇▖" : ALIEN_T[1] = "▞  ▚" : ALIEN_T[2] = "▗▇▇▖"
ALIEN_T[3] = "▚  ▞" : ALIEN_T[4] = "▗▇▇▖" : ALIEN_T[5] = " ▚▞ "
ALIEN_T[6] = "▗▇▇▖" : ALIEN_T[7] = " ▞▚"  : ALIEN_T[8] = "▛▀▀▜"
ALIEN_T[9] = "▚▅▅▞" : ALIEN_T[10] = "▛▀▀▜": ALIEN_T[11] = "▚  ▞"

P_MISSILE$ = "|"
A_MISSILE$ = "┇"

REM ======================================================================
REM INITIALIZATION
REM ======================================================================

SUB INIT_LEVEL()
    GAMEOVER = 0
    SPEED = 6
    FRAME = 0
    SFRAME = 0
    
    REM --- CREATE ALIENS (VECTORIZED) ---
    ColsX = (IOTA(ALIEN_COLS) - 1) * 8 + 8
    RowsY = (IOTA(ALIEN_ROWS) - 1) * 3 + 4
    TypeVec = [0, 1, 1, 2, 2]
    PointsVec = [500, 300, 300, 100, 100]

    AlienXMatrix = OUTER(IOTA(ALIEN_ROWS) * 0, ColsX, "+")
    AlienYMatrix = OUTER(RowsY, IOTA(ALIEN_COLS) * 0, "+")
    AlienTypeMatrix = OUTER(TypeVec, IOTA(ALIEN_COLS) * 0, "+")
    AlienPointsMatrix = OUTER(PointsVec, IOTA(ALIEN_COLS) * 0, "+")

    Aliens.X = RESHAPE(AlienXMatrix, [MAX_ALIENS])
    Aliens.Y = RESHAPE(AlienYMatrix, [MAX_ALIENS])
    Aliens.InitialX = Aliens.X
    Aliens.InitialY = Aliens.Y
    Aliens.Species = RESHAPE(AlienTypeMatrix, [MAX_ALIENS])
    Aliens.Points = RESHAPE(AlienPointsMatrix, [MAX_ALIENS])
    Aliens.Direction = RESHAPE([1], [MAX_ALIENS])
    Aliens.Visible = RESHAPE([TRUE], [MAX_ALIENS])
    
    REM --- CREATE BLOCKS (VECTORIZED) ---
    Blocks.X = IOTA(MAX_BLOCKS) * 17 - 5
    Blocks.Y = RESHAPE([30], [MAX_BLOCKS])
    Blocks.Hits = RESHAPE([0], [MAX_BLOCKS])
    Blocks.Visible = RESHAPE([TRUE], [MAX_BLOCKS])

    REM --- INIT PLAYER AND MISSILES ---
    Player.X = 40 
    Player.Y = 35 
    Player.Direction = 0
    Player.Visible = TRUE 
    Player.RespawnTimer = 0
    PlayerMissile.Visible = FALSE 
    PlayerMissile.IsFiring = FALSE
    AlienMissile.Visible = FALSE 
    AlienMissile.IsFiring = FALSE
ENDSUB

SUB INIT_GAME()
    OPTION "NOPAUSE"
    CLS
    CURSOR 0
    LIVES = 3
    SCORE = 0
    DIFFICULTY = 10
    INIT_LEVEL
ENDSUB

SUB FIRE_PLAYER_MISSILE()
    PlayerMissile.X = Player.X + 2
    PlayerMissile.Y = Player.Y - 4
    PlayerMissile.Visible = TRUE
    PlayerMissile.IsFiring = TRUE
ENDSUB

SUB FIRE_ALIEN_MISSILE(i)
    AlienMissile.X = Aliens.X[i] + 2
    AlienMissile.Y = Aliens.Y[i] + 2
    AlienMissile.Visible = TRUE
    AlienMissile.IsFiring = TRUE
ENDSUB

SUB PLAYER_DIE()
    Player.Visible = FALSE
    Player.RespawnTimer = 5
    LIVES = LIVES - 1
    IF LIVES < 0 THEN GAMEOVER = 2
ENDSUB

REM ======================================================================
REM GAME LOGIC AND UPDATES
REM ======================================================================

FUNC FIND_FIRST_HIT_INDEX(Projectile, Target)
    REM Performs a vectorized collision check.
    REM Returns the index of the first target hit, or -1 if no hit.
    
    HitMask = (Projectile.Y >= Target.Y) AND (Projectile.Y < Target.Y + 2) AND (Projectile.X >= Target.X) AND (Projectile.X < Target.X + 4) AND Target.Visible
    IF HitMask NOT FALSE THEN
        IF ANY(HitMask) THEN
            ' This is a vectorized method to find the index of the first TRUE value.
            ' 1. Create a score where non-hits are high (2) and hits are low (1).
            Scores = (HitMask * -1) + 2
            ' 2. Get the sort order; indices of hits will come first.
            GradeOrder = GRADE(Scores)
            ' 3. Take the very first index from the sorted list.
            RETURN TAKE(1, GradeOrder)[0]
        ENDIF
    ENDIF    
    RETURN -1
ENDFUNC

SUB CHECK_PLAYER_MISSILE_HITS()
    FOR i = 0 TO MAX_ALIENS - 1
        IF Aliens.Visible[i] THEN
            IF (PlayerMissile.X >= Aliens.X[i] AND PlayerMissile.X < Aliens.X[i] + 4) AND (PlayerMissile.Y >= Aliens.Y[i] AND PlayerMissile.Y < Aliens.Y[i] + 2) THEN
                Aliens.Visible[i] = FALSE
                SCORE = SCORE + Aliens.Points[i]
                PRINT Aliens.Points[i]
                PlayerMissile.Visible = 0
                PlayerMissile.IsFiring = 0
                EXITFOR                           
            ENDIF
        ENDIF
    NEXT i
ENDSUB

SUB UPDATE_GAME()
    REM --- MOVE PLAYER ---
    IF Player.Visible THEN
        Player.X = Player.X + Player.Direction
        IF Player.X < 2 THEN Player.X = 2
        IF Player.X > 75 THEN Player.X = 75
        Player.Direction = 0
    ELSE
        Player.RespawnTimer = Player.RespawnTimer - 1
        IF Player.RespawnTimer = 0 THEN Player.Visible = TRUE
    ENDIF

   IF PlayerMissile.Visible THEN
       PlayerMissile.Y = PlayerMissile.Y - 1
       IF PlayerMissile.Y < 3 THEN
           PlayerMissile.Visible = FALSE
           PlayerMissile.IsFiring = FALSE
       ELSE
           CHECK_PLAYER_MISSILE_HITS 
       ENDIF
   ENDIF

    REM --- MOVE ALIENS (VECTORIZED) ---
    NextX = Aliens.X + Aliens.Direction
    WallHits = (NextX < 2) OR (NextX > 75)
    MoveDown = ANY(WallHits AND Aliens.Visible)

    IF MoveDown THEN
        Aliens.Y = Aliens.Y + Aliens.Visible
        Aliens.Direction = Aliens.Direction * -1
        IF SPEED > DIFFICULTY THEN SPEED = SPEED - 1
    ELSE
        Aliens.X = Aliens.X + (Aliens.Direction * Aliens.Visible)
    ENDIF

    REM --- ALIEN LOGIC (FIRE, GAME OVER CHECK) ---
    AliveCount = SUM(Aliens.Visible)
    
    IF AlienMissile.IsFiring = FALSE AND AliveCount > 0 THEN
        IF RND(1) * 100 < 5 THEN
            VisibleAlienIndices = []
            FOR i = 0 TO MAX_ALIENS - 1
                IF Aliens.Visible[i] THEN VisibleAlienIndices = APPEND(VisibleAlienIndices, i)
            NEXT i
            RandomIndex = INT(RND(1) * AliveCount)
            AlienToFire = VisibleAlienIndices[RandomIndex]
            FIRE_ALIEN_MISSILE(AlienToFire)
        ENDIF
    ENDIF
    
    IF ANY(Aliens.Y > 32 AND Aliens.Visible) THEN GAMEOVER = 2
    IF AliveCount = 0 AND GAMEOVER = 0 THEN GAMEOVER = 1

    REM --- MOVE ALIEN MISSILE AND CHECK HITS (VECTORIZED) ---
   IF AlienMissile.Visible THEN
       AlienMissile.Y = AlienMissile.Y + 1
       IF AlienMissile.Y > 36 THEN
           AlienMissile.Visible = FALSE
           AlienMissile.IsFiring = FALSE
       ELSE
           ' Direct collision check for the player
           IF Player.Visible AND (AlienMissile.X >= Player.X AND AlienMissile.X < Player.X + 4 AND AlienMissile.Y >= Player.Y AND AlienMissile.Y < Player.Y + 2) THEN
               PLAYER_DIE()
               AlienMissile.Visible = FALSE
               AlienMissile.IsFiring = FALSE
           ELSE
               ' Vectorized collision check for the blocks
               BlockHitIndex = FIND_FIRST_HIT_INDEX(AlienMissile, Blocks)
               IF BlockHitIndex > -1 THEN
                   Blocks.Hits[BlockHitIndex] = Blocks.Hits[BlockHitIndex] + 1
                   IF Blocks.Hits[BlockHitIndex] >= 3 THEN Blocks.Visible[BlockHitIndex] = FALSE
                   AlienMissile.Visible = FALSE
                   AlienMissile.IsFiring = FALSE
               ENDIF
           ENDIF
       ENDIF
   ENDIF
ENDSUB

REM ======================================================================
REM RENDERING
REM ======================================================================

sub print_alien(i, f, t)
    LOCATE Aliens.Y[I], Aliens.X[I]
    print ALIEN_T[t*4+f*2]
    LOCATE Aliens.Y[I]+1, Aliens.X[I]
    print ALIEN_T[t*4+1+f*2]
endsub

SUB PRINT_PLAYER()
    LOCATE Player.Y, Player.X
    PRINT PLAYER_T[0]
    LOCATE Player.Y+1, Player.X
    PRINT PLAYER_T[1]
ENDSUB

SUB PRINT_BLOCK(I, HITS)
    LOCATE Blocks.Y[I], Blocks.X[I]
    IF HITS = 0 THEN
        PRINT BLOCK_A_T[0]
        LOCATE Blocks.Y[I]+1, Blocks.X[I]
        PRINT BLOCK_A_T[1]
    ENDIF
    IF HITS = 1 THEN
        PRINT BLOCK_B_T[0]
        LOCATE Blocks.Y[I]+1, Blocks.X[I]
        PRINT BLOCK_B_T[1]
    ENDIF
    IF HITS = 2 THEN
        PRINT BLOCK_C_T[0]
        LOCATE Blocks.Y[I]+1, Blocks.X[I]
        PRINT BLOCK_C_T[1]
    ENDIF
ENDSUB

SUB RENDER_SCREEN()
    CLS
    COLOR 7, 0
    LOCATE 1, 1
    PRINT "LIVES: " + STR$(LIVES);
    LOCATE 1, 35
    PRINT "JD INVADERS";
    LOCATE 1, 68
    PRINT "SCORE: " + STR$(SCORE);
    LOCATE 2, 1
    PRINT "--------------------------------------------------------------------------------";

    REM -- DRAW ALIENS --
    FOR I = 0 TO MAX_ALIENS - 1
        IF Aliens.Visible[I] = 1 THEN
            Spec = Aliens.Species[I]
            IF Spec = 0 THEN 
               COLOR 1, 0 ' Red
	        ENDIF
            IF Spec = 1 THEN 
               COLOR 2, 0 ' Green
	        ENDIF
            IF Spec = 2 THEN 
               COLOR 6, 0 ' Cyan
            ENDIF
	    PRINT_ALIEN I, FRAME, Spec
        ENDIF
    NEXT I
    
    REM -- DRAW BLOCKS --
    COLOR 1, 0 ' Gray
    FOR I = 0 TO MAX_BLOCKS - 1 
        IF Blocks.Visible[I] = 1 THEN 
            HITS = Blocks.Hits[I] 
            PRINT_BLOCK I, HITS 
        ENDIF
    NEXT I 

    REM -- DRAW PLAYER --
    IF Player.Visible = 1 THEN
        COLOR 4, 0 ' Blue
	    PRINT_PLAYER 
    ENDIF
    
    REM -- DRAW MISSILES --
    IF PlayerMissile.Visible = 1 THEN
        COLOR 7, 0 ' White
        LOCATE PlayerMissile.Y, PlayerMissile.X
	    PRINT P_MISSILE$;
    ENDIF
    IF AlienMissile.Visible = 1 THEN
        COLOR 1, 0 ' Red
        LOCATE AlienMissile.Y, AlienMissile.X
	    PRINT A_MISSILE$;
    ENDIF

    REM -- DRAW GAME OVER MESSAGES --
    IF GAMEOVER > 0 THEN
        COLOR 7, 0
        LOCATE 20, 35
	PRINT "GAME OVER"
        IF GAMEOVER = 1 THEN
            LOCATE 22, 28
	    PRINT "PRESS 'N' FOR NEXT LEVEL"
        ELSE
            LOCATE 22, 36
	    PRINT "YOU LOST"
            LOCATE 23, 29
	    PRINT "PRESS 'N' TO RESTART"
        ENDIF
    ENDIF
ENDSUB


REM ======================================================================
REM MAIN GAME LOOP
REM ======================================================================
SUB GAME_LOOP()
MAIN_LOOP:
    
    K$ = INKEY$()
    IF K$ = "z" or asc(k$) = 27 THEN 
	GOTO END_GAME
    ENDIF
    IF GAMEOVER > 0 THEN
        IF K$ = "n" THEN
            IF GAMEOVER = 1 THEN
                LIVES = LIVES + 1
                INIT_LEVEL
            ELSE
                INIT_GAME
            ENDIF
        ENDIF
    ENDIF

    IF Player.Visible = 1 THEN
        IF K$ = "a" THEN 
    	    Player.Direction = -1
    	ENDIF
        IF K$ = "d" THEN 
            Player.Direction = 1
        ENDIF
        IF K$ = " " AND PlayerMissile.IsFiring = 0 THEN 
            FIRE_PLAYER_MISSILE
        ENDIF
    ENDIF
    
    IF GAMEOVER = 0 THEN
        SFRAME = SFRAME + 1
        IF SFRAME > SPEED THEN
            UPDATE_GAME
	        RENDER_SCREEN
            SFRAME = 0
            FRAME = FRAME + 1
            IF FRAME > 1 then
            FRAME = 0
            ENDIF
        ENDIF
    ENDIF

    SLEEP 20
    GOTO MAIN_LOOP

END_GAME:
    CURSOR 1
    CLS
ENDSUB

INIT_GAME
GAME_LOOP

' --- End of File ---

' Test program for the new INVERT function

PRINT "--- INVERT Function Test ---"

' Define a 3x3 matrix that is known to be invertible
DIM A[3, 3]
A[0,0] = 1 : A[0,1] = 2 : A[0,2] = 3
A[1,0] = 0 : A[1,1] = 1 : A[1,2] = 4
A[2,0] = 5 : A[2,1] = 6 : A[2,2] = 0

PRINT "Original Matrix A:"
PRINT A
PRINT ""

' Calculate the inverse of A
PRINT "Calculating Inverse of A..."
DIM A_inv[0,0] ' Define, will be resized by the function
A_inv = INVERT(A)

PRINT "Inverse Matrix A_inv:"
PRINT A_inv
PRINT ""

' To verify, multiply A by its inverse. The result should be the identity matrix.
PRINT "Verifying by calculating A * A_inv..."
DIM Identity[0,0]
Identity = MATMUL(A, A_inv)

PRINT "Result of A * A_inv (should be Identity Matrix):"
PRINT Identity
PRINT ""

' --- Test a singular matrix ---
PRINT "--- Testing a Singular Matrix (should fail) ---"
DIM S[2,2]
S[0,0] = 1 : S[0,1] = 1
S[1,0] = 1 : S[1,1] = 1
PRINT "Singular matrix S:"
PRINT S
PRINT "Calling INVERT(S)..."
DIM S_inv[0,0]
S_inv = INVERT(S) ' This line will cause a runtime error

' The program will stop at the line above if error handling is correct.
' If it continues, the error was not caught.
PRINT "This line should not be printed."

' --- End of File ---

' --- Example for SELECT and FILTER with Lambdas ---

MyNumbers = IOTA(10)
PRINT "Original Array: "; FRMV$(MyNumbers)
PRINT

' Use SELECT with a lambda to transform every element
SquaredNumbers = SELECT(lambda x -> x * x, MyNumbers)
PRINT "After SELECT with lambda: "; FRMV$(SquaredNumbers)
PRINT

' Use FILTER with a lambda to keep only the even numbers
EvenNumbers = FILTER(lambda n -> (n MOD 2) = 0, MyNumbers)
PRINT "After FILTER with lambda: "; FRMV$(EvenNumbers)
PRINT

' Chain the operations together with lambdas!
result_nested = SELECT(lambda v -> v * 10, FILTER(lambda val -> val > 5, SELECT(lambda i -> i + 1, MyNumbers)))
PRINT "Chained lambda result: "; result_nested

' Expected Output:
' Original Array:           1 2 3 4 5 6 7 8 9 10
'
' After SELECT with lambda: 1 4 9 16 25 36 49 64 81 100
'
' After FILTER with lambda: 2 4 6 8 10
'
' Chained lambda result:    60 70 80 90 100 110
' --- End of File ---

' ==========================================================
' == An LLM with a Multi-Layer Transformer in jdBasic
' == Goal: Use stacked, normalized self-attention blocks for stable training.
' ==========================================================

CLS
PRINT "--- Building a Multi-Layer Transformer LLM ---"
PRINT

' --- Helper Functions (declared before use) ---
' NOTE: These functions are already efficient for this BASIC dialect.
' Using more complex vector functions would not improve their performance.
FUNC ONE_HOT_ENCODE_MATRIX(token_array, size)
    rows = LEN(token_array)
    matrix = []
    DIM matrix[rows, size]
    FOR r = 0 TO rows - 1
        FOR c = 0 to size - 1
            matrix[r, c] = 0
        NEXT c
        matrix[r, token_array[r]] = 1
    NEXT r
    RETURN matrix
ENDFUNC

FUNC SAMPLE(probs_array)
    r = RND(1)
    cdf = 0
    num_probs = LEN(probs_array)
    FOR i = 0 TO num_probs - 1
        cdf = cdf + probs_array[i]
        IF r < cdf THEN
            RETURN i
        ENDIF
    NEXT i
    RETURN num_probs - 1
ENDFUNC

' --- 1. Vocabulary and Data Setup ---
' *** MODIFIED: Using more training data is the best way to improve loss ***
'TEXT_DATA$ = "der schnelle braune fuchs springt über den faulen hund. the quick brown fox jumps over the lazy dog. zwei flinke boxer jagen die quirlige eva."
TEXT_DATA$ = TXTREADER$("trainingtext.txt")
PRINT "Vocabulary Data: "; TEXT_DATA$

' NOTE: This method of finding unique characters is clear and effective for a one-time setup.
VOCAB = []
FOR I = 0 TO LEN(TEXT_DATA$) - 1
    CHAR$ = MID$(TEXT_DATA$, I + 1, 1)
    IS_IN_VOCAB = 0
    if LEN(VOCAB) > 0 then
        FOR J = 0 TO LEN(VOCAB) - 1
            IF VOCAB[J] = CHAR$ THEN
                IS_IN_VOCAB = 1
                EXITFOR
            ENDIF
        NEXT J
    Endif
    IF IS_IN_VOCAB = 0 THEN
        VOCAB = APPEND(VOCAB, CHAR$)
    ENDIF
NEXT I

VOCAB_SIZE = LEN(VOCAB)
VOCAB_MAP = {}
FOR I = 0 TO VOCAB_SIZE - 1
    VOCAB_MAP{VOCAB[I]} = I
NEXT I

PRINT "Vocabulary Size: "; VOCAB_SIZE
PRINT "Vocabulary     : ", VOCAB
PRINT


' --- 2. Prepare Training Data ---
INPUT_TOKENS_ARRAY = TENSOR.TOKENIZE(TEXT_DATA$, VOCAB_MAP)
TARGET_TOKENS_ARRAY = APPEND(TAKE(LEN(INPUT_TOKENS_ARRAY) - 1, DROP(1, INPUT_TOKENS_ARRAY)), 0)


' --- 3. Model Definition ---
' *** MODIFIED: Increased model depth for more learning capacity ***
HIDDEN_DIM = 128
EMBEDDING_DIM = HIDDEN_DIM
NUM_LAYERS = 4 ' --- Stacking four Transformer blocks ---

MODEL = {}
MODEL{"embedding"} = TENSOR.CREATE_LAYER("EMBEDDING", {"vocab_size": VOCAB_SIZE, "embedding_dim": EMBEDDING_DIM})
MODEL{"output_norm"} = TENSOR.CREATE_LAYER("LAYER_NORM", {"dim": HIDDEN_DIM})
MODEL{"output"} = TENSOR.CREATE_LAYER("DENSE", {"input_size": HIDDEN_DIM, "units": VOCAB_SIZE})

' Create the stack of Transformer layers
MODEL{"layers"} = []
FOR i = 0 TO NUM_LAYERS - 1
    layer = {}
    layer{"attention"} = TENSOR.CREATE_LAYER("ATTENTION", {"embedding_dim": EMBEDDING_DIM})
    layer{"norm1"} = TENSOR.CREATE_LAYER("LAYER_NORM", {"dim": HIDDEN_DIM})
    layer{"ffn1"} = TENSOR.CREATE_LAYER("DENSE", {"input_size": HIDDEN_DIM, "units": HIDDEN_DIM * 2})
    layer{"ffn2"} = TENSOR.CREATE_LAYER("DENSE", {"input_size": HIDDEN_DIM * 2, "units": HIDDEN_DIM})
    layer{"norm2"} = TENSOR.CREATE_LAYER("LAYER_NORM", {"dim": HIDDEN_DIM})
    MODEL{"layers"} = APPEND(MODEL{"layers"}, layer)
NEXT i


' *** MODIFIED: Tuned hyperparameters for better convergence ***
LEARNING_RATE = 0.1
OPTIMIZER = TENSOR.CREATE_OPTIMIZER("SGD", {"learning_rate": LEARNING_RATE})
EPOCHS = 2000 ' Increased epochs for deeper model


' The core Transformer Block forward pass
FUNC FORWARD_PASS(input_tokens)
    SEQ_LEN = LEN(input_tokens)

    ' --- 1. Embedding + Positional Encoding ---
    one_hot_matrix = ONE_HOT_ENCODE_MATRIX(input_tokens, VOCAB_SIZE)
    one_hot_tensor = TENSOR.FROM(one_hot_matrix)
    embedding_weights = MODEL{"embedding"}{"weights"}
    x = TENSOR.MATMUL(one_hot_tensor, embedding_weights)
    x = x + TENSOR.POSITIONAL_ENCODING(SEQ_LEN, HIDDEN_DIM)

    ' --- 2. Pass through the stack of Transformer Layers ---
    FOR i = 0 TO NUM_LAYERS - 1
        layer = MODEL{"layers"}[i]
        
        ' --- Pre-LN Self-Attention ---
        norm1_out = TENSOR.LAYERNORM(x, layer{"norm1"}{"gain"}, layer{"norm1"}{"bias"})
        attn_layer = layer{"attention"}
        Wq = attn_layer{"Wq"}
        Wk = attn_layer{"Wk"}
        Wv = attn_layer{"Wv"}
        Q = TENSOR.MATMUL(norm1_out, Wq)
        K = TENSOR.MATMUL(norm1_out, Wk)
        V = TENSOR.MATMUL(norm1_out, Wv)
        attn_scores = TENSOR.MATMUL(Q, TENSOR.FROM(TRANSPOSE(TENSOR.TOARRAY(K)))) / SQR(HIDDEN_DIM)
        
        attn_probs = TENSOR.SOFTMAX(attn_scores, TRUE) 

        attention_output = TENSOR.MATMUL(attn_probs, V)
        x = x + attention_output ' Residual connection

        ' --- Pre-LN Feed-Forward ---
        norm2_out = TENSOR.LAYERNORM(x, layer{"norm2"}{"gain"}, layer{"norm2"}{"bias"})
        ffn1_out = TENSOR.RELU(TENSOR.MATMUL(norm2_out, layer{"ffn1"}{"weights"}) + layer{"ffn1"}{"bias"})
        ffn2_out = TENSOR.MATMUL(ffn1_out, layer{"ffn2"}{"weights"}) + layer{"ffn2"}{"bias"}
        x = x + ffn2_out ' Residual connection
    NEXT i
    
    ' --- 3. Final Output ---
    final_norm = TENSOR.LAYERNORM(x, MODEL{"output_norm"}{"gain"}, MODEL{"output_norm"}{"bias"})
    logits = TENSOR.MATMUL(final_norm, MODEL{"output"}{"weights"}) + MODEL{"output"}{"bias"}
    
    RETURN logits
ENDFUNC

' --- 5. Training Loop ---
PRINT "--- Starting Training... ---"
PRINT

FOR EPI = 1 TO EPOCHS
    logits_tensor = FORWARD_PASS(INPUT_TOKENS_ARRAY)
    target_one_hot_matrix = ONE_HOT_ENCODE_MATRIX(TARGET_TOKENS_ARRAY, VOCAB_SIZE)
    target_tensor = TENSOR.FROM(target_one_hot_matrix)
    
    loss_tensor = TENSOR.CROSS_ENTROPY_LOSS(logits_tensor, target_tensor)
    TENSOR.BACKWARD loss_tensor
    MODEL = TENSOR.UPDATE(MODEL, OPTIMIZER)

    IF EPI MOD 10 = 0 THEN
        PRINT "Epoch:"; EPI; ", Loss:"; TENSOR.TOARRAY(loss_tensor)[0]
    ENDIF
    
    ' ***Implement learning rate decay for better fine-tuning ***
    IF EPI MOD 2000 = 0 AND LEARNING_RATE > 0.005 THEN
        LEARNING_RATE = LEARNING_RATE / 2
        OPTIMIZER = TENSOR.CREATE_OPTIMIZER("SGD", {"learning_rate": LEARNING_RATE})
        PRINT "New learning rate: "; LEARNING_RATE
    ENDIF

NEXT EPI

PRINT
PRINT "--- Training Complete ---"
PRINT

' --- 6. Inference / Text Generation ---
PRINT "--- Generating Text ---"
PRINT "Seed text: 'Atomi'"

generated_text$ = "Atomi"

FOR i = 1 TO 200
    inference_input_tokens = TENSOR.TOKENIZE(generated_text$, VOCAB_MAP)
    
    all_logits_tensor = FORWARD_PASS(inference_input_tokens)
    all_logits_array = TENSOR.TOARRAY(all_logits_tensor)
    
    last_row_index = LEN(inference_input_tokens) - 1
    last_logits_vector = SLICE(all_logits_array, 0, last_row_index)
    
    last_logits_tensor = TENSOR.FROM(last_logits_vector)
    probs_tensor = TENSOR.SOFTMAX(last_logits_tensor)
    
    probs_array = TENSOR.TOARRAY(probs_tensor)
    
    next_token_id = SAMPLE(probs_array)
    
    generated_text$ = generated_text$ + VOCAB[next_token_id]

    Print VOCAB[next_token_id];
    
NEXT i

PRINT
PRINT "Generated Output:"
PRINT generated_text$
PRINT

' --- End of File ---

' test_simple.txt (Corrected)

PRINT "--- Testing Simple MATMUL and Backward Pass ---"

' 1. Create two simple tensors
A_arr = [[1, 2], [3, 4]]
B_arr = [[5, 6], [7, 8]]

A = TENSOR.FROM(A_arr)
B = TENSOR.FROM(B_arr)

' 2. Forward Pass
C = TENSOR.MATMUL(A, B)
PRINT "C (Result of A @ B):"
PRINT FRMV$(TENSOR.TOARRAY(C))
PRINT

' 3. Backward Pass
TENSOR.BACKWARD C

' 4. Check Gradients
' Access the .grad property of the tensor
PRINT "Gradient of A:"
PRINT FRMV$(TENSOR.TOARRAY(A.grad))
PRINT

PRINT "Gradient of B:"
PRINT FRMV$(TENSOR.TOARRAY(B.grad))
PRINT
' --- End of File ---

' ==========================================================
' == An LLM with a Multi-Layer Transformer in jdBasic
' == Goal: Use stacked, normalized self-attention blocks for stable training.
' ==========================================================

CLS
PRINT "--- Building a Multi-Layer Transformer LLM ---"
PRINT

' --- Helper Functions (declared before use) ---
' NOTE: These functions are already efficient for this BASIC dialect.
' Using more complex vector functions would not improve their performance.
FUNC ONE_HOT_ENCODE_MATRIX(token_array, size)
    rows = LEN(token_array)
    matrix = []
    DIM matrix[rows, size]
    FOR r = 0 TO rows - 1
        FOR c = 0 to size - 1
            matrix[r, c] = 0
        NEXT c
        matrix[r, token_array[r]] = 1
    NEXT r
    RETURN matrix
ENDFUNC

FUNC SAMPLE(probs_array)
    r = RND(1)
    cdf = 0
    num_probs = LEN(probs_array)
    FOR i = 0 TO num_probs - 1
        cdf = cdf + probs_array[i]
        IF r < cdf THEN
            RETURN i
        ENDIF
    NEXT i
    RETURN num_probs - 1
ENDFUNC

' --- 1. Vocabulary and Data Setup ---
' *** MODIFIED: Using more training data is the best way to improve loss ***
'TEXT_DATA$ = "der schnelle braune fuchs springt über den faulen hund. the quick brown fox jumps over the lazy dog. zwei flinke boxer jagen die quirlige eva."
TEXT_DATA$ = TXTREADER$("trainingtext.txt")
PRINT "Vocabulary Data: "; TEXT_DATA$

' NOTE: This method of finding unique characters is clear and effective for a one-time setup.
VOCAB = []
FOR I = 0 TO LEN(TEXT_DATA$) - 1
    CHAR$ = MID$(TEXT_DATA$, I + 1, 1)
    IS_IN_VOCAB = 0
    if LEN(VOCAB) > 0 then
        FOR J = 0 TO LEN(VOCAB) - 1
            IF VOCAB[J] = CHAR$ THEN
                IS_IN_VOCAB = 1
                EXITFOR
            ENDIF
        NEXT J
    Endif
    IF IS_IN_VOCAB = 0 THEN
        VOCAB = APPEND(VOCAB, CHAR$)
    ENDIF
NEXT I

VOCAB_SIZE = LEN(VOCAB)
VOCAB_MAP = {}
FOR I = 0 TO VOCAB_SIZE - 1
    VOCAB_MAP{VOCAB[I]} = I
NEXT I

PRINT "Vocabulary Size:"; VOCAB_SIZE
PRINT


' --- 2. Prepare Training Data ---
INPUT_TOKENS_ARRAY = TENSOR.TOKENIZE(TEXT_DATA$, VOCAB_MAP)
TARGET_TOKENS_ARRAY = APPEND(TAKE(LEN(INPUT_TOKENS_ARRAY) - 1, DROP(1, INPUT_TOKENS_ARRAY)), 0)


' --- 3. Model Definition ---
' *** MODIFIED: Increased model depth for more learning capacity ***
HIDDEN_DIM = 128
EMBEDDING_DIM = HIDDEN_DIM
NUM_LAYERS = 4 ' --- Stacking four Transformer blocks ---

MODEL = {}
MODEL{"embedding"} = TENSOR.CREATE_LAYER("EMBEDDING", {"vocab_size": VOCAB_SIZE, "embedding_dim": EMBEDDING_DIM})
MODEL{"output_norm"} = TENSOR.CREATE_LAYER("LAYER_NORM", {"dim": HIDDEN_DIM})
MODEL{"output"} = TENSOR.CREATE_LAYER("DENSE", {"input_size": HIDDEN_DIM, "units": VOCAB_SIZE})

' Create the stack of Transformer layers
MODEL{"layers"} = []
FOR i = 0 TO NUM_LAYERS - 1
    layer = {}
    layer{"attention"} = TENSOR.CREATE_LAYER("ATTENTION", {"embedding_dim": EMBEDDING_DIM})
    layer{"norm1"} = TENSOR.CREATE_LAYER("LAYER_NORM", {"dim": HIDDEN_DIM})
    layer{"ffn1"} = TENSOR.CREATE_LAYER("DENSE", {"input_size": HIDDEN_DIM, "units": HIDDEN_DIM * 2})
    layer{"ffn2"} = TENSOR.CREATE_LAYER("DENSE", {"input_size": HIDDEN_DIM * 2, "units": HIDDEN_DIM})
    layer{"norm2"} = TENSOR.CREATE_LAYER("LAYER_NORM", {"dim": HIDDEN_DIM})
    MODEL{"layers"} = APPEND(MODEL{"layers"}, layer)
NEXT i


' *** MODIFIED: Tuned hyperparameters for better convergence ***
LEARNING_RATE = 0.1
OPTIMIZER = TENSOR.CREATE_OPTIMIZER("SGD", {"learning_rate": LEARNING_RATE})
EPOCHS = 20000 ' Increased epochs for deeper model

' The core Transformer Block forward pass
' *** MODIFIED: Function now accepts the model to use as a parameter ***
FUNC FORWARD_PASS(current_model, input_tokens)
    SEQ_LEN = LEN(input_tokens)

    ' --- 1. Embedding + Positional Encoding ---
    one_hot_matrix = ONE_HOT_ENCODE_MATRIX(input_tokens, VOCAB_SIZE)
    one_hot_tensor = TENSOR.FROM(one_hot_matrix)
    embedding_weights = current_model{"embedding"}{"weights"}
    x = TENSOR.MATMUL(one_hot_tensor, embedding_weights)
    x = x + TENSOR.POSITIONAL_ENCODING(SEQ_LEN, HIDDEN_DIM)

    ' --- 2. Pass through the stack of Transformer Layers ---
    FOR i = 0 TO NUM_LAYERS - 1
        layer = current_model{"layers"}[i]
        
        ' --- Pre-LN Self-Attention ---
        norm1_out = TENSOR.LAYERNORM(x, layer{"norm1"}{"gain"}, layer{"norm1"}{"bias"})
        attn_layer = layer{"attention"}
        Wq = attn_layer{"Wq"}
        Wk = attn_layer{"Wk"}
        Wv = attn_layer{"Wv"}
        Q = TENSOR.MATMUL(norm1_out, Wq)
        K = TENSOR.MATMUL(norm1_out, Wk)
        V = TENSOR.MATMUL(norm1_out, Wv)
        attn_scores = TENSOR.MATMUL(Q, TENSOR.FROM(TRANSPOSE(TENSOR.TOARRAY(K)))) / SQR(HIDDEN_DIM)
                
        attn_probs = TENSOR.SOFTMAX(attn_scores, TRUE) 

        attention_output = TENSOR.MATMUL(attn_probs, V)
        x = x + attention_output ' Residual connection

        ' --- Pre-LN Feed-Forward ---
        norm2_out = TENSOR.LAYERNORM(x, layer{"norm2"}{"gain"}, layer{"norm2"}{"bias"})
        ffn1_out = TENSOR.RELU(TENSOR.MATMUL(norm2_out, layer{"ffn1"}{"weights"}) + layer{"ffn1"}{"bias"})
        ffn2_out = TENSOR.MATMUL(ffn1_out, layer{"ffn2"}{"weights"}) + layer{"ffn2"}{"bias"}
        x = x + ffn2_out ' Residual connection
    NEXT i
    
    ' --- 3. Final Output ---
    final_norm = TENSOR.LAYERNORM(x, current_model{"output_norm"}{"gain"}, current_model{"output_norm"}{"bias"})
    logits = TENSOR.MATMUL(final_norm, current_model{"output"}{"weights"}) + current_model{"output"}{"bias"}
    
    RETURN logits
ENDFUNC

' --- 5. Training Loop ---
PRINT "--- Starting Training... ---"
PRINT

FOR EPI = 1 TO EPOCHS
    logits_tensor = FORWARD_PASS(MODEL, INPUT_TOKENS_ARRAY)
    target_one_hot_matrix = ONE_HOT_ENCODE_MATRIX(TARGET_TOKENS_ARRAY, VOCAB_SIZE)
    target_tensor = TENSOR.FROM(target_one_hot_matrix)
    
    loss_tensor = TENSOR.CROSS_ENTROPY_LOSS(logits_tensor, target_tensor)
    TENSOR.BACKWARD loss_tensor
    MODEL = TENSOR.UPDATE(MODEL, OPTIMIZER)

    IF EPI MOD 100 = 0 THEN
        PRINT "Epoch:"; EPI; ", Loss:"; TENSOR.TOARRAY(loss_tensor)[0]
    ENDIF
    
    ' *** MODIFIED: Implement learning rate decay for better fine-tuning ***
    IF EPI MOD 500 = 0 AND LEARNING_RATE > 0.005 THEN
        LEARNING_RATE = LEARNING_RATE / 2
        OPTIMIZER = TENSOR.CREATE_OPTIMIZER("SGD", {"learning_rate": LEARNING_RATE})
        PRINT "New learning rate: "; LEARNING_RATE
    ENDIF
NEXT EPI

PRINT
PRINT "--- Training Complete ---"
PRINT

' --- 6. Save and Load the Trained Model ---

PRINT "--- Saving Model ---"
TENSOR.SAVEMODEL MODEL, "llm_model.json"
PRINT "Model saved to llm_model.json"
PRINT

PRINT "--- Loading Model for Inference ---"
LOADED_MODEL = TENSOR.LOADMODEL("llm_model.json")
IF LEN(LOADED_MODEL)=0 THEN
    PRINT "Failed to load model!"
    END
ENDIF
PRINT "Model loaded successfully."
PRINT

' --- 7. Inference / Text Generation using the LOADED model ---
PRINT "--- Generating Text from Loaded Model ---"
generated_text$ = "Computerwelt"
PRINT "Seed text: "; generated_text$

FOR i = 1 TO 200
    inference_input_tokens = TENSOR.TOKENIZE(generated_text$, VOCAB_MAP)
    
    all_logits_tensor = FORWARD_PASS(LOADED_MODEL, inference_input_tokens)
    all_logits_array = TENSOR.TOARRAY(all_logits_tensor)
    
    last_row_index = LEN(inference_input_tokens) - 1
    last_logits_vector = SLICE(all_logits_array, 0, last_row_index)
    
    last_logits_tensor = TENSOR.FROM(last_logits_vector)
    probs_tensor = TENSOR.SOFTMAX(last_logits_tensor)
    
    probs_array = TENSOR.TOARRAY(probs_tensor)
    
    next_token_id = SAMPLE(probs_array)
    
    generated_text$ = generated_text$ + VOCAB[next_token_id]
    
NEXT i

PRINT
PRINT "Generated Output:"
PRINT generated_text$
PRINT

' --- End of File ---

MY_NUMBER = 1234567.89

PRINT "Default 'C' Locale:"
PRINT MY_NUMBER
PRINT ""

' For Windows, locale names are "German", "French", etc.
' On Linux, they are often "de_DE.UTF-8", "fr_FR.UTF-8"
PRINT "Setting locale to German..."
SETLOCALE "German"

PRINT "German Locale:"
PRINT MY_NUMBER

' The CSVWRITER will now also use this format!
DATA = RESHAPE([PI, MY_NUMBER], [1, 2])
CSVWRITER "german_numbers.csv", DATA, ";"

PRINT "german_numbers.csv has been written."

' --- End of File ---

Print "Do until loop"
i = 0
Do until i > 4
   Print "I: "; I
   i = i + 1
loop

Print "Do while loop"
i = 0
Do while i < 4
   Print "I: "; I
   i = i + 1
loop

Print "Do loop until"
i = 0
Do 
   Print "I: "; I
   i = i + 1
loop until i > 4

Print "Do loop while"
i = 0
Do 
   Print "I: "; I
   i = i + 1
loop while i < 4


' --- End of File ---

' Program to combine all .jdb files into a single file.

PRINT "Starting to combine all .jdb files..."

' 1. Get a list of all files with the .jdb extension
jdb_files$ = DIR$("*.jdb")

' Check if any files were found
IF LEN(jdb_files$) = 0 THEN
    PRINT "No .jdb files found in the current directory."
    STOP
ENDIF

PRINT "Found " + STR$(LEN(jdb_files$)) + " files to combine."

' 2. Initialize an empty string to hold all the code
combined_code$ = ""
file_separator$ = CHR$(13) + CHR$(10) + "' --- End of File ---" + CHR$(13) + CHR$(10) + CHR$(13) + CHR$(10)

' 3. Loop through the list of files
FOR i = 0 TO LEN(jdb_files$) - 1
    current_file$ = jdb_files$[i]
    PRINT "Reading: "; current_file$
    
    ' Read the entire content of the current file
    file_content$ = TXTREADER$(current_file$)
    
    ' Append the content to our master string, followed by a separator
    combined_code$ = combined_code$ + file_content$ + file_separator$
NEXT i

' 4. Write the combined string to a new file
output_filename$ = "all_code.txt"
PRINT "Writing combined code to: "; output_filename$
TXTWRITER output_filename$, combined_code$

PRINT "Done. All files have been combined into 'all_code.jdb'."
' --- End of File ---

' Mandelbrot Set Generator for jdBasic
' -------------------------------------
' This program calculates and draws the Mandelbrot fractal.
' It iterates through each pixel, mapping it to the complex plane
' and coloring it based on how quickly the value escapes to infinity.

' --- 1. Configuration and Setup ---
SCREEN_W = 800
SCREEN_H = 600
CALC_W = 400
CALC_H = 300
DX = SCREEN_W / CALC_W
DY = SCREEN_H / CALC_H

MAX_ITERATIONS = 50 ' Increase for more detail, but slower rendering

' Define the view of the complex plane to render
' Default view
X_MIN = -2.0
X_MAX = 1.0
Y_MIN = -1.0
Y_MAX = 1.0

' A more zoomed-in view to see more detail
' X_MIN = -0.75
' X_MAX = -0.74
' Y_MIN = 0.1
' Y_MAX = 0.11

' --- 2. Initialize Graphics ---
PRINT "Initializing graphics screen..."
SCREEN SCREEN_W, SCREEN_H, "Mandelbrot Set in jdBasic"
CLS 0, 0, 0 ' Clear screen to black

' --- 3. Main Calculation and Drawing Loop ---
PRINT "Calculating Mandelbrot set... This may take a moment."

' Loop through every pixel on the screen
FOR PY = 0 TO CALC_H - 1
  FOR PX = 0 TO CALC_W - 1
    ' Map the pixel coordinates (PX, PY) to a complex number (C_REAL, C_IMAG)
    C_REAL = X_MIN + (PX / CALC_W) * (X_MAX - X_MIN)
    C_IMAG = Y_MIN + (PY / CALC_H) * (Y_MAX - Y_MIN)

    ' Initialize the iteration variables for this point
    Z_REAL = 0
    Z_IMAG = 0
    ITER = 0

    ' The main Mandelbrot iteration loop
    DO WHILE (Z_REAL * Z_REAL + Z_IMAG * Z_IMAG) <= 4 AND ITER < MAX_ITERATIONS
      ' Calculate z^2 + c
      Z_REAL_NEW = (Z_REAL * Z_REAL - Z_IMAG * Z_IMAG) + C_REAL
      Z_IMAG_NEW = (2 * Z_REAL * Z_IMAG) + C_IMAG

      ' Update z for the next iteration
      Z_REAL = Z_REAL_NEW
      Z_IMAG = Z_IMAG_NEW

      ITER = ITER + 1
    LOOP

    ' --- 4. Coloring the Pixel ---
    ' If the loop finished because it reached max iterations, the point is in the set.
    IF ITER = MAX_ITERATIONS THEN
      ' Draw a black pixel for points inside the set
      RECT PX*DX, PY*DY, DX, DY, 0, 0, 0, TRUE
    ELSE
      ' The point is outside the set. Color it based on the escape time (ITER).
      ' This creates the colorful bands around the set.
      R = (ITER * 8) MOD 255
      G = (ITER * 5) MOD 255
      B = (ITER * 12) MOD 255
      RECT PX*DX, PY*DY, DX, DY, R, G, B, TRUE
    ENDIF
  NEXT PX
  PRINT "ROW: "; PY
NEXT PY

' --- 5. Display the Final Image and Wait ---
PRINT "Calculation complete. Displaying result."
SCREENFLIP ' Push the completed drawing to the screen

PRINT "Press any key to exit."
' Wait for a key press before closing the window
do
 a$ = inkey$()
 sleep 10
loop until a$ > ""

' --- End of File ---

' Mandelbrot Set Generator for jdBasic (Interactive Zoom)
' --------------------------------------------------------------------
' This program interactively calculates and draws the Mandelbrot fractal.
'
' - It uses APL-style array operations for high performance.
' - Click on the image to zoom in on that point.
' - Press the ESC key to exit the program.
' --------------------------------------------------------------------

' --- 1. Global Configuration and Setup ---
SCREEN_W = 1920
SCREEN_H = 1080
MAX_ITERATIONS = 100 ' Increase for more detail, but slower rendering
CALC_W = 384         ' Increased calculation resolution for better zoom quality
CALC_H = 216
DX = SCREEN_W / CALC_W
DY = SCREEN_H / CALC_H

' Define the initial view of the complex plane
X_MIN = -2.0
X_MAX = 1.0
Y_MIN = -1.5
Y_MAX = 1.5

' --- 2. Initialize Graphics ---
PRINT "Initializing graphics screen..."
SCREEN SCREEN_W, SCREEN_H, "Interactive Mandelbrot Set in jdBasic"
CLS 0, 0, 0 ' Clear screen to black


' ====================================================================
' ==  SUBROUTINE TO CALCULATE AND DRAW THE FRACTAL
' ====================================================================
SUB CalculateAndDrawMandelbrot()
    ' This subroutine contains the core calculation and drawing logic.
    ' It is called once at the start and every time we zoom.

    ' --- 3. Vectorized Coordinate Setup ---
    PRINT "Creating coordinate matrices for the current view..."

    ' Create 1D vectors for all X and Y coordinates on the screen
    PX_VEC = (IOTA(CALC_W) - 1) / (CALC_W - 1)
    PY_VEC = (IOTA(CALC_H) - 1) / (CALC_H - 1)

    ' Use OUTER to expand the 1D vectors into 2D coordinate matrices
    C_REAL = OUTER(PY_VEC*0, PX_VEC, "+") * (X_MAX - X_MIN) + X_MIN
    C_IMAG = OUTER(PY_VEC, PX_VEC*0, "+") * (Y_MAX - Y_MIN) + Y_MIN


    ' --- 4. Vectorized Iteration ---
    PRINT "Calculating Mandelbrot set with matrix operations..."

    ' Initialize Z and iteration-count matrices
    Z_REAL = RESHAPE([0], [CALC_H, CALC_W])
    Z_IMAG = RESHAPE([0], [CALC_H, CALC_W])
    ITERATIONS = RESHAPE([0], [CALC_H, CALC_W])

    ' This loop replaces the inner DO/WHILE. It iterates for all points at once.
    FOR I = 1 TO MAX_ITERATIONS
      ' Create a boolean mask of points that are still within the escape radius
      STILL_CALCULATING_MASK = (Z_REAL^2 + Z_IMAG^2) <= 4

      ' If all points have escaped, we can stop early
      IF NOT ANY(STILL_CALCULATING_MASK) THEN EXITFOR

      ' Increment iteration count only for points still being calculated
      ITERATIONS = ITERATIONS + STILL_CALCULATING_MASK

      ' Calculate z^2 + c for all points
      Z_REAL_NEW = (Z_REAL^2 - Z_IMAG^2) + C_REAL
      Z_IMAG_NEW = (2 * Z_REAL * Z_IMAG) + C_IMAG

      ' Update Z values only for the points still inside the mask
      Z_REAL = Z_REAL_NEW * STILL_CALCULATING_MASK + Z_REAL * (1 - STILL_CALCULATING_MASK)
      Z_IMAG = Z_IMAG_NEW * STILL_CALCULATING_MASK + Z_IMAG * (1 - STILL_CALCULATING_MASK)
    NEXT I


    ' --- 5. Vectorized Coloring ---
    PRINT "Calculating final color matrix..."

    ' Create a mask for points inside the set (those that reached max iterations)
    INSIDE_SET_MASK = (ITERATIONS >= MAX_ITERATIONS)

    ' Calculate colors for points outside the set based on escape time
    R = (ITERATIONS * 8) MOD 255
    G = (ITERATIONS * 5) MOD 255
    B = (ITERATIONS * 12) MOD 255

    ' Apply the "inside set" mask to make those pixels black
    R = R * (1 - INSIDE_SET_MASK)
    G = G * (1 - INSIDE_SET_MASK)
    B = B * (1 - INSIDE_SET_MASK)

    ' Pack the R, G, and B matrices into a single integer color matrix
    ' The formula is equivalent to (R << 16) | (G << 8) | B
    COLOR_MATRIX = R * 65536 + G * 256 + B


    ' --- 6. Draw the Final Image ---
    PRINT "Drawing final image with PLOTRAW..."

    ' Call the high-performance procedure to draw the entire matrix at once
    PLOTRAW 0, 0, COLOR_MATRIX, DX, DY

    ' Push the completed drawing to the screen
    SCREENFLIP
    PRINT "Ready. Click to zoom or press ESC to exit."
ENDSUB


' ====================================================================
' ==  MAIN INTERACTIVE LOOP
' ====================================================================

' First, draw the initial view
CalculateAndDrawMandelbrot

DO
    ' --- Check for User Input ---
    ' Check for a left mouse button click
    IF MOUSEB(1) THEN
        MX = MOUSEX()
        MY = MOUSEY()
        PRINT "Mouse clicked at: "; MX; ", "; MY

        ' --- Zoom Logic ---
        ' Convert screen coordinates (MX, MY) to complex plane coordinates
        CLICK_REAL = X_MIN + (MX / SCREEN_W) * (X_MAX - X_MIN)
        CLICK_IMAG = Y_MIN + (MY / SCREEN_H) * (Y_MAX - Y_MIN)

        ' Define how much to zoom in. 2.0 means the view will be half the size.
        ZOOM_FACTOR = 2.0

        ' Calculate the new width and height of the view in the complex plane
        NEW_WIDTH = (X_MAX - X_MIN) / ZOOM_FACTOR
        NEW_HEIGHT = (Y_MAX - Y_MIN) / ZOOM_FACTOR

        ' Recenter the view on the point that was clicked
        X_MIN = CLICK_REAL - NEW_WIDTH / 2
        X_MAX = CLICK_REAL + NEW_WIDTH / 2
        Y_MIN = CLICK_IMAG - NEW_HEIGHT / 2
        Y_MAX = CLICK_IMAG + NEW_HEIGHT / 2

        ' Now that the view coordinates are updated, recalculate and redraw
        CalculateAndDrawMandelbrot
    ENDIF

    ' Check if the user pressed a key
    KEY$ = INKEY$()
    IF KEY$ <> "" THEN
        ' Check if the pressed key was ESC (ASCII code 27)
        IF ASC(KEY$) = 27 THEN
            EXITDO ' Exit the main loop
        ENDIF
    ENDIF

    ' Pause briefly to prevent the loop from using 100% CPU
    SLEEP 20
LOOP

PRINT "Program finished."
' --- End of File ---

' Mandelbrot Set Generator for jdBasic (Vectorized & Optimized Drawing)
' --------------------------------------------------------------------
' This program calculates and draws the Mandelbrot fractal using
' APL-style array operations and a high-performance raw plotting procedure.

' --- 1. Configuration and Setup ---
SCREEN_W = 1920
 SCREEN_H = 1080
MAX_ITERATIONS = 50 ' Increase for more detail, but slower rendering
CALC_W = 192
CALC_H = 108
DX = SCREEN_W / CALC_W
DY = SCREEN_H / CALC_H
' Define the view of the complex plane to render
X_MIN = -2.0
X_MAX = 1.0
Y_MIN = -1.0
Y_MAX = 1.0

' A more zoomed-in view to see more detail
'X_MIN = -0.75
'X_MAX = -0.74
'Y_MIN = 0.1
'Y_MAX = 0.11

' --- 2. Initialize Graphics ---
PRINT "Initializing graphics screen..."
SCREEN SCREEN_W, SCREEN_H, "Mandelbrot Set in jdBasic (Vectorized)"
CLS 0, 0, 0 ' Clear screen to black

' --- 3. Vectorized Coordinate Setup ---
PRINT "Creating coordinate matrices..."

' Create 1D vectors for all X and Y coordinates on the screen
PX_VEC = (IOTA(CALC_W) - 1) / (CALC_W - 1)
PY_VEC = (IOTA(CALC_H) - 1) / (CALC_H - 1)

' Use OUTER to expand the 1D vectors into 2D coordinate matrices
C_REAL = OUTER(PY_VEC*0, PX_VEC, "+") * (X_MAX - X_MIN) + X_MIN
C_IMAG = OUTER(PY_VEC, PX_VEC*0, "+") * (Y_MAX - Y_MIN) + Y_MIN


' --- 4. Vectorized Iteration ---
PRINT "Calculating Mandelbrot set with matrix operations..."

' Initialize Z and iteration-count matrices
Z_REAL = RESHAPE([0], [CALC_H, CALC_W])
Z_IMAG = RESHAPE([0], [CALC_H, CALC_W])
ITERATIONS = RESHAPE([0], [CALC_H, CALC_W])

' This loop replaces the inner DO/WHILE. It iterates for all points at once.
FOR I = 1 TO MAX_ITERATIONS
  ' Create a boolean mask of points that are still within the escape radius
  STILL_CALCULATING_MASK = (Z_REAL^2 + Z_IMAG^2) <= 4

  ' If all points have escaped, we can stop early
  IF NOT ANY(STILL_CALCULATING_MASK) THEN EXITFOR

  ' Increment iteration count only for points still being calculated
  ITERATIONS = ITERATIONS + STILL_CALCULATING_MASK

  ' Calculate z^2 + c for all points
  Z_REAL_NEW = (Z_REAL^2 - Z_IMAG^2) + C_REAL
  Z_IMAG_NEW = (2 * Z_REAL * Z_IMAG) + C_IMAG

  ' Update Z values only for the points still inside the mask
  Z_REAL = Z_REAL_NEW * STILL_CALCULATING_MASK + Z_REAL * (1 - STILL_CALCULATING_MASK)
  Z_IMAG = Z_IMAG_NEW * STILL_CALCULATING_MASK + Z_IMAG * (1 - STILL_CALCULATING_MASK)
  PRINT "Calculating iteration: "; I
NEXT I


' --- 5. Vectorized Coloring ---
PRINT "Calculating final color matrix..."

' Create a mask for points inside the set (those that reached max iterations)
INSIDE_SET_MASK = (ITERATIONS = MAX_ITERATIONS)

' Calculate colors for points outside the set based on escape time
R = (ITERATIONS * 8) MOD 255
G = (ITERATIONS * 5) MOD 255
B = (ITERATIONS * 12) MOD 255

' Apply the "inside set" mask to make those pixels black
R = R * (1 - INSIDE_SET_MASK)
G = G * (1 - INSIDE_SET_MASK)
B = B * (1 - INSIDE_SET_MASK)

' Pack the R, G, and B matrices into a single integer color matrix
' The formula is equivalent to (R << 16) | (G << 8) | B
COLOR_MATRIX = R * 65536 + G * 256 + B


' --- 6. Draw the Final Image ---
PRINT "Drawing final image with PLOTRAW..."

' Call the new high-performance procedure to draw the entire matrix at once
PLOTRAW 0, 0, COLOR_MATRIX, DX, DY

' Push the completed drawing to the screen
SCREENFLIP

PRINT "Calculation complete. Press any key to exit."
do
 a$ = inkey$()
 sleep 10
loop until a$ > ""


' --- End of File ---

DIM my_map AS MAP
my_map{"name"} = "Atomi"
my_map{"level"} = 99

PRINT MAP.EXISTS(my_map, "level")   ' Prints TRUE
PRINT MAP.EXISTS(my_map, "armor")   ' Prints FALSE

IF MAP.EXISTS(my_map, "name") THEN
    PRINT "Name is: "; my_map{"name"}
ENDIF

DIM my_map AS MAP
my_map{"name"} = "Atomi"
my_map{"level"} = 99
my_map{"class"} = "Interpreter"

key_array = MAP.KEYS(my_map)

PRINT "Map contains the following keys:"
FOR i = 0 TO LEN(key_array) - 1
    PRINT "- "; key_array[i]
NEXT i
' Output:
' - CLASS
' - LEVEL
' - NAME
' (Note: std::map stores keys in alphabetical order)

DIM my_map AS MAP
my_map{"name"} = "Atomi"
my_map{"level"} = 99
my_map{"class"} = "Interpreter"

value_array = MAP.VALUES(my_map)

PRINT "Map contains the following values:"
FOR i = 0 TO LEN(value_array) - 1
    PRINT "- "; value_array[i]
NEXT i
' Output:
' - Interpreter
' - 99
' - Atomi

' --- End of File ---

' --- Map Data Type Test ---
DIM person AS MAP
PRINT "Assigning values to the map..."
person{"name"} = "John Doe"
person{"age"} = 42
person{"city"} = "New York"
person{"verified"} = TRUE

PRINT "The complete map is: "; person
PRINT ""
PRINT "Accessing individual values:"
PRINT "Name: "; person{"name"}
PRINT "Age: "; person{"age"}

' Update a value
person{"age"} = person{"age"} + 1
PRINT "New Age: "; person{"age"}

' --- End of File ---

export MODULE MATH

' This function will be public because of the 'export' keyword.
' Other programs that import this module can use it.
export func add(a, b)
    return a + b
endfunc

' This function is private to this module because it does NOT have 'export'.
' It can be called by other functions inside this file, but not from outside.
func secret_multiplier()
    return 2
endfunc

' This exported function demonstrates calling a private function.
export func add_and_double(a, b)
    ' First, add the two numbers using the public 'add' function
    result = add(a, b)
    
    ' Then, multiply by a secret internal value
    result = result * secret_multiplier()
    
    return result
endfunc

' This is an exported procedure.
export sub print_sum(a, b)
    print a; " + "; b; " = "; add(a,b)
endsub

' --- End of File ---

import MATH

print "--- Module Test Program ---"
print

print "Calling MATH.ADD(15, 7)..."
x = MATH.ADD(15, 7)
print "Result:"; x
print

print "Calling MATH.ADD_AND_DOUBLE(10, 5)..."
y = MATH.ADD_AND_DOUBLE(10, 5)
print "Result:"; y
print

print "Calling MATH.PRINT_SUM 100, 23..."
MATH.PRINT_SUM 100, 23
print

print "--- Module Test Complete ---"

' --- End of File ---

' ==========================================================
' == jdBasic Advanced Sprite & Tilemap Demo
' ==========================================================
'
' This program demonstrates:
' - Loading a Tiled map and drawing its layers.
' - Loading an animated sprite from Aseprite.
' - Player movement and animation state changes.
' - Basic camera follow.
' - Collision detection with the tilemap.
'
' --- CONTROLS ---
' - A/D or Left/Right Arrows: Move the player.
' - ESC: Quit the program.
'
' ----------------------------------------------------------

' --- 0. Evetis
ON "KEYDOWN" CALL HandleKeys
ON "KEYUP" CALL HandleKeysUP

Dim Event As Map
Event{"type"} = "NA"

SUB HandleKeys(data)
    Event  = data[0]
    Event{"type"} = "KEYDOWN"
ENDSUB

SUB HandleKeysUP(data)
    Event  = data[0]
    Event{"type"} = "KEYUP"
ENDSUB

' --- 0. Delete me
cd "D:\usr\dev\c\jdBasic\jdb"

' --- 1. Initialization ---
SCREEN 1920, 1080, "jdBasic Advanced Demo", 2
OPTION "NOPAUSE" ' Disable pause on focus loss

' --- 2. Asset Loading ---
PRINT "Loading assets..."

' Load the character animations from Aseprite
' The character will be sprite type ID 1
SPRITE.LOAD_ASEPRITE 1, "atomi.json"
SPRITE.LOAD 2, "pictures\point.png"

' Load the level map from Tiled
MAP.LOAD "level1", "tiled\jdrpg.json"
MAP.LOAD "main_menu", "main_menu.json"

SUB SortMenuItems()
    ' This uses a simple Bubble Sort to order the menu items
    ' based on the "index" custom property from Tiled.
    N = LEN(MENU_ITEMS)
    IF N < 2 THEN RETURN

    FOR I = 0 TO N - 2
        FOR J = 0 TO N - I - 2
            ' Get the index property of two adjacent items
            IndexA = VAL(MENU_ITEMS[J]{"index"})
            IndexB = VAL(MENU_ITEMS[J+1]{"index"})
            
            ' If the first is greater than the second, swap them
            IF IndexA > IndexB THEN
                TempItem = MENU_ITEMS[J]
                MENU_ITEMS[J] = MENU_ITEMS[J+1]
                MENU_ITEMS[J+1] = TempItem
            ENDIF
        NEXT
    NEXT
ENDSUB

DIM GameState AS STRING
GameState = "MainMenu"
SETFONT ".\fonts\SuperVanilla.ttf", 24
SOUND.INIT
SFX.LOAD THEME_MUSIC, "music/Theme1.wav"
MUSIC.PLAY THEME_MUSIC

DO WHILE GameState = "MainMenu"
    ' --- Menu Setup (runs once) ---
    MENU_ITEMS = MAP.GET_OBJECTS("main_menu", "menu_item")
    SortMenuItems
    CURRENT_SELECTION = 0
    SELECTOR_ID = SPRITE.CREATE(2, 0, 0)
    MUSIC.PLAY -1 
    ' --- The Actual Menu Loop ---
    DO
        ' --- Handle Menu Input ---
        IF Event{"type"} = "KEYDOWN" THEN
            ' Move selection down
            IF Event{"scancode"} = 81 OR Event{"scancode"} = 22 THEN ' S or Down Arrow
                CURRENT_SELECTION = CURRENT_SELECTION + 1
                IF CURRENT_SELECTION >= LEN(MENU_ITEMS) THEN CURRENT_SELECTION = 0
            ENDIF
            ' Move selection up
            IF Event{"scancode"} = 82 OR Event{"scancode"} = 26 THEN ' W or Up Arrow
                CURRENT_SELECTION = CURRENT_SELECTION - 1
                IF CURRENT_SELECTION < 0 THEN CURRENT_SELECTION = LEN(MENU_ITEMS) - 1
            ENDIF
            
            ' Handle selection action
            IF Event{"scancode"} = 40 THEN ' Enter key
                IF CURRENT_SELECTION = 0 THEN GameState = "Playing" : EXITDO ' Start Game
                IF CURRENT_SELECTION = 1 THEN PRINT "Load Game not implemented!"
                IF CURRENT_SELECTION = 2 THEN PRINT "Settings not implemented!"
                IF CURRENT_SELECTION = 3 THEN PRINT "Credits not implemented!"
                IF CURRENT_SELECTION = 4 THEN GameState = "Exit" : EXITDO ' Exit
            ENDIF
            
            Event{"type"} = "NA" ' Consume event
        ENDIF

        ' --- Update Menu Logic ---
        ' Position the selector sprite next to the selected text
        SELECTED_ITEM = MENU_ITEMS[CURRENT_SELECTION]
        SELECTOR_X = VAL(SELECTED_ITEM{"x"}) - 40 ' Position selector to the left
        SELECTOR_Y = VAL(SELECTED_ITEM{"y"})
        
        SPRITE.MOVE SELECTOR_ID, SELECTOR_X, SELECTOR_Y

        ' --- Drawing Phase ---
        CLS 20, 20, 40 ' Dark blue clear color
        MAP.DRAW_LAYER "main_menu", "Background"

        ' Draw all the menu text items
        FOR I = 0 TO LEN(MENU_ITEMS) - 1
            ITEM = MENU_ITEMS[I]
            TX = VAL(ITEM{"x"})
            TY = VAL(ITEM{"y"})
            ' Highlight the selected item in yellow
            IF I = CURRENT_SELECTION THEN
                TEXT TX, TY, ITEM{"text"}, 255, 255, 0
            ELSE
                TEXT TX, TY, ITEM{"text"}, 255, 255, 255
            ENDIF
        NEXT
        SPRITE.UPDATE 0
        SPRITE.DRAW_ALL 0,0' Draw the selector
        SCREENFLIP
    LOOP UNTIL 1=2

    ' --- Cleanup after menu exits ---
    SPRITE.DELETE SELECTOR_ID
LOOP ' This outer loop handles changing GameState

MUSIC.STOP

' --- 3. Game Object Creation ---
' Find the player's spawn point from the Tiled map data
IF GameState = "Playing" THEN
    SPAWN_POINTS = MAP.GET_OBJECTS("level1", "spawn_point")
    IF LEN(SPAWN_POINTS) > 0 THEN
        SPAWN = SPAWN_POINTS[0] ' Use the first spawn point found
        PLAYER_ID = SPRITE.CREATE(1, VAL(SPAWN{"x"}), VAL(SPAWN{"y"}))
    ELSE
        ' Fallback if no spawn point is found
        PLAYER_ID = SPRITE.CREATE(1, 400, 250)
    ENDIF

    ' --- 4. Game Variables ---
    PLAYER_SPEED = 75.0

    PLAYER_VX = 0.0 ' Player X velocity
    PLAYER_VY = 0.0 ' Player Y velocity

    ' Camera position
    CAM_X = 0
    CAM_Y = 0

LAST_TICK = TICK()

' --- 5. Main Game Loop ---

    DO
        ' --- Delta Time Calculation ---
        CURRENT_TICK = TICK()
        DELTA_TIME = (CURRENT_TICK - LAST_TICK) / 1000.0
        LAST_TICK = CURRENT_TICK
        
        ' --- Handle Input ---
        'EVENT = GET_EVENT() ' Get the latest event
        
        PLAYER_VX = 0
        PLAYER_VY = 0
        IF EVENT{"type"} = "KEYDOWN" THEN
            ' Move left
            IF EVENT{"scancode"} = 4 OR EVENT{"scancode"} = 80 THEN ' A or Left Arrow
                PLAYER_VX = -PLAYER_SPEED
                PLAYER_VY = 0
            ENDIF
            ' Move right
            IF EVENT{"scancode"} = 7 OR EVENT{"scancode"} = 79 THEN ' D or Right Arrow
                PLAYER_VX = PLAYER_SPEED
                PLAYER_VY = 0
            ENDIF
            ' Move up
            IF EVENT{"scancode"} = 26 OR EVENT{"scancode"} = 82 THEN ' W or Up Arrow
                    PLAYER_VY = -PLAYER_SPEED
                    PLAYER_VX = 0
            ENDIF
            ' Move down
            IF EVENT{"scancode"} = 22 OR EVENT{"scancode"} = 81 THEN ' W or Up Arrow
                    PLAYER_VY = PLAYER_SPEED
                    PLAYER_VX = 0
            ENDIF
            ' Exit
            IF EVENT{"scancode"} = 41 THEN EXITDO ' ESC key
            LAST_VX = PLAYER_VX
            LAST_VY = PLAYER_VY
        ENDIF

        ' --- Update Game Logic ---
        LAST_X = SPRITE.GET_X(PLAYER_ID)
        LAST_Y = SPRITE.GET_Y(PLAYER_ID)   

            ' Set player velocity
        SPRITE.SET_VELOCITY PLAYER_ID, PLAYER_VX, PLAYER_VY
        
        ' Update all sprite positions based on velocity
        SPRITE.UPDATE DELTA_TIME
        
        ' --- Collision Detection & Response ---
        IS_GROUNDED = FALSE
        IF MAP.COLLIDES(PLAYER_ID, "level1", "Collision") THEN
            PLAYER_VX = 0
            PLAYER_VY = 0
            SPRITE.SET_VELOCITY PLAYER_ID, 0, 0
            SPRITE.MOVE PLAYER_ID, LAST_X, LAST_Y
            SPRITE.SET_VELOCITY PLAYER_ID, PLAYER_VX, PLAYER_VY
        ENDIF

        ' --- Update Animation State ---
        IF PLAYERV_X <> 0 OR PLAYER_VY <> 0 THEN
              IF PLAYER_VY > 0 THEN
                SPRITE.SET_ANIMATION PLAYER_ID, "walk"
            ENDIF
            IF PLAYER_VY < 0 THEN 
                SPRITE.SET_ANIMATION PLAYER_ID, "backwalk"
            ENDIF
            IF PLAYERV_X < 0 THEN 
                SPRITE.SET_ANIMATION PLAYER_ID, "leftwalk"
            ENDIF
            IF PLAYERV_X > 0 THEN 
                SPRITE.SET_ANIMATION PLAYER_ID, "rightwalk"
            ENDIF
        ELSE
            IF LAST_VY > 0 THEN
                SPRITE.SET_ANIMATION PLAYER_ID, "idle"
            ENDIF
            IF LAST_VY < 0 THEN 
                SPRITE.SET_ANIMATION PLAYER_ID, "backidle"
            ENDIF
            IF LAST_VX < 0 THEN 
                SPRITE.SET_ANIMATION PLAYER_ID, "leftidle"
            ENDIF
            IF LAST_VX > 0 THEN 
                SPRITE.SET_ANIMATION PLAYER_ID, "rightidle"
            ENDIF
        ENDIF

        ' --- Update Camera ---
        ' Make the camera follow the player smoothly
        SX = SPRITE.GET_X(PLAYER_ID)
        SY = SPRITE.GET_Y(PLAYER_ID)
        CAM_X = CAM_X + (SX - CAM_X - 400) * 0.1
        CAM_Y = CAM_Y + (SY - CAM_Y - 300) * 0.1

        ' --- Drawing Phase ---
        CLS 50, 150, 255 ' Clear to a sky blue color

        ' Draw the map layers with the camera offset
        MAP.DRAW_LAYER "level1", "background", CAM_X, CAM_Y
        MAP.DRAW_LAYER "level1", "collision", CAM_X, CAM_Y
        
        ' Draw all sprites
        SPRITE.DRAW_ALL CAM_X, CAM_Y

        'MAP.DRAW_DEBUG_COLLISIONS PLAYER_ID, "level1", "collision"
        
        ' Draw UI
        TEXT 10, 10, "jdBasic RPG Demo X,y: " + str$(sx) + ", " + str$(sy), 255, 255, 0
        
        SCREENFLIP
    LOOP
ENDIF

' --- 6. Shutdown ---
PRINT "Program finished."

' --- End of File ---

' ==========================================================
' == Save/Load Test Program - Complex Nested Structure
' == Goal: Isolate and debug the TENSOR.SAVEMODEL and
' ==       TENSOR.LOADMODEL functionality with a structure
' ==       that mimics the full model.
' ==========================================================

CLS
PRINT "--- Starting Save/Load Test (Complex Model) ---"
PRINT

' 1. Create a data structure that mimics the full model:
'    A main map containing a list (array) of layers, where each
'    layer is a map containing a tensor.
TEST_MODEL = {}
TEST_MODEL{"layers"} = []

' Create Layer 1
layer1 = {}
layer1_array = [[1, 2, 3], [4, 5, 6]]
layer1{"weights"} = TENSOR.FROM(layer1_array)
TEST_MODEL{"layers"} = APPEND(TEST_MODEL{"layers"}, layer1)

' Create Layer 2
layer2 = {}
layer2_array = [[10, 20, 30], [40, 50, 60]]
layer2{"weights"} = TENSOR.FROM(layer2_array)
TEST_MODEL{"layers"} = APPEND(TEST_MODEL{"layers"}, layer2)


' 2. Print the original object to see its structure
PRINT "--- ORIGINAL MODEL ---"
PRINT TEST_MODEL
PRINT


' 3. Save the model to a file
PRINT "--- SAVING MODEL ---"
TENSOR.SAVEMODEL TEST_MODEL, "test_model.json"
PRINT "Model saved to test_model.json"
PRINT


' 4. Load the model from the file into a new variable
PRINT "--- LOADING MODEL ---"
LOADED_MODEL = TENSOR.LOADMODEL("test_model.json")
IF LEN(LOADED_MODEL)=0 THEN
    PRINT "Error: Failed to load model from file."
    END
ENDIF
PRINT "Model loaded successfully."
PRINT


' 5. Print the loaded object to compare it with the original
PRINT "--- LOADED MODEL ---"
PRINT LOADED_MODEL
PRINT

' 6. Check if the loaded tensor's data can be accessed from deep
'    within the nested structure.
PRINT "--- VERIFYING LOADED DATA ---"
loaded_layer2_tensor = LOADED_MODEL{"layers"}[1]{"weights"}
loaded_array = TENSOR.TOARRAY(loaded_layer2_tensor)

' This line will cause an error if the shape information was lost during loading
PRINT "Value at (1, 2) of loaded layer 2 array: "; loaded_array[1, 2] 

PRINT
PRINT "--- Test Complete ---"


' --- End of File ---

' ===============================================
' == jdBasic Rainbow Mouse Drawing Demo (Event-Driven v2)
' ===============================================
'
' This version is fully event-driven and stores all drawn
' lines in an array, redrawing them each frame.
'
' --- CONTROLS ---
' - Hold the LEFT mouse button to draw.
' - Press the ESC key to quit.
'
' -----------------------------------------------

' --- 1. Global State Variables ---
DIM is_drawing AS BOOLEAN
DIM prev_x AS INTEGER
DIM prev_y AS INTEGER
DIM hue_counter AS INTEGER
DIM G_QUIT AS BOOLEAN ' Flag to signal program exit

' --- 2. Event Handler Subroutines ---
SUB OnMouseDown(data)
    IF data[0]{"button"} = 1 THEN
        is_drawing = TRUE
        prev_x = data[0]{"x"}
        prev_y = data[0]{"y"}
    ENDIF
ENDSUB

SUB OnMouseUp(data)
    is_drawing = FALSE
    prev_x = -1
    prev_y = -1
ENDSUB

SUB OnMouseMove(data)
    IF is_drawing THEN
        mx = data[0]{"x"}
        my = data[0]{"y"}

        color_array = HSVtoRGB(hue_counter, 1.0, 1.0)
        
        ' Create a new line segment array: [x1, y1, x2, y2, r, g, b]
        new_line = [prev_x, prev_y, mx, my]
        new_color = [color_array[0], color_array[1], color_array[2]]
        
        ' Add the new line segment to our global list of lines
        G_LINES = APPEND(G_LINES, new_line)
        G_COLORS = APPEND(G_COLORS, new_color)

        prev_x = mx
        prev_y = my
        hue_counter = (hue_counter + 2) MOD 360
    ENDIF
ENDSUB

' --- NEW: Event handler for keyboard input ---
SUB OnKeyDown(data)
    ' Check if the pressed key is ESC (ASCII 27)
    PRINT data
    IF data[0]{"keycode"} = 27 THEN
        G_QUIT = TRUE
    ENDIF
ENDSUB


' --- 3. Helper Function: HSV to RGB Color Conversion ---
FUNC HSVtoRGB(h, s, v)
    c = v * s
    h_prime = h / 60.0
    x = c * (1 - ABS(h_prime MOD 2 - 1))
    m = v - c

    IF h_prime >= 0 AND h_prime < 1 THEN
        r_ = c : g_ = x : b_ = 0
    ELSEIF h_prime >= 1 AND h_prime < 2 THEN
        r_ = x : g_ = c : b_ = 0
    ELSEIF h_prime >= 2 AND h_prime < 3 THEN
        r_ = 0 : g_ = c : b_ = x
    ELSEIF h_prime >= 3 AND h_prime < 4 THEN
        r_ = 0 : g_ = x : b_ = c
    ELSEIF h_prime >= 4 AND h_prime < 5 THEN
        r_ = x : g_ = 0 : b_ = c
    ELSEIF h_prime >= 5 AND h_prime < 6 THEN
        r_ = c : g_ = 0 : b_ = x
    ELSE
        r_ = 0 : g_ = 0 : b_ = 0
    ENDIF

    r = (r_ + m) * 255
    g = (g_ + m) * 255
    b = (b_ + m) * 255

    RETURN [r, g, b]
ENDFUNC


' --- 4. Main Program Setup and Loop ---
SCREEN 800, 600, "Rainbow Paint (Event-Driven)"

' Initialize global state variables
is_drawing = FALSE
prev_x = -1
prev_y = -1
hue_counter = 0
G_LINES = []
G_COLORS = []
G_QUIT = FALSE

' Register ALL event handlers
ON "MOUSEDOWN" CALL OnMouseDown
ON "MOUSEUP" CALL OnMouseUp
ON "MOUSEMOVE" CALL OnMouseMove
ON "KEYDOWN" CALL OnKeyDown

PRINT "--- Starting Drawing App. Hold left-click to draw. Press ESC to quit. ---"

' The main loop now handles redrawing the entire scene from the G_LINES array.
DO

    if len(G_LINES) > 1 THEN
       LINE RESHAPE(G_LINES,[len(G_LINES)[0]/4,4]), RESHAPE(G_COLORS,[len(G_COLORS)[0]/3,3])
    ENDIF
    ' Update the screen
    SCREENFLIP
    
    ' Check the quit flag, which is set by the OnKeyDown handler
    IF G_QUIT THEN EXITDO
    if is_drawing = FALSE THEN 
        SLEEP 10 
    ENDIF
LOOP

' --- 5. Shutdown ---
CLS
PRINT "Drawing app closed."

' --- End of File ---

' ===============================================
' == jdBASIC Mouse Drawing Demo
' ===============================================
'
' This program demonstrates the MOUSEX, MOUSEY,
' and MOUSEB functions.
'
' --- CONTROLS ---
' - Move the mouse to position the cursor.
' - Hold the LEFT mouse button (1) to draw.
' - Hold the RIGHT mouse button (3) to erase.
' - Press the ESC key to quit.
'
' -----------------------------------------------

SCREEN 800, 600, "jdBasic Mouse Drawing"

' Main drawing loop
DO
  ' Get mouse coordinates
  CLS 20, 20, 30 ' Clear to a dark background
  TEXT 10, 10, "Left-click and drag to draw. Right-click to erase. ESC to quit.", 200, 200, 200
  MX = MOUSEX()
  MY = MOUSEY()

  ' Check if the left mouse button is held down
  IF MOUSEB(1) THEN
    ' Draw a small circle at the mouse position
    CIRCLE MX, MY, 3, 255, 200, 100
  ENDIF

  ' Check if the right mouse button is held down
  IF MOUSEB(3) THEN
    ' Erase by drawing a larger black circle
    CIRCLE MX, MY, 10, 20, 20, 30 ' Use the background color
  ENDIF

  ' Redraw the screen to show any new drawing
  SCREENFLIP
  
  ' Use INKEY$ to check for the ESC key (ASCII 27)
  KEY$ = INKEY$()
  IF KEY$ <> "" AND ASC(KEY$) = 27 THEN
    EXITDO
  ENDIF

  ' Small delay to prevent 100% CPU usage
  SLEEP 10
LOOP

' --- End of File ---

A = [ [1,2,3], _
      [4,5,6], _
      [5,6,7] ]
print A, _
      "Atomi made it"

' --- End of File ---

Print "' --- Array-Scalar Math ---"
V = IOTA(7)
Print "IOTA(7): ";V
M = RESHAPE(V, [2, 4])
Print "M = RESHAPE(V, [2, 4]): "; M
Print

Print "Reverse REVERSE([10, 20, 30])"
PRINT REVERSE([10, 20, 30])
Print

Print "T = TRANSPOSE([[1,2],[3,4]])"
T = TRANSPOSE([[1,2],[3,4]])
PRINT T
Print

Print "' --- Array-Array Math ---"
V = IOTA(5)
PRINT "Original Vector: "; V
PRINT "V * 10 = "; V * 10
PRINT "100 + V = "; 100 + V
PRINT ""

V2 = V + 10
PRINT "V2 is V + 10: "; V2
PRINT "V + V2 = "; V + V2
PRINT ""

Print "' --- Matrix Math ---"
A = RESHAPE(IOTA(6), [2, 3])
B = A * 2
PRINT "Matrix A:"; A
PRINT "Matrix B (A*2):"; B
PRINT "A + B ="; A + B
Print 

'Print "'--- This will cause a shape mismatch error, as expected ---"
'PRINT A + V 

PRINT "--- Numeric Reductions ---"
V = [2, 3, 4, 5, 6]
PRINT "Vector is "; V
PRINT "SUM: "; SUM(V)         ' Should be 20
PRINT "PRODUCT: "; PRODUCT(V) ' Should be 720
PRINT "MIN: "; MIN(V)         ' Should be 2
PRINT "MAX: "; MAX(V)         ' Should be 6
PRINT ""

PRINT "--- Boolean Reductions ---"
B1 = [TRUE, TRUE, TRUE]
B2 = [TRUE, FALSE, TRUE]
PRINT "B1 is "; B1
PRINT "ANY(B1): "; ANY(B1)     ' Should be TRUE
PRINT "ALL(B1): "; ALL(B1)     ' Should be TRUE
PRINT ""
PRINT "B2 is "; B2
PRINT "ANY(B2): "; ANY(B2)     ' Should be TRUE
PRINT "ALL(B2): "; ALL(B2)     ' Should be FALSE
PRINT ""

PRINT "--- Reductions work on matrices too! ---"
M = RESHAPE(IOTA(9), [3,3])
PRINT "Matrix M:"; M
PRINT "SUM of M: "; SUM(M)     ' Should be 45
Print

PRINT "--- Testing MATMUL ---"
A = [[1, 2], [3, 4]]
B = [[5, 6], [7, 8]]
C = MATMUL(A, B)
PRINT "Matrix A:"; A
PRINT "Matrix B:"; B
PRINT "MATMUL(A, B) ="; C  ' Should be [[19, 22], [43, 50]]
PRINT ""

PRINT "--- Testing OUTER ---"
V1 = [10, 20]
V2 = [1, 2, 3]
PRINT "Vector V1: "; V1
PRINT "Vector V2: "; V2
M_MULT = OUTER(V1, V2, "*")
PRINT "OUTER(V1, V2, *) ="; M_MULT

M_ADD = OUTER(V1, V2, "+")
PRINT "OUTER(V1, V2, +) ="; M_ADD
Print

Print "--- Slicing and Sorting ---"
Print

V = IOTA(8)
PRINT "Original Vector V: "; V
PRINT ""
PRINT "TAKE(3, V) = "; TAKE(3, V)     ' Should be [1 2 3]
PRINT "TAKE(-3, V) = "; TAKE(-3, V)   ' Should be [6 7 8]
PRINT ""
PRINT "DROP(3, V) = "; DROP(3, V)     ' Should be [4 5 6 7 8]
PRINT "DROP(-3, V) = "; DROP(-3, V)   ' Should be [1 2 3 4 5]
Print

' Create an unsorted array of scores
SCORES = [98, 75, 100, 82, 91]
PRINT "Original Scores: "; SCORES
PRINT ""

' Get the indices that WOULD sort the scores
G = GRADE(SCORES)
PRINT "Grade of Scores: "; G  ' Should be [1 3 4 0 2] (indices of 75, 82, 91, 98, 100)
PRINT ""

' Now, use the grade vector to print the scores in sorted order
PRINT "Scores sorted by rank:"
FOR I = 0 TO LEN(G)-1
    PRINT SCORES[G[I]]
NEXT I

' --- End of File ---

' --- Part 1: A Single Neuron ---

PRINT "--- Simulating a Single Neuron ---"
PRINT

' Our neuron has 3 inputs. Let's define them.
INPUTS = [0.5, -1.2, 0.8]

' Every input has a corresponding weight.
WEIGHTS = [0.8, 0.1, -0.4]

' The neuron also has a single bias value.
BIAS = 0.5

PRINT "Inputs: "; INPUTS
PRINT "Weights: "; WEIGHTS
PRINT "Bias: "; BIAS
PRINT

' The core calculation: (input * weight) summed up, plus the bias.
' In jdBasic, we can do this elegantly with element-wise multiplication
' followed by a SUM reduction.
WEIGHTED_SUM = SUM(INPUTS * WEIGHTS)
OUTPUT = WEIGHTED_SUM + BIAS

PRINT "Weighted Sum of Inputs: "; WEIGHTED_SUM
PRINT "Final Neuron Output: "; OUTPUT
' --- End of File ---

' --- Part 2: A Layer of Neurons ---

PRINT "--- Simulating a Layer of 4 Neurons ---"
PRINT

' The same 3 inputs as before. We can think of this as a 1x3 matrix.
INPUTS = [[0.5, -1.2, 0.8]]

' Now, we have 4 neurons, so we need a weight matrix.
' The shape must be (number of inputs) x (number of neurons).
' So, a 3x4 matrix. Each *column* represents the weights for one neuron.
' Row 1 weights for input 1 to each of the 4 neurons
' Row 2 weights for input 2 to each of the 4 neurons
' Row 3 weights for input 3 to each of the 4 neurons
WEIGHTS = [[0.8, -0.2,  0.3, 1.0],  [0.1,  0.4, -0.5, 0.2],  [-0.4, 0.9,  0.1, 0.8]]  

' Each of the 4 neurons has its own bias. This is a 1x4 vector.
BIASES = [[0.5, -0.1, 0.2, -0.3]]

PRINT "Input Vector (1x3):"
PRINT FRMV$(INPUTS)
PRINT
PRINT "Weight Matrix (3x4):"
PRINT FRMV$(WEIGHTS)
PRINT
PRINT "Bias Vector (1x4):"
PRINT FRMV$(BIASES)
PRINT

' The entire forward pass calculation for all 4 neurons at once!
' The result of INPUTS (1x3) @ WEIGHTS (3x4) is a 1x4 matrix.
LAYER_OUTPUTS = MATMUL(INPUTS, WEIGHTS) + BIASES

PRINT "Layer Outputs (1x4):"
PRINT FRMV$(LAYER_OUTPUTS)

' --- End of File ---

' --- Part 3: Activation Functions ---
PRINT "--- Applying Activation Functions ---"
PRINT

' Our raw layer outputs from the previous step.
LAYER_OUTPUTS = [[0.04, 0.1, 0.77, 0.6]]

PRINT "Raw Layer Outputs:"
PRINT FRMV$(LAYER_OUTPUTS)
PRINT

' --- 1. The Sigmoid Function ---
' Sigmoid squashes any number into a range between 0 and 1.
' It's often used for binary classification output layers.
' The formula is: 1 / (1 + e^-x)
FUNC SIGMOID(X)
  RETURN 1 / (1 + 2 ^ x*-1)
ENDFUNC

' Apply Sigmoid to the entire output array element-wise.
ACTIVATED_SIGMOID = SIGMOID(LAYER_OUTPUTS)

PRINT "Outputs after Sigmoid Activation:"
PRINT ACTIVATED_SIGMOID
PRINT


' --- 2. The ReLU (Rectified Linear Unit) Function ---
' ReLU is the most popular activation function for hidden layers.
' It's very simple: if x is negative, it becomes 0. Otherwise, it stays x.
' Formula: MAX(0, x)
FUNC RELU(X)
  ' We can implement this cleverly with array comparisons.
  ' (X > 0) creates a boolean array [FALSE, TRUE, TRUE, TRUE]
  ' which acts like [0, 1, 1, 1] in math.
  RETURN X * (X > 0)
ENDFUNC

' Apply ReLU to the entire output array element-wise.
ACTIVATED_RELU = RELU(LAYER_OUTPUTS)

PRINT "Outputs after ReLU Activation:"
PRINT FRMV$(ACTIVATED_RELU)

' --- End of File ---

' ==========================================================
' == A Complete, Trainable Neural Network in jdBasic
' == Goal: Learn the XOR logic gate
' ==========================================================

' --- 1. Setup and Helper Functions ---

' The Sigmoid activation function
FUNC SIGMOID(X)
  ' We multiply by -1 for element-wise negation of the array
  RETURN 1 / (1 + 2.71828 ^ (X * -1))
ENDFUNC

' The *derivative* of the Sigmoid function.
' This is needed for backpropagation.
FUNC SIGMOID_DERIVATIVE(X)
  RETURN X * (1 - X)
ENDFUNC

' Helper function to create an array of a given SHAPE filled with random numbers.
FUNC RAND_ARRAY(SHAPE)
  TOTAL_ELEMENTS = PRODUCT(SHAPE)
  DIM R[TOTAL_ELEMENTS]
  FOR i = 0 TO TOTAL_ELEMENTS - 1
    R[i] = RND(1)
  NEXT i
  RETURN RESHAPE(R, SHAPE)
ENDFUNC


' --- 2. Training Data and Network Architecture ---

' XOR truth table:
' Input: [0,0], Output: [0]
' Input: [0,1], Output: [1]
' Input: [1,0], Output: [1]
' Input: [1,1], Output: [0]
TRAINING_INPUTS = [[0,0], [0,1], [1,0], [1,1]]
TRAINING_OUTPUTS = [[0], [1], [1], [0]]

' Initialize weights and biases with random numbers shifted to the range [-1, 1].
' Hidden Layer: 2 input neurons, 3 hidden neurons
' Output Layer: 3 hidden neurons, 1 output neuron
WEIGHTS_HIDDEN = (RAND_ARRAY([2, 3]) - 0.5) * 2
WEIGHTS_OUTPUT = (RAND_ARRAY([3, 1]) - 0.5) * 2
BIAS_HIDDEN = (RAND_ARRAY([1, 3]) - 0.5) * 2
BIAS_OUTPUT = (RAND_ARRAY([1, 1]) - 0.5) * 2

LEARNING_RATE = 0.1
EPOCHS = 10000 ' Number of training iterations

PRINT "--- Starting Training ---"

' --- 3. The Training Loop ---

FOR i = 1 TO EPOCHS
  ' --- FORWARD PASS ---
  HIDDEN_LAYER_ACTIVATION = MATMUL(TRAINING_INPUTS, WEIGHTS_HIDDEN) + BIAS_HIDDEN
  ACTIVATED_HIDDEN = SIGMOID(HIDDEN_LAYER_ACTIVATION)
  
  OUTPUT_LAYER_ACTIVATION = MATMUL(ACTIVATED_HIDDEN, WEIGHTS_OUTPUT) + BIAS_OUTPUT
  PREDICTED_OUTPUT = SIGMOID(OUTPUT_LAYER_ACTIVATION)

  ' --- BACKPROPAGATION ---
  ' Calculate the error
  ERROR = TRAINING_OUTPUTS - PREDICTED_OUTPUT

  ' Calculate the gradients (this is the derived calculus)
  D_PREDICTED_OUTPUT = ERROR * SIGMOID_DERIVATIVE(PREDICTED_OUTPUT)
  
  ERROR_HIDDEN_LAYER = MATMUL(D_PREDICTED_OUTPUT, TRANSPOSE(WEIGHTS_OUTPUT))
  D_HIDDEN_LAYER = ERROR_HIDDEN_LAYER * SIGMOID_DERIVATIVE(ACTIVATED_HIDDEN)

  ' --- UPDATE WEIGHTS AND BIASES ---
  ' Update output layer weights
  WEIGHTS_OUTPUT = WEIGHTS_OUTPUT + MATMUL(TRANSPOSE(ACTIVATED_HIDDEN), D_PREDICTED_OUTPUT) * LEARNING_RATE
  
  ' Update hidden layer weights
  WEIGHTS_HIDDEN = WEIGHTS_HIDDEN + MATMUL(TRANSPOSE(TRAINING_INPUTS), D_HIDDEN_LAYER) * LEARNING_RATE
  
  ' Update biases
  BIAS_OUTPUT = BIAS_OUTPUT + SUM(D_PREDICTED_OUTPUT, 0) * LEARNING_RATE
  BIAS_HIDDEN = BIAS_HIDDEN + SUM(D_HIDDEN_LAYER, 0) * LEARNING_RATE

  ' Print progress every 1000 epochs
  IF i MOD 1000 = 0 THEN
    LOSS = SUM(ERROR ^ 2) / LEN(ERROR)[0]
    PRINT "Epoch:"; i; ", Loss:"; LOSS
  ENDIF
NEXT i

PRINT
PRINT "--- Training Complete ---"
PRINT "Final Predictions:"
PRINT FRMV$(PREDICTED_OUTPUT)

' --- End of File ---

' ==========================================================
' == An Autodiff Neural Network in jdBasic (Corrected)
' == Goal: Learn the XOR logic gate with the new high-level API
' ==========================================================

' --- 1. Define Training Data ---
' The four possible inputs for the XOR problem. [cite: 21]
TRAINING_INPUT_DATA = [[0, 0], [0, 1], [1, 0], [1, 1]]
' The corresponding correct outputs for XOR. [cite: 22]
TRAINING_OUTPUT_DATA = [[0], [1], [1], [0]]

' Convert the raw data arrays into Tensors to enable automatic differentiation. [cite: 23]
INPUTS = TENSOR.FROM(TRAINING_INPUT_DATA)
TARGETS = TENSOR.FROM(TRAINING_OUTPUT_DATA)


' --- 2. Define the Neural Network Model ---
' Model is now a Map to conform to the new API
MODEL = {}

' Layer 1: A dense layer with 2 inputs and 3 hidden units (neurons). 
HIDDEN_LAYER = TENSOR.CREATE_LAYER("DENSE", {"input_size": 2, "units": 3})
' Layer 2: A dense layer with 3 inputs (from hidden layer) and 1 output unit. [cite: 26]
OUTPUT_LAYER = TENSOR.CREATE_LAYER("DENSE", {"input_size": 3, "units": 1})

' Layers are stored in the "layers" key of the model map
MODEL{"layers"} = [HIDDEN_LAYER, OUTPUT_LAYER]


' --- 3. Setup the Optimizer and Training Parameters ---
' The optimizer will update the model's weights and biases based on the gradients. [cite: 28]
' SGD (Stochastic Gradient Descent) is a simple and effective optimizer. [cite: 28]
OPTIMIZER = TENSOR.CREATE_OPTIMIZER("SGD", {"learning_rate": 0.1})
EPOCHS = 15000 ' The number of times to iterate over the training data.


' --- 4. Define Helper Functions ---

' The forward pass function takes the model and an input tensor,
' and returns the model's prediction. [cite: 31]
FUNC MODEL_FORWARD(current_model, input_tensor)
    temp_tensor = input_tensor
    model_layers = current_model{"layers"}
    ' Process the input through each layer in the model. [cite: 32]
    FOR i = 0 TO LEN(model_layers) - 1
        layer = model_layers[i]
        
        ' Get the weights and biases for the current layer. [cite: 33]
        weights = layer{"weights"}
        bias = layer{"bias"}
        
        ' Apply the layer's logic: output = sigmoid(input * weights + bias)
        temp_tensor = MATMUL(temp_tensor, weights) + bias
        temp_tensor = TENSOR.SIGMOID(temp_tensor)
    NEXT i
    RETURN temp_tensor
ENDFUNC

' The loss function measures how wrong the model's predictions are. [cite: 34]
' We use Mean Squared Error (MSE). [cite: 34]
FUNC MSE_LOSS(predicted_tensor, actual_tensor)
    ' Calculate the difference (error) between prediction and actual target. [cite: 35]
    errors = actual_tensor - predicted_tensor
    ' Square the errors. [cite: 36]
    squared_errors = errors ^ 2
    ' Return the average of the squared errors. [cite: 37]
    RETURN SUM(squared_errors) / LEN(TENSOR.TOARRAY(errors))[0]
ENDFUNC


' --- 5. The Training Loop ---
CLS
PRINT "--- Starting Training for XOR Gate ---"

FOR epoch = 1 TO EPOCHS
    ' --- a) Forward Pass ---
    ' Get the model's current predictions for the training inputs. [cite: 38]
    PREDICTIONS = MODEL_FORWARD(MODEL, INPUTS)

    ' --- b) Calculate Loss ---
    ' Calculate how far off the predictions are from the actual targets. [cite: 39]
    ' The result is a Tensor that is the root of our computation graph. [cite: 39]
    LOSS = MSE_LOSS(PREDICTIONS, TARGETS)
    
    ' --- c) Backpropagation ---
    ' This one command calculates the gradient (derivative) of the loss
    ' with respect to every parameter (weight and bias) in the model. [cite: 41]
    TENSOR.BACKWARD LOSS

    ' --- d) Update Parameters ---
    ' The optimizer uses the calculated gradients to update the model's
    ' weights and biases, nudging them in the right direction to reduce the loss. [cite: 42]
    MODEL = TENSOR.UPDATE(MODEL, OPTIMIZER)

    ' --- e) Print Progress ---
    IF epoch MOD 1000 = 0 THEN
        PRINT "Epoch:"; epoch; ", Loss:"; TENSOR.TOARRAY(LOSS) 
    ENDIF
NEXT epoch

' --- 6. Save the Trained Model ---
PRINT
PRINT "--- Training Complete ---"
TENSOR.SAVEMODEL MODEL, "xor_model.jmd"
PRINT "Model saved to xor_model.jmd"
PRINT


' --- 7. Verification and Final Predictions ---
PRINT "--- Verifying Final Predictions ---"
final_predictions_array = TENSOR.TOARRAY(PREDICTIONS)

input_pair = TRAINING_INPUT_DATA

predicted_val = final_predictions_array

target_val = TRAINING_OUTPUT_DATA

PRINT "Input: :   "; input_pair
PRINT "Target:    "; target_val
PRINT "Predicted: "; predicted_val

' --- End of File ---

' Test program for the enhanced OUTER function

PRINT "--- Testing OUTER with string operator '*' ---"
A=IOTA(4)*10
B=IOTA(4)

' Create a multiplication table
mult_table = OUTER(A, B, "*")

PRINT "Vector A:", A
PRINT "Vector B:", B
PRINT "Multiplication Table (A OUTER B, '*'):"
PRINT mult_table
PRINT ""


PRINT "--- Testing OUTER with a Function Reference ---"

' Define a custom function to use as the operator.
' It must take exactly two arguments.
FUNC HYPOT(X, Y)
    ' Calculate the hypotenuse: SQR(X^2 + Y^2)
    RETURN SQR(X*X + Y*Y)
ENDFUNC

' Use the custom function with OUTER
hypot_table = OUTER(A, B, HYPOT@)

PRINT "Hypotenuse Table (A OUTER B, HYPOT@):"
PRINT hypot_table
PRINT

PRINT "--- Testing OUTER with a Lambda Function ---"
' Use the custom lambda with OUTER
hypot_table = OUTER(A, B, lambda x,y -> SQR(X*X + Y*Y))

PRINT "Hypotenuse Table OUTER(A, B, lambda x,y -> SQR(X*X + Y*Y))"
PRINT hypot_table
' --- End of File ---

MyNumbers = IOTA(10)

result = SELECT(lambda i -> i + 1, MyNumbers) |> FILTER(lambda val -> val > 5, ?) |> SELECT(lambda v -> v * 10, ?)

PRINT "Piped lambda result:   "; FRMV$(result)
' --- End of File ---

' ===================================================================
' == Pipe Operator (`|>`) Demo for jdBasic
' ==
' == This program demonstrates how to use the custom pipe operator
' == to create clean, readable, and efficient data processing chains.
' ===================================================================
CLS

' --- 1. The Core Multi-Argument Function ---
' This is our main filtering logic. It takes TWO arguments:
' an array of data and a string describing the filter criteria.
' Because it takes two arguments, it CANNOT be used directly with the pipe.
FUNC FILTER(data_array, criteria$)
    ' Simple parser for criteria like "> 100" or "< 50"
    parts = SPLIT(criteria$, " ")
    operator$ = parts[0]
    value = VAL(parts[1])

    ' Create a boolean mask based on the criteria
    IF operator$ = ">" THEN
        mask = data_array > value
    ELSEIF operator$ = "<" THEN
        mask = data_array < value
    ELSE
        ' Return the original array if the operator is unknown
        RETURN data_array
    ENDIF

    ' Use the boolean mask to select the matching elements
    ' The result of MASK*DATA_ARRAY will have zeros for non-matching elements.
    ' We then filter those out.
    filtered_with_zeros = mask * data_array
    
    final_result = []
    FOR i = 0 TO LEN(filtered_with_zeros)[0] - 1
        IF filtered_with_zeros[i] <> 0 THEN
            final_result = APPEND(final_result, filtered_with_zeros[i])
        ENDIF
    NEXT i
    
    RETURN final_result
ENDFUNC

' --- 2. Pipe-Compatible (Single-Argument) Functions ---

' This function creates a "closure". It takes only ONE argument (the array)
' and calls our main FILTER function with a hard-coded second argument.
' This makes it compatible with the pipe operator.
FUNC FILTER_GT_150(data_array)
  RETURN FILTER(data_array, "> 150")
ENDFUNC

' A simple function to sum the elements of an array.
' It takes one argument, so it's naturally pipe-compatible.
FUNC SUM_ARRAY(data_array)
    RETURN SUM(data_array)
ENDFUNC

' A function to format a number into a nice string for display.
' It also takes one argument.
FUNC FORMAT_RESULT$(result_value)
    RETURN "Total of High-Value Sales: " + result_value
ENDFUNC

' --- 3. The Main Program ---

' Our initial dataset
SALES_DATA = [100, 250, 80, 500, 120, 180, 300]
PRINT "Original Sales Data: "; SALES_DATA
PRINT

' --- The "Old Way": Nested Function Calls ---
' This is hard to read from left to right. You have to read it inside-out.
PRINT "--- Processing the Old Way (Nested) ---"
filtered_sales = FILTER_GT_150(SALES_DATA)
sum_of_sales = SUM_ARRAY(filtered_sales)
formatted_result$ = FORMAT_RESULT$(sum_of_sales)
PRINT formatted_result$
PRINT

' --- The "Pipe Way": The Pipe Operator ---
' This is clean, logical, and reads like a set of instructions.
PRINT "--- Processing the New Way (with Pipe Operator) ---"
final_result$ = FILTER_GT_150(SALES_DATA) |> SUM_ARRAY(?) |> FORMAT_RESULT$(?)
PRINT final_result$


' --- End of File ---

' APL-inspired Sieve of Eratosthenes for jdBasic
' -----------------------------------------------

PRINT "--- APL Style Sieve ---"
PRINT "Wait for Array creation..."
LIMIT = 10000
T=tick()

' 1. Create a boolean mask, initially all TRUE, for numbers 1 to 100.
'    We use RESHAPE on a single TRUE value to fill the array.
IS_PRIME = RESHAPE([TRUE], [LIMIT])

' 2. Mark 1 as not prime (arrays are 0-indexed).
IS_PRIME[0] = FALSE

' 3. Loop from 2 up to the square root of the limit.
FOR P = 2 TO SQR(LIMIT)
    ' If P is still considered prime...
    IF IS_PRIME[P-1] THEN
        ' ...mark all of its multiples as FALSE.
        ' The first multiple to mark is P*P.
        FOR J = P*P TO LIMIT STEP P
            IS_PRIME[J-1] = FALSE
        NEXT J
    ENDIF
NEXT P

' 4. Print all the numbers whose entry in the IS_PRIME mask is still TRUE.
PRINT "Primes up to "; LIMIT; ":"
FOR I = 1 TO LIMIT
    IF IS_PRIME[I-1] THEN
        PRINT I; " ";
    ENDIF
NEXT I
print
PRINT "Time: "; tick()-t
print

' Traditional Functional/Procedural Approach for jdBasic
' ----------------------------------------------------

PRINT "--- Functional Style ---"

' A reusable function to test if a single number N is prime.
FUNC IS_PRIME(N)
    ' Numbers less than 2 are not prime.
    IF N < 2 THEN RETURN FALSE
    ' 2 is the only even prime.
    IF N = 2 THEN RETURN TRUE
    ' All other even numbers are not prime.
    IF N MOD 2 = 0 THEN RETURN FALSE

    ' Check for odd divisors from 3 up to the square root of N.
    LIMIT = SQR(N)
    FOR D = 3 TO LIMIT STEP 2
        IF N MOD D = 0 THEN
            ' A divisor was found, so it's not prime.
            RETURN FALSE
        ENDIF
    NEXT D

    ' If the loop finishes, no divisors were found. It's prime.
    RETURN TRUE
ENDFUNC

' Main loop: Test every number from 1 to 100 using our function.
T=tick()
PRINT "Primes up to "; LIMIT
FOR I = 1 TO LIMIT
    IF IS_PRIME(I) THEN
        PRINT I; " ";
    ENDIF
NEXT I
print
PRINT "Time: "; tick()-t
print


' --- End of File ---

PRINT "--- Testing TXTREADER$ ---"
MY_STORY$ = TXTREADER$("story.txt")
PRINT "The story file contains:"
PRINT MY_STORY$
PRINT "The story file split in lines:"
V = SPLIT(MY_STORY$,chr$(10))
PRINT "There are "; len(v); " lines:"
print "This is line 2: "; v[1]
print


PRINT "--- Testing CSVREADER ---"
' Load the data, skipping the header row
TEMP_DATA = CSVREADER("temps.csv", ",", TRUE)

PRINT "Temperature data loaded."
PRINT "Shape of data:"; LEN(TEMP_DATA)
PRINT "Full data matrix:"; TEMP_DATA
PRINT ""

' Let's analyze the average max temperature (column 2)
' (This is a conceptual example for now)
PRINT "Analysis would go here."


PRINT "--- Testing SPLIT ---"
SENTENCE$ = "this is a sentence with several words"
WORDS = SPLIT(SENTENCE$, " ")
PRINT "The words are: "; WORDS
PRINT "The third word is: "; WORDS[2]
PRINT ""

CSV_LINE$ = "2025-06-17,45.3,102.1"
DATA_POINTS = SPLIT(CSV_LINE$, ",")
PRINT "Data points: "; DATA_POINTS


PRINT "--- Testing SLICE ---"
' Create a 3x4 matrix
M = RESHAPE(IOTA(12), [3, 4])
PRINT "Original Matrix M:"; M
PRINT ""

' Extract row 1 (the second row, index 1)
ROW1 = SLICE(M, 0, 1)
PRINT "Row 1 of M: "; ROW1  ' Should be [5 6 7 8]
PRINT ""

' Extract column 2 (the third column, index 2)
COL2 = SLICE(M, 1, 2)
PRINT "Column 2 of M: "; COL2 ' Should be [3 7 11]


' --- End of File ---

' First, define a function that takes two arguments and adds them.
PRINT "REDUCE test "
PRINT 

FUNC MyAdd(accumulator, current_value)
    RETURN accumulator + current_value
ENDFUNC

' Create an array of numbers to sum.
my_numbers = [10, 20, 30, 40]

' Use REDUCE to apply the MyAdd function to the array.
' The initial value for the accumulator is 0.
total = REDUCE(MyAdd@, my_numbers, 0)

PRINT "The sum is: "; total ' Output: The sum is: 100

PRINT "Test done."
' --- End of File ---

' ===================================================================
' == jdBasic Regular Expression (REGEX) Demonstration
' ===================================================================
'
' This program demonstrates the usage of the new REGEX functions:
' - REGEX.MATCH: For validating strings against a pattern.
' - REGEX.FINDALL: For extracting all matching parts of a string.
' - REGEX.REPLACE: For finding and replacing text.
'
' -------------------------------------------------------------------

CLS
PRINT "--- jdBasic REGEX Function Showcase ---"
PRINT

' ===================================================================
' 1. REGEX.MATCH - For Validation and Simple Group Extraction
' ===================================================================

PRINT "--- 1. REGEX.MATCH ---"
PRINT

' --- Example 1a: Simple Validation (Is it a valid email?) ---
PRINT "Example 1a: Validating an email address"
email_pattern$ = "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
test_email_good$ = "test.user@example.com"
test_email_bad$ = "not-an-email"

PRINT "Pattern: "; email_pattern$
PRINT "Testing '"; test_email_good$; "': "; REGEX.MATCH(email_pattern$, test_email_good$) ' Should be TRUE
PRINT "Testing '"; test_email_bad$; "': "; REGEX.MATCH(email_pattern$, test_email_bad$)   ' Should be FALSE
PRINT

' --- Example 1b: Extracting Capture Groups ---
PRINT "Example 1b: Extracting parts of a date with capture groups"
date_pattern$ = "^(\d{4})-(\d{2})-(\d{2})$" ' Captures Year, Month, Day
test_date$ = "2025-07-10"

PRINT "Pattern: "; date_pattern$
PRINT "Testing '"; test_date$; "'"
date_parts = REGEX.MATCH(date_pattern$, test_date$)

IF len(date_parts) > 0 THEN
    PRINT "Match successful. Captured groups:"
    PRINT "  Year:  "; date_parts[0]
    PRINT "  Month: "; date_parts[1]
    PRINT "  Day:   "; date_parts[2]
ELSE
    PRINT "No match found."
ENDIF
PRINT

' ===================================================================
' 2. REGEX.FINDALL - For Extracting All Occurrences
' ===================================================================

PRINT "--- 2. REGEX.FINDALL ---"
PRINT

' --- Example 2a: Finding all numbers in a string ---
PRINT "Example 2a: Finding all numbers"
text_with_numbers$ = "Order 123 has 5 items for a total of 99.50 dollars."
number_pattern$ = "\d+\.?\d*" ' Matches one or more digits, optionally followed by a dot and more digits

PRINT "Text: "; text_with_numbers$
all_numbers = REGEX.FINDALL(number_pattern$, text_with_numbers$)
PRINT "All numbers found: "; all_numbers
PRINT

' --- Example 2b: Finding all key-value pairs with capture groups ---
PRINT "Example 2b: Finding key-value pairs"
config_string$ = "user=admin, pass=12345, host=localhost, port=8080"
kv_pattern$ = "(\w+)=(\w+)" ' Group 1 captures the key, Group 2 captures the value

PRINT "Text: "; config_string$
all_pairs = REGEX.FINDALL(kv_pattern$, config_string$)

PRINT "Found "; LEN(all_pairs); " pairs:"
' The result is a 2D array: [[key1, val1], [key2, val2], ...]
FOR i = 0 TO LEN(all_pairs) - 1
    key$ = all_pairs[i][0]
    value$ = all_pairs[i][1]
    PRINT "  Key: '"; key$; "', Value: '"; value$; "'"
NEXT i
PRINT

' ===================================================================
' 3. REGEX.REPLACE - For Transforming Text
' ===================================================================

PRINT "--- 3. REGEX.REPLACE ---"
PRINT

' --- Example 3a: Reformatting a date string ---
PRINT "Example 3a: Reformatting a date"
iso_date$ = "2025-07-10"
reformat_pattern$ = "(\d{4})-(\d{2})-(\d{2})"
' Use backreferences $3, $2, $1 to reorder the captured groups
us_format$ = "$2/$3/$1"

PRINT "Original date: "; iso_date$
new_date$ = REGEX.REPLACE(reformat_pattern$, iso_date$, us_format$)
PRINT "Reformatted date: "; new_date$
PRINT

' --- Example 3b: Censoring sensitive words ---
PRINT "Example 3b: Censoring words"
secret_message$ = "The secret codes are 'alpha' and 'gamma'."
censor_pattern$ = "alpha|gamma" ' Matches either 'alpha' or 'gamma'
censored_message$ = REGEX.REPLACE(censor_pattern$, secret_message$, "[REDACTED]")

PRINT "Original message: "; secret_message$
PRINT "Censored message: "; censored_message$
PRINT

PRINT "--- REGEX Demo Complete ---"


' --- End of File ---

'================================================================
' NeReLaBasic (jdBasic) ASYNC/AWAIT Demonstration
' This program shows how to run tasks in the background
' and wait for their results without blocking the main program.
' ================================================================

PRINT "--- Starting ASYNC/AWAIT Demonstration ---"
PRINT

' ================================================================
'          A S Y N C   F U N C T I O N   D E F I N I T I O N S
' ================================================================

' This function simulates a "download" that takes some time.
ASYNC FUNC DOWNLOADFILE(url$, duration)
  PRINT "  [Task 1] Starting download from "; url$
  ' Simulate work by looping
  FOR i = 1 TO duration
    PRINT "  [Task 1] ... downloading chunk "; i; " of "; duration; " ..."
  NEXT i
  PRINT "  [Task 1] Download finished."
  RETURN "Download of " + url$ + " successful."
ENDFUNC

' This function simulates a "data processing" job.
ASYNC FUNC PROCESSDATA(dataset$, duration)
  PRINT "    [Task 2] Starting to process data from "; dataset$
  ' Simulate work by looping
  FOR i = 1 TO duration
    PRINT "    [Task 2] ... processing record block "; i; " of "; duration; " ..."
  NEXT i
  PRINT "    [Task 2] Data processing finished."
  RETURN "Processed " + dataset$ + " and found 42 insights."
ENDFUNC

' --- Step 1: Start the asynchronous tasks ---
' We call two ASYNC functions. This creates two new tasks that
' start running in the background. The calls return immediately
' with a "Task Reference" handle, which we store in variables.
PRINT "Main: Kicking off background tasks..."
task1 = DOWNLOADFILE("https://example.com/data.zip", 5)
task2 = PROCESSDATA("some_large_dataset.csv", 3)
PRINT "Main: Background tasks have been started."
PRINT

' --- Step 2: Main program continues its own work ---
' While the background tasks are running, the main program is not
' blocked. It can continue to execute other commands.
PRINT "Main: Now doing other work while tasks run in the background."
FOR i = 1 TO 4
  PRINT "Main: ... processing main task step "; i; " ..."
  ' In a real program, you could do other things here,
  ' like updating the UI or handling user input.
NEXT i
PRINT "Main: Finished with other work."
PRINT

' --- Step 3: Wait for the tasks to complete and get results ---
' Now we use AWAIT. This will pause the main program until the
' specified task is finished. It then returns the value from
' the task's RETURN statement.

PRINT "Main: Now waiting for Task 1 to complete..."
result1 = AWAIT task1
PRINT "Main: Task 1 finished with result: '"; result1; "'"
PRINT

PRINT "Main: Now waiting for Task 2 to complete..."
result2 = AWAIT task2
PRINT "Main: Task 2 finished with result: '"; result2; "'"
PRINT

PRINT "--- Demonstration Complete ---"



' --- End of File ---

' jdBasic Sine Wave Plot
' This program demonstrates how to plot multiple sine waves with different
' properties using vectorized operations. It also includes simple axes.
' This version uses a single draw call with a line and color matrix.

' -------------------------------------------------
' 1. SETUP & INITIALIZATION
' -------------------------------------------------
SCREEN_W = 1920
SCREEN_H = 1080

' --- Graphing Parameters ---
NUM_POINTS = 1000 ' Number of points to calculate. More points = smoother curve.
NUM_SEGMENTS = NUM_POINTS - 1

' --- Wave 1 Parameters (Red) ---
AMPLITUDE1 = 400
FREQUENCY1 = 4
COLOR1 = [255, 50, 50]

' --- Wave 2 Parameters (Green) ---
AMPLITUDE2 = 250
FREQUENCY2 = 8
COLOR2 = [50, 255, 50]

' --- Wave 3 Parameters (Blue) ---
AMPLITUDE3 = 150
FREQUENCY3 = 2
COLOR3 = [100, 100, 255]

' --- Initialize Graphics ---
PRINT "Initializing graphics screen..."
SCREEN SCREEN_W, SCREEN_H, "Vectorized Sine Waves"
CLS 0, 0, 0 ' Clear screen to black

' -------------------------------------------------
' 2. GENERATE COORDINATE VECTORS
' -------------------------------------------------
' --- Create the base X-axis vector ---
' IOTA(NUM_POINTS) creates a vector [0, 1, 2, ..., NUM_POINTS-1]
x_axis = IOTA(NUM_POINTS)

' --- Scale the X-axis to fit the screen width ---
' This creates the pixel coordinates for the x-axis.
x_coords = x_axis * (SCREEN_W / (NUM_POINTS - 1))

' --- Animation Loop Variables ---
time_step = 0

' --- Create a dummy vector for building color matrices ---
dummy_vec = RESHAPE([1], [NUM_SEGMENTS])

' -------------------------------------------------
' 3. MAIN ANIMATION LOOP
' -------------------------------------------------
PRINT "Starting animation loop... Press any key to exit."
DO
    ' --- Clear the screen for the new frame ---
    CLS 0, 0, 0

    ' --- Draw Axes ---
    ' Draw the X-axis (horizontal line in the middle)
    LINE 0, SCREEN_H / 2, SCREEN_W, SCREEN_H / 2, 100, 100, 100
    ' Draw the Y-axis (vertical line near the left)
    LINE 20, 0, 20, SCREEN_H, 100, 100, 100

    ' --- Calculate Y Coordinates for all waves ---
    angle1 = (x_axis / NUM_POINTS) * FREQUENCY1 * 2 * PI + time_step
    y_coords1 = (SIN(angle1) * AMPLITUDE1) + (SCREEN_H / 2)

    angle2 = (x_axis / NUM_POINTS) * FREQUENCY2 * 2 * PI + time_step * 1.5
    y_coords2 = (SIN(angle2) * AMPLITUDE2) + (SCREEN_H / 2)

    angle3 = (x_axis / NUM_POINTS) * FREQUENCY3 * 2 * PI + time_step * 0.5
    y_coords3 = (SIN(angle3) * AMPLITUDE3) + (SCREEN_H / 2)

    ' --- Create line segment matrices for each wave ---
    x1_vec = SLICE(x_coords, 0, 0, NUM_SEGMENTS)
    x2_vec = SLICE(x_coords, 0, 1, NUM_SEGMENTS)

    y1_vec1 = SLICE(y_coords1, 0, 0, NUM_SEGMENTS)
    y2_vec1 = SLICE(y_coords1, 0, 1, NUM_SEGMENTS)
    lines1 = STACK(1, x1_vec, y1_vec1, x2_vec, y2_vec1)

    y1_vec2 = SLICE(y_coords2, 0, 0, NUM_SEGMENTS)
    y2_vec2 = SLICE(y_coords2, 0, 1, NUM_SEGMENTS)
    lines2 = STACK(1, x1_vec, y1_vec2, x2_vec, y2_vec2)

    y1_vec3 = SLICE(y_coords3, 0, 0, NUM_SEGMENTS)
    y2_vec3 = SLICE(y_coords3, 0, 1, NUM_SEGMENTS)
    lines3 = STACK(1, x1_vec, y1_vec3, x2_vec, y2_vec3)

    ' --- Create color matrices for each wave ---
    ' Each matrix will have NUM_SEGMENTS rows, with each row being the wave's color.
    colors1 = STACK(1, dummy_vec * COLOR1[0], dummy_vec * COLOR1[1], dummy_vec * COLOR1[2])
    colors2 = STACK(1, dummy_vec * COLOR2[0], dummy_vec * COLOR2[1], dummy_vec * COLOR2[2])
    colors3 = STACK(1, dummy_vec * COLOR3[0], dummy_vec * COLOR3[1], dummy_vec * COLOR3[2])

    ' --- Draw all lines ---

    LINE lines1, colors1
    LINE lines2, colors2
    LINE lines3, colors3

    ' --- Update the screen and advance the animation ---
    SCREENFLIP
    time_step = time_step + 0.05
    SLEEP 16 ' Aim for ~60 FPS

    ' --- Check for user input to exit the loop ---
    a$ = INKEY$()
LOOP UNTIL a$ > ""

' --- Clean up ---
PRINT "Animation finished."

' --- End of File ---

' jdBasic Sine Wave Plot
' This program demonstrates how to plot multiple sine waves with different
' properties using vectorized operations. It also includes simple axes.

' -------------------------------------------------
' 1. SETUP & INITIALIZATION
' -------------------------------------------------
SCREEN_W = 1920
SCREEN_H = 1080

' --- Graphing Parameters ---
NUM_POINTS = 1000 ' Number of points to calculate. More points = smoother curve.

' --- Wave 1 Parameters (Red) ---
AMPLITUDE1 = 400
FREQUENCY1 = 4
COLOR1 = [255, 50, 50]

' --- Wave 2 Parameters (Green) ---
AMPLITUDE2 = 250
FREQUENCY2 = 8
COLOR2 = [50, 255, 50]

' --- Wave 3 Parameters (Blue) ---
AMPLITUDE3 = 150
FREQUENCY3 = 2
COLOR3 = [100, 100, 255]

' --- Axes Color ---
AXIS_COLOR = [100, 100, 100] ' Grey

' --- Initialize Graphics ---
PRINT "Initializing graphics screen..."
SCREEN SCREEN_W, SCREEN_H, "Vectorized Sine Waves"
CLS 0, 0, 0 ' Clear screen to black

' -------------------------------------------------
' 2. GENERATE COORDINATE VECTORS
' -------------------------------------------------
' --- Create the base X-axis vector ---
' IOTA(NUM_POINTS) creates a vector [0, 1, 2, ..., NUM_POINTS-1]
x_axis = IOTA(NUM_POINTS)

' --- Scale the X-axis to fit the screen width ---
' This creates the pixel coordinates for the x-axis.
x_coords = x_axis * (SCREEN_W / (NUM_POINTS - 1))

' --- Animation Loop Variables ---
time_step = 0

' -------------------------------------------------
' 3. MAIN ANIMATION LOOP
' -------------------------------------------------
PRINT "Starting animation loop... Press any key to exit."
DO
    ' --- Clear the screen for the new frame ---
    CLS 0, 0, 0

    ' --- Prepare and Draw Wave 1 (Red) ---
    angle1 = (x_axis / NUM_POINTS) * FREQUENCY1 * 2 * PI + time_step
    y_wave1 = SIN(angle1)
    y_coords1 = (y_wave1 * AMPLITUDE1) + (SCREEN_H / 2)
    x1_vec1 = SLICE(x_coords, 0, 0, NUM_POINTS - 1)
    y1_vec1 = SLICE(y_coords1, 0, 0, NUM_POINTS - 1)
    x2_vec1 = SLICE(x_coords, 0, 1, NUM_POINTS - 1)
    y2_vec1 = SLICE(y_coords1, 0, 1, NUM_POINTS - 1)
    lines_to_draw1 = STACK(1, x1_vec1, y1_vec1, x2_vec1, y2_vec1)
    DRAWCOLOR COLOR1
    LINE lines_to_draw1

    ' --- Prepare and Draw Wave 2 (Green) ---
    angle2 = (x_axis / NUM_POINTS) * FREQUENCY2 * 2 * PI + time_step * 1.5
    y_wave2 = SIN(angle2)
    y_coords2 = (y_wave2 * AMPLITUDE2) + (SCREEN_H / 2)
    x1_vec2 = SLICE(x_coords, 0, 0, NUM_POINTS - 1)
    y1_vec2 = SLICE(y_coords2, 0, 0, NUM_POINTS - 1)
    x2_vec2 = SLICE(x_coords, 0, 1, NUM_POINTS - 1)
    y2_vec2 = SLICE(y_coords2, 0, 1, NUM_POINTS - 1)
    lines_to_draw2 = STACK(1, x1_vec2, y1_vec2, x2_vec2, y2_vec2)
    DRAWCOLOR COLOR2
    LINE lines_to_draw2

    ' --- Prepare and Draw Wave 3 (Blue) ---
    angle3 = (x_axis / NUM_POINTS) * FREQUENCY3 * 2 * PI + time_step * 0.5
    y_wave3 = SIN(angle3)
    y_coords3 = (y_wave3 * AMPLITUDE3) + (SCREEN_H / 2)
    x1_vec3 = SLICE(x_coords, 0, 0, NUM_POINTS - 1)
    y1_vec3 = SLICE(y_coords3, 0, 0, NUM_POINTS - 1)
    x2_vec3 = SLICE(x_coords, 0, 1, NUM_POINTS - 1)
    y2_vec3 = SLICE(y_coords3, 0, 1, NUM_POINTS - 1)
    lines_to_draw3 = STACK(1, x1_vec3, y1_vec3, x2_vec3, y2_vec3)
    DRAWCOLOR COLOR3
    LINE lines_to_draw3

    ' --- Draw Axes ---
    ' Draw the X-axis (horizontal line in the middle)
    DRAWCOLOR AXIS_COLOR
    LINE 0, SCREEN_H / 2, SCREEN_W, SCREEN_H / 2
    ' Draw the Y-axis (vertical line near the left)
    LINE 20, 0, 20, SCREEN_H

    ' --- Update the screen and advance the animation ---
    SCREENFLIP
    time_step = time_step + 0.05
    SLEEP 16 ' Aim for ~60 FPS

    ' --- Check for user input to exit the loop ---
    a$ = INKEY$()
LOOP UNTIL a$ > ""

' --- Clean up ---
PRINT "Animation finished."

' --- End of File ---

' Test program for the new SOLVE function

' We want to solve the system Ax = b
'
'      [ 2  1 -1 ] [ x1 ]   [  8 ]
'  A = [ -3 -1  2 ] [ x2 ] = [ -11 ] = b
'      [ -2  1  2 ] [ x3 ]   [ -3 ]
'
' The known solution is x = [ 2, 3, -1 ]

PRINT "Setting up the matrix A and vector b..."

DIM A[3, 3]
A[0,0] = 2 : A[0,1] = 1 : A[0,2] = -1
A[1,0] = -3 : A[1,1] = -1 : A[1,2] = 2
A[2,0] = -2 : A[2,1] = 1 : A[2,2] = 2

DIM b[3]
b[0] = 8
b[1] = -11
b[2] = -3

PRINT "Matrix A:"
PRINT A
PRINT "Vector b:"
PRINT b
PRINT ""

PRINT "Calling SOLVE(A, b)..."
DIM x[0] ' Define x, will be resized by the function result
x = SOLVE(A, b)

PRINT "Solution vector x:"
PRINT x

PRINT "Expected solution is [2 3 -1]"

' --- End of File ---

' ==========================================================
' == jdBASIC Interactive Synthesizer Demo
' ==========================================================
'
' This program demonstrates the SOUND.* commands by creating
' a playable on-screen piano keyboard.
'
' --- CONTROLS ---
' Keys A,S,D,F,G,H,J,K map to the white keys (C4 to C5).
' Keys W,E,T,Y,U map to the black keys.
' Press ESC to quit.
'
' ----------------------------------------------------------

' --- Initialization ---
OPTION "NOPAUSE"
SCREEN 800, 300, "jdBASIC Synthesizer"
SOUND.INIT

' Configure a "Rhodes" like electric piano sound on track 0
' waveform$, attack, decay, sustain, release
SOUND.VOICE 0, "SINE", 0.01, 0.3, 0.4, 0.4

' Configure a "Synth Bass" sound on track 1
SOUND.VOICE 1, "SAW", 0.02, 0.1, 0.9, 0.2


' --- Data Setup ---
' Create a MAP to store note frequencies for easy lookup.
DIM NOTES As MAP

NOTES{"C4"}  = 261.63 : NOTES{"C#4"} = 277.18
NOTES{"D4"}  = 293.66 : NOTES{"D#4"} = 311.13
NOTES{"E4"}  = 329.63
NOTES{"F4"}  = 349.23 : NOTES{"F#4"} = 369.99
NOTES{"G4"}  = 392.00 : NOTES{"G#4"} = 415.30
NOTES{"A4"}  = 440.00 : NOTES{"A#4"} = 466.16
NOTES{"B4"}  = 493.88
NOTES{"C5"}  = 523.25

' Map keyboard keys to note names.
DIM KEY_MAP As MAP
KEY_MAP{"A"}="C4"  : KEY_MAP{"S"}="D4" : KEY_MAP{"D"}="E4"
KEY_MAP{"F"}="F4"  : KEY_MAP{"G"}="G4" : KEY_MAP{"H"}="A4"
KEY_MAP{"J"}="B4"  : KEY_MAP{"K"}="C5"
' Black keys
KEY_MAP{"W"}="C#4" : KEY_MAP{"E"}="D#4" : KEY_MAP{"T"}="F#4"
KEY_MAP{"Y"}="G#4" : KEY_MAP{"U"}="A#4"


' --- Drawing Subroutine ---
SUB DRAW_KEYBOARD(LAST_KEY$)
  CLS 30, 30, 40
  
  ' Draw White Keys
  WHITE_KEYS$ = "ASDFGHJK"
  FOR i = 0 TO LEN(WHITE_KEYS$) - 1
    key_char$ = MID$(WHITE_KEYS$, i + 1, 1)
    x = 50 + (i * 80)
    
    ' Highlight the currently pressed key
    IF key_char$ = UCASE$(LAST_KEY$) THEN
      RECT x, 50, 78, 180, 200, 200, 255, TRUE
    ELSE
      RECT x, 50, 78, 180, 255, 255, 255, TRUE
    ENDIF
    RECT x, 50, 78, 180, 0, 0, 0, FALSE ' Border
    TEXT x + 30, 200, key_char$, 0, 0, 0
  NEXT i
  
  ' Draw Black Keys
  BLACK_KEYS$ = "WETYU"
  BLACK_KEY_POS = [1.5, 2.5, 4.5, 5.5, 6.5]
  FOR i = 0 TO LEN(BLACK_KEYS$) - 1
      key_char$ = MID$(BLACK_KEYS$, i + 1, 1)
      x = 50 + (BLACK_KEY_POS[i] * 80)
      
      IF key_char$ = UCASE$(LAST_KEY$) THEN
        RECT x, 50, 50, 120, 150, 150, 150, TRUE
      ELSE
        RECT x, 50, 50, 120, 0, 0, 0, TRUE
      ENDIF
      TEXT x + 18, 150, key_char$, 255, 255, 255
  NEXT i
  
  TEXT 10, 270, "Press keyboard keys to play notes. ESC to quit.", 200, 200, 200
  SCREENFLIP
ENDSUB


' --- Main Program Loop ---
LAST_KEY_PLAYED$ = ""

QUIT = false

DO
  ' Initial draw
  DRAW_KEYBOARD(LAST_KEY_PLAYED$)

  ' Loop while waiting for a key press
  DO
    KEY_PRESSED$ = UCASE$(INKEY$())
    IF KEY_PRESSED$ <> "" THEN EXITDO
    
    ' If a note was playing but no key is pressed now, release it.
    IF LAST_KEY_PLAYED$ <> "" THEN
      SOUND.RELEASE 0
      LAST_KEY_PLAYED$ = ""
      DRAW_KEYBOARD(LAST_KEY_PLAYED$) ' Redraw to un-highlight
    ENDIF
    
    SLEEP 10 ' Small delay to prevent high CPU usage
  LOOP UNTIL QUIT

  IF QUIT THEN EXITDO

  ' Check for ESC key to quit
  IF ASC(KEY_PRESSED$) = 27 THEN
    QUIT = TRUE
  ENDIF

  ' Check if the pressed key is a valid note and is a *new* note
  IF MAP.EXISTS(KEY_MAP, KEY_PRESSED$) AND KEY_PRESSED$ <> LAST_KEY_PLAYED$ THEN
      NOTE_NAME$ = KEY_MAP{KEY_PRESSED$}
      FREQ = NOTES{NOTE_NAME$}
      
      ' Play the new note
      SOUND.PLAY 0, FREQ
      
      ' Play a bass note an octave lower on track 1
      SOUND.PLAY 1, FREQ / 2
      
      LAST_KEY_PLAYED$ = KEY_PRESSED$
  ENDIF
  
LOOP UNTIL QUIT

' --- End of File ---

' ==========================================================
' == jdBasic Sprite System Test Program
' ==
' == This program demonstrates loading, creating, moving,
' == and detecting collisions between sprites.
' ==========================================================

' --- 1. Initialization ---
PRINT "Initializing Graphics and Sound..."
SCREEN 800, 600, "jdBasic Sprite Test"
SOUND.INIT

' --- 2. Load Assets ---
' NOTE: You must provide 'player.png' and 'enemy.png' files
' in the same directory as the interpreter to run this demo.
' They should be small images (e.g., 32x32 pixels).
PRINT "Loading sprite images..."
SPRITE.LOAD 1, "player.png" ' Assign image to type_id 1
SPRITE.LOAD 2, "enemy.png"  ' Assign image to type_id 2

' Configure a simple sound voice for collision feedback
SOUND.VOICE 0, "SQUARE", 0.01, 0.1, 0.5, 0.2

' --- 3. Create Game Objects ---
PRINT "Creating sprites..."
PLAYER_ID = SPRITE.CREATE(1, 400, 500) ' Create player sprite from type 1
ENEMY1_ID = SPRITE.CREATE(2, 100, 100) ' Create enemy sprite from type 2
ENEMY2_ID = SPRITE.CREATE(2, 700, 150) ' Create another enemy

' --- 4. Set Initial Velocities ---
' Make the enemies move automatically
SPRITE.SET_VELOCITY ENEMY1_ID, 2, 1.5
SPRITE.SET_VELOCITY ENEMY2_ID, -1.5, 2

' --- 5. Main Game Loop ---
PRINT "Starting main loop... Press ESC to quit."
DO
  ' --- Handle Input: Exit on ESC key ---
  k$ = INKEY$
  IF k$ = CHR$(27) THEN ' 27 is the ASCII code for ESC
    EXITDO
  ENDIF

  ' --- Player Control: Move player sprite to mouse position ---
  SPRITE.MOVE PLAYER_ID, MOUSEX(), MOUSEY()

  ' --- Update Game State ---
  SPRITE.UPDATE ' Move all sprites based on their set velocities

  ' --- Simple AI: Bounce enemies off the screen edges ---
  ' A real game would need GET_VELOCITY functions to do this properly.
  ' Here we just reset the position for simplicity.
  IF SPRITE.GET_X(ENEMY1_ID) < 0 OR SPRITE.GET_X(ENEMY1_ID) > 770 THEN
      SPRITE.MOVE ENEMY1_ID, 400, 100
  ENDIF
  IF SPRITE.GET_Y(ENEMY2_ID) < 0 OR SPRITE.GET_Y(ENEMY2_ID) > 570 THEN
      SPRITE.MOVE ENEMY2_ID, 400, 100
  ENDIF

  ' --- Check for Collisions ---
  COLLISION_STATUS$ = "No Collision"
  ' Check if the player sprite is touching either enemy sprite
  IF SPRITE.COLLISION(PLAYER_ID, ENEMY1_ID) OR SPRITE.COLLISION(PLAYER_ID, ENEMY2_ID) THEN
      COLLISION_STATUS$ = "COLLISION!"
      SOUND.PLAY 0, 220 ' Play a low 'A' note
  ENDIF

  ' --- Drawing Phase ---
  CLS 0, 0, 50 ' Clear screen to a dark blue

  SPRITE.DRAW_ALL ' Draw all active sprites at their new positions

  ' Draw UI / Status Text
  TEXT 10, 10, "jdBasic Sprite Demo", 255, 255, 0 ' Yellow
  TEXT 10, 40, "Move mouse to control player. Press ESC to quit.", 200, 200, 200 ' Grey
  TEXT 650, 10, COLLISION_STATUS$, 255, 0, 0 ' Red

  SCREENFLIP ' Push everything drawn to the window

  SLEEP 16 ' Wait for ~16ms to target roughly 60 FPS

LOOP UNTIL FALSE ' Loop "forever" until EXITDO is called

' --- 6. Shutdown ---
PRINT "Program finished."
' The graphics system will be shut down automatically by the interpreter.
' --- End of File ---

' sqlite_test.jdb

' Load the new SQLite module
DLLIMPORT "sqlitefunc"

PRINT "SQLite Test Program"
PRINT "-------------------"

PRINT "Current Directory: ";
PWD

' Try to open a database.
db = SQLITE.OPEN("test.db")

' Check if the handle is valid
IF TYPEOF(db) <> "SQLITEDB" THEN
    PRINT
    PRINT "--- DATABASE OPEN FAILED! ---"
    PRINT "Reason: " + SQLITE.ERROR$() ' <-- ADD THIS LINE
    PRINT "-----------------------------"
    GOTO Ende
ENDIF


PRINT "Database opened successfully."

' Create a table. Use EXEC for commands that don't return rows.
sql_create$ = "CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, name TEXT, score REAL);"
success = SQLITE.EXEC(db, sql_create$)
IF NOT success THEN
    PRINT "Error creating table: " + SQLITE.ERROR$()
    SQLITE.CLOSE db
    GOTO Ende
ENDIF

' Insert some data
SQLITE.EXEC(db, "INSERT INTO users (name, score) VALUES ('Alice', 100.5);")
SQLITE.EXEC(db, "INSERT INTO users (name, score) VALUES ('Bob', 95.2);")
SQLITE.EXEC(db, "INSERT INTO users (name, score) VALUES ('Charlie', 110.0);")

PRINT "Data inserted."

' Query the data back
sql_query$ = "SELECT id, name, score FROM users WHERE score > 100;"
results = SQLITE.QUERY(db, sql_query$)

IF TYPEOF(results) = "ARRAY" THEN
    PRINT
    PRINT "Query Results (score > 100):"
    FOR i = 0 TO LEN(results)[0] - 1
        user_row = results[i]
        PRINT "ID: " + user_row{"id"} + ", Name: " + user_row{"name"} + ", Score: " + user_row{"score"}
    NEXT i
ELSE
    PRINT "Query failed: " + SQLITE.ERROR$()
ENDIF

' Close the database connection
SQLITE.CLOSE db
PRINT
PRINT "Database closed."
goto out

ende:
PRINT "An error occured"
out:
PRINT "Program finished"

' --- End of File ---

PRINT "--- String Operator Showcase ---"

' 1. Concatenation (+)
PRINT "Hello " + "World!"

' 2. Replacement (-)
PRINT "The quick brown fox jumps over the lazy dog" - "brown "
PRINT "ababababc" - "ab"

' 3. Repetition (*)
PRINT "-" * 40
PRINT "Beetlejuice " * 3

' 4. Slicing (/)
PRINT 5 / "This is a long string"  ' Left part
PRINT "This is a long string" / 6  ' Right part

' 5. Unary Minus (-) to split string
char_array = -"jdBasic"
PRINT "Character array from 'jdBasic':"
PRINT char_array

' Chaining them together
PRINT ("Atomi "+("A"*10)+" truncate me." - "AA") / 3


' --- End of File ---

' Import the MATH module. The interpreter will look for "MATH.bas"
' and compile it before running this program.
import MATH

print "--- Module Test Program ---"
print

' Call the exported 'add' function from the MATH module
print "Calling MATH.ADD(15, 7)..."
x = MATH.ADD(15, 7)
print "Result:"; x
print

' Call the exported 'add_and_double' function
print "Calling MATH.ADD_AND_DOUBLE(10, 5)..."
y = MATH.ADD_AND_DOUBLE(10, 5)
print "Result:"; y
print

' Call the exported 'print_sum' procedure
print "Calling MATH.PRINT_SUM 100, 23..."
MATH.PRINT_SUM 100, 23

print

print "--- Module Test Complete ---"

Print "For Next Test"

for i = 1 to 5
 print "lall: "; i
next i

print "done"
print "------------------------"

Print "Nested For Next Test"

for i = 1 to 5
    for j = 1 to 5
        print "lall: "; i*j
    next j
    print
next i

print "done"
print "------------------------"

PRINT "Goto/Label and if then else Test"

i = 0
fluppi:
i = i + 1

print i;

if i > 20 then
   goto ende
else
   print "luli"
endif

GoTo fluppi

ende:
print "done"
print "------------------------"

PRINT "Array Test"

Dim a[20]

for i = 0 to 19
  a[i] = i*2
next i

for i = 0 to 19
  print "Zahl #",i, " ist: ", a[i]
next i

my_numbers = [10, 20, 30, 40, 50]
my_strings$ = ["alpha", "beta", "gamma"]

PRINT "--- Strings ---"
FOR i = 0 TO len(my_strings$)-1
    PRINT my_strings$[i]
NEXT i

PRINT "--- Numbers ---"
FOR i = 0 TO len(my_numbers)-1
    PRINT my_numbers[i]
NEXT i

print "done"
print "------------------------"

PRINT "--- String and Math Function Test ---"

GREETING$ = "   Hello, World!   "
PRINT "Original: '"; GREETING$; "'"
PRINT "Trimmed: '"; TRIM$(GREETING$); "'"
PRINT "Length of trimmed: "; LEN(TRIM$(GREETING$))
PRINT

PRINT "LEFT 5: "; LEFT$(TRIM$(GREETING$), 5)
PRINT "RIGHT 6: "; RIGHT$(TRIM$(GREETING$), 6)
PRINT "MID from 8 for 5: "; MID$(TRIM$(GREETING$), 8, 5)

PRINT "LOWER: "; LCASE$("THIS IS A TEST")
PRINT "UPPER: "; UCASE$("this is a test")
PRINT

PRINT "ASCII for 'A' is "; ASC("A")
PRINT "Character for 66 is "; CHR$(66)
PRINT

PRINT "VAL of '100.00' is "; VAL("100.00")
PRINT "STR of 100.00 is "; STR$(100.00)
PRINT


HAYSTACK$ = "the quick brown fox jumps over the lazy dog"
PRINT "Position of 'fox' is "; INSTR(HAYSTACK$, "fox")
PRINT "Position of 'the' after pos 5 is "; INSTR(5, HAYSTACK$, "the")
PRINT

PRINT "--- Math Test ---"
X = 90
PRINT "The square root of ";X;" is "; SQR(X)

' Note: SIN/COS/TAN work in radians, not degrees

PRINT "The sine of PI/2 is roughly "; SIN(PI / 2)

print "10 random, Numbers: ";
for i = 1 to 10
PRINT RND(1); " ";
Next i
print
PRINT "--- DATE Test ---"
Print "Tick: "; Tick()
Print "Now: "; Now()

DIM deadline AS DATE
DIM name AS STRING

name = "Project Apollo"
deadline = CVDate("2025-07-01")

PRINT "Deadline for "; name; " is "; deadline

deadline = DATEADD("D", 10, deadline)
PRINT "Extended deadline is "; deadline

If deadline > Now() then
   print "Deadline is greater"
endif

print "done"
PRINT "--- String, Math and DATE Function Test COMPLETE ---"


funci:
Print "Functional tests"
print
Print "Function Definition and call functions"

func lall(a,b)
    return a*b
endfunc

print "func call:"
b=lall(5,3)
print b

print
print "Done"
print "------------------------"

print "Using higher order functions"
print

func inc(ab)
    return ab+1
endfunc
func dec(ac)
    return ac-1
endfunc

func apply(fa,cc)
    return fa(cc)
endfunc

print apply(inc@,10)
print apply(dec@,12)

print
print "Done"
print "------------------------"

print "Factional recursion"
print

func factorial(a)
    if a > 1 then
        return factorial(a-1)*a
    else
        return a
    endif
endfunc

lall =  factorial(5)
print "erg: ", lall

print
print "Done"
print "------------------------"

print "Simple recursion"
print

func count_asc(n)
   if n < 0 then return n
   count_asc(n-1)
   print n
endfunc

func count_desc(n)
    if n >= 0 then
        print n
	r=count_desc(n - 1)
    endif
endfunc

print "Result ASC: "
count_asc(5)
print "Result DEC: "
count_desc(5)

print
print "Done"
print "------------------------"

print "Map and Filter"
print

Dim o_map[20]

s_map = [1,5,8,7,45,66,12]

sub printresult(result)
   for i = 0 to len(result)-1
       if result[i]>0 then
           print result[i], " ";
       endif
   next i
print
endsub

func iseven(a)
   if a mod 2 = 0 then
      r=1
   else
      r=0
   endif
   return r
endfunc

func filter(fu,in[],out[])
   j=0
   for i = 0 to len(in) - 1
      m=fu(in[i])
      if m = 1 then
         out[j]=in[i]
         j=j+1
      endif
   next i
endfunc

filter(iseven@,s_map,o_map)

print "Result filter: "
printresult o_map

print
print "Done"
print "------------------------"

PRINT "Single Line IF Test"
print

FOR i = 0 to 10
	IF I = 5 THEN PRINT "LALL"; I
	PRINT "LULL"; i
NEXT I
PRINT "ENDE"

print "--- do/while/loop test ---"
i=0
do while i < 5
 i=i+1
 print "Achim: "; I
loop
print

print "--- do/until/loop test ---"
i=0
do until i > 5
 i=i+1
 print "Achim: "; I
loop
print

print "--- do/loop/while test ---"
i=0
do
 i=i+1
 print "Achim: "; I
loop while i < 5
print

print "--- do/loop/until exit do test ---"
i=0
do
 i=i+1
 if i = 3 THEN
    print "Exit do at i: "; I
    exitdo
 endif
 j = 0
 do until j > 4
    j = j + 1
    if j = 2 THEN
        print "inner exit do by: "; j
        exitdo
    endif
 loop
 print "Atomi's loop# "; I
loop until i > 5

print "--- test done ---"


' --- End of File ---

' ===================================================================
' == jdBASIC Generic Function Plotting Library
' ===================================================================
'
' This library provides a subroutine, PLOTTER, to draw a 2D graph
' of any user-defined function.
'
' --- HOW TO USE ---
' 1. Define a function in your code that takes one argument (x)
'    and returns a numeric value (y).
'    e.g., func my_func(x)
'              return SIN(x) * 5
'          endfunc
'
' 2. Call the PLOTTER subroutine with the required parameters.
'
' -------------------------------------------------------------------

' --- Coordinate Mapping Functions (Corrected Syntax) ---
' These functions convert math coordinates to screen pixel coordinates.
func MAP_X(x)
    return PLOT_LEFT + (x - X_MIN) * PLOT_W / (X_MAX - X_MIN)
endfunc

func MAP_Y(y)
    return PLOT_BOTTOM - (y - Y_MIN) * PLOT_H / (Y_MAX - Y_MIN)
endfunc

SUB PLOTTER(FN_TO_PLOT, X_MIN, X_MAX, Y_MIN, Y_MAX, TITLE$)
    ' --- Parameters ---
    ' FN_TO_PLOT: A function reference to the function to be plotted.
    ' X_MIN, X_MAX: The domain (min and max x-values) for the plot.
    ' Y_MIN, Y_MAX: The range (min and max y-values) for the plot.
    ' TITLE$: A string to display as the title of the graph.
    ' ----------------------------------------------------------------

    ' --- Configuration ---
    SCREEN_W = 800
    SCREEN_H = 600
    MARGIN = 60 ' Pixels to leave around the edge of the screen

    ' Plotting area dimensions
    PLOT_W = SCREEN_W - (2 * MARGIN)
    PLOT_H = SCREEN_H - (2 * MARGIN)
    PLOT_LEFT = MARGIN
    PLOT_TOP = MARGIN
    PLOT_RIGHT = PLOT_LEFT + PLOT_W
    PLOT_BOTTOM = PLOT_TOP + PLOT_H

    ' --- Drawing ---
    SCREEN SCREEN_W, SCREEN_H, "jdBASIC Function Plotter"
    CLS 0, 15, 30 ' Clear to a dark blue background

    ' Draw Plot Title
    TEXT 10, 10, TITLE$, 200, 200, 255

    ' Draw Plot Area Bounding Box
    RECT PLOT_LEFT, PLOT_TOP, PLOT_W, PLOT_H, 50, 80, 100, FALSE

    ' --- Draw Axes and Labels ---
    ' Calculate position of math origin (0,0) on the screen
    ORIGIN_SX = MAP_X(0)
    ORIGIN_SY = MAP_Y(0)
    
    ' Draw X-Axis (only if it's visible within the plot area)
    IF ORIGIN_SY >= PLOT_TOP AND ORIGIN_SY <= PLOT_BOTTOM THEN
        LINE PLOT_LEFT, ORIGIN_SY, PLOT_RIGHT, ORIGIN_SY, 100, 130, 150
    ENDIF

    ' Draw Y-Axis (only if it's visible)
    IF ORIGIN_SX >= PLOT_LEFT AND ORIGIN_SX <= PLOT_RIGHT THEN
        LINE ORIGIN_SX, PLOT_TOP, ORIGIN_SX, PLOT_BOTTOM, 100, 130, 150
    ENDIF
    
    ' Draw Axis Labels
    TEXT PLOT_LEFT - 10, PLOT_BOTTOM + 10, STR$(X_MIN), 180, 180, 180
    TEXT PLOT_RIGHT - 10, PLOT_BOTTOM + 10, STR$(X_MAX), 180, 180, 180
    TEXT PLOT_LEFT - 40, PLOT_BOTTOM, STR$(Y_MIN), 180, 180, 180
    TEXT PLOT_LEFT - 40, PLOT_TOP, STR$(Y_MAX), 180, 180, 180

    ' --- Plot the Function ---
    ' Calculate step size for smooth plotting (one pixel at a time)
    X_STEP = (X_MAX - X_MIN) / PLOT_W

    FOR x = X_MIN TO X_MAX STEP X_STEP
        ' Calculate current point and next point
        y1 = FN_TO_PLOT(x)
        y2 = FN_TO_PLOT(x + X_STEP)

        ' Convert math coordinates to screen coordinates
        sx1 = MAP_X(x)
        sy1 = MAP_Y(y1)
        sx2 = MAP_X(x + X_STEP)
        sy2 = MAP_Y(y2)

        ' Draw a line segment, but only if it's within the plot's Y-range
        IF (y1 >= Y_MIN AND y1 <= Y_MAX) OR (y2 >= Y_MIN AND y2 <= Y_MAX) THEN
            LINE sx1, sy1, sx2, sy2, 150, 255, 150
        ENDIF
    NEXT x

    ' Update the screen to show the final plot
    SCREENFLIP
ENDSUB


' ===================================================================
' ==                  EXAMPLE USAGE
' ===================================================================

' 1. Define the functions you want to plot using the func..endfunc syntax.
'    The function must take one parameter.
func SINE_WAVE(x)
    return SIN(x) * 2
endfunc

func PARABOLA(x)
    return (x * x) - 4
endfunc

func COMPLEX_FUNC(x)
    return COS(x) * x
endfunc

' --- Plot the Sine Wave ---
PLOTTER SINE_WAVE@, -5, 5, -3, 3, "y = SIN(x) * 2"
SLEEP 4000 ' Pause for 4 seconds to view the plot

' --- Plot the Parabola ---
PLOTTER PARABOLA@, -4, 4, -5, 12, "y = x^2 - 4" 
SLEEP 4000

' --- Plot the more Complex Function ---
PLOTTER COMPLEX_FUNC@, -10, 10, -10, 10, "y = COS(x) * x" 
SLEEP 4000

' --- End of File ---

' TensorFlow Tier 1 Test Script
' Requires tffunc.dll and model.pb

DLLIMPORT "tffunc"
PRINT "TensorFlow Version: "; TENSORFLOW.VERSION()
PRINT

' 1. Create Graph and Session
GraphHandle = TENSORFLOW.NEW_GRAPH()
TENSORFLOW.LOAD_GRAPH_FROM_FILE(GraphHandle, "model.pb")
SessionHandle = TENSORFLOW.NEW_SESSION(GraphHandle)

PRINT "Handles created:"
PRINT "Graph: "; GraphHandle
PRINT "Session: "; SessionHandle
PRINT

' 2. Prepare input data with the correct 2D shape
DIM InputData[1, 4]
InputData[0, 0] = 1.0
InputData[0, 1] = 2.0
InputData[0, 2] = 3.0
InputData[0, 3] = 4.0

' 3. Create a tensor using the default FLOAT type
InputTensor = TENSORFLOW.NEW_TENSOR_FROM_ARRAY(InputData)

PRINT "Input Tensor Info:"
PRINT "  Handle: "; InputTensor
PRINT "  Shape: "; FRMV$(TENSORFLOW.GET_TENSOR_SHAPE(InputTensor))
PRINT "  DType: "; TENSORFLOW.GET_TENSOR_DTYPE(InputTensor)
PRINT

' 4. Run Inference
DIM Inputs AS MAP
Inputs{"input:0"} = InputTensor

DIM Outputs[1]
Outputs[0] = "output:0"
    
ResultMap = TENSORFLOW.SESSION_RUN(SessionHandle, GraphHandle, Inputs, Outputs,[])

' 5. Process and inspect the results
IF TYPEOF(ResultMap) = "MAP" THEN
  ResultTensor = ResultMap{"output:0"}
  ResultArray = TENSORFLOW.NEW_ARRAY_FROM_TENSOR(ResultTensor)
  
  PRINT "Inference Result:"
  PRINT "  Tensor Handle: "; ResultTensor
  PRINT "  Result Shape: "; FRMV$(TENSORFLOW.GET_TENSOR_SHAPE(ResultTensor))
  PRINT "  Result DType: "; TENSORFLOW.GET_TENSOR_DTYPE(ResultTensor)
  PRINT "  Result Array: "; FRMV$(ResultArray)
ELSE
  PRINT "Inference failed."
ENDIF

PRINT
PRINT "Done."

' --- End of File ---

' TensorFlow Tier 2 Training Test (FINAL SCALAR VERSION)

DLLIMPORT "tffunc"

PRINT "--- Building and Training a Graph (FINAL SCALAR VERSION) ---"

PRINT

' 1. Create a Graph

G = TENSORFLOW.NEW_GRAPH()

DIM empty_attrs AS MAP



' 2. Define Placeholders

DIM X_shape[2] : X_shape[0] = -1 : X_shape[1] = 1

X = TENSORFLOW.PLACEHOLDER(G, "FLOAT", X_shape, "X_input")

DIM Y_shape[2] : Y_shape[0] = -1 : Y_shape[1] = 1

Y_ = TENSORFLOW.PLACEHOLDER(G, "FLOAT", Y_shape, "Y_label")



' 3. Define trainable Variable HANDLES

' W is now a scalar stored as shape [1]

DIM W_shape[1] : W_shape[0] = 1

DIM W_attrs AS MAP

W_attrs{"shape"} = W_shape

W_attrs{"dtype"} = "DT_FLOAT"

W = TENSORFLOW.ADD_OPERATION(G, "VarHandleOp", "Weight", [], W_attrs)



' Bias also as scalar

DIM B_shape[1] : B_shape[0] = 1

DIM B_attrs AS MAP

B_attrs{"shape"} = B_shape

B_attrs{"dtype"} = "DT_FLOAT"

B = TENSORFLOW.ADD_OPERATION(G, "VarHandleOp", "Bias", [], B_attrs)



' 4. Build the Forward Pass

DIM read_attrs AS MAP

read_attrs{"dtype"} = "DT_FLOAT"

W_val = TENSORFLOW.ADD_OPERATION(G, "ReadVariableOp", "read_W", [W], read_attrs)

B_val = TENSORFLOW.ADD_OPERATION(G, "ReadVariableOp", "read_B", [B], read_attrs)



' *** Use Mul instead of MatMul ***

MulOp = TENSORFLOW.ADD_OPERATION(G, "Mul", "mul", [X, W_val], empty_attrs)

Y = TENSORFLOW.ADD_OPERATION(G, "Add", "add", [MulOp, B_val], empty_attrs)



' 5. Build the Loss function

SubOp = TENSORFLOW.ADD_OPERATION(G, "Sub", "sub", [Y, Y_], empty_attrs)

SquareOp = TENSORFLOW.ADD_OPERATION(G, "Square", "square", [SubOp], empty_attrs)

DIM reduction_indices_data[2]: reduction_indices_data[0]=0: reduction_indices_data[1]=1

ReductionIndices = TENSORFLOW.CONSTANT(G, reduction_indices_data, "INT32", "reduction_indices")

Loss = TENSORFLOW.ADD_OPERATION(G, "Mean", "loss", [SquareOp, ReductionIndices], empty_attrs)



' Reshape the loss scalar to a [1] vector so we can read it as an array.

DIM reshape_shape[1] : reshape_shape[0] = 1

ShapeConst = TENSORFLOW.CONSTANT(G, reshape_shape, "INT32", "reshape_shape")

LossReshaped = TENSORFLOW.ADD_OPERATION(G, "Reshape", "loss_out", [Loss, ShapeConst], empty_attrs)



' 6. Get Gradients and define the Training Step

GradW_array = TENSORFLOW.ADD_GRADIENTS(G, Loss, [W])

GradB_array = TENSORFLOW.ADD_GRADIENTS(G, Loss, [B])



' No reshape needed for scalars

LearningRate = TENSORFLOW.CONSTANT(G, 0.001, "FLOAT", "learning_rate")



TrainW = TENSORFLOW.ADD_OPERATION(G, "ResourceApplyGradientDescent", "train_w", [W, LearningRate, GradW_array[0]], empty_attrs)

TrainB = TENSORFLOW.ADD_OPERATION(G, "ResourceApplyGradientDescent", "train_b", [B, LearningRate, GradB_array[0]], empty_attrs)



' 7. Explicit Variable Initialization

DIM W_init_data[1] : W_init_data[0] = 0.0

W_init_const = TENSORFLOW.CONSTANT(G, W_init_data, "FLOAT", "W_init_const")



DIM B_init_data[1] : B_init_data[0] = 0.0

B_init_const = TENSORFLOW.CONSTANT(G, B_init_data, "FLOAT", "B_init_const")



W_assign = TENSORFLOW.ADD_OPERATION(G, "AssignVariableOp", "W_assign", [W, W_init_const], empty_attrs)

B_assign = TENSORFLOW.ADD_OPERATION(G, "AssignVariableOp", "B_assign", [B, B_init_const], empty_attrs)

DIM init_attrs AS MAP

init_attrs{"control_inputs"} = [W_assign, B_assign]

InitOp = TENSORFLOW.ADD_OPERATION(G, "NoOp", "init", [], init_attrs)



' 8. Setup Session and Run Initializer

S = TENSORFLOW.NEW_SESSION(G)

TENSORFLOW.SESSION_RUN(S, G, {}, [], [InitOp])



' 9. Prepare full training data

PRINT "Preparing training data..."

DIM train_x[500,1]

DIM train_y[500,1]



FOR I = 1 TO 500
    train_x[I-1,0] = (I / 100.0) / 5.0
    train_y[I-1,0] = 3.0 * train_x[I-1,0] + 1.0
NEXT I




x_tensor = TENSORFLOW.NEW_TENSOR_FROM_ARRAY(train_x, "FLOAT")

y_tensor = TENSORFLOW.NEW_TENSOR_FROM_ARRAY(train_y, "FLOAT")



DIM feed_dict AS MAP

feed_dict{"X_input:0"} = x_tensor

feed_dict{"Y_label:0"} = y_tensor



' 10. Training Loop over epochs

PRINT "Starting training..."

DIM nodes_to_fetch[1]

nodes_to_fetch[0] = "loss_out:0"



FOR epoch = 1 TO 500

 ResultMap = TENSORFLOW.SESSION_RUN(S, G, feed_dict, nodes_to_fetch, [TrainW, TrainB])

 LossValue = TENSORFLOW.NEW_ARRAY_FROM_TENSOR(ResultMap{"loss_out:0"})

 PRINT "Loss after epoch "; epoch; " = "; LossValue[0]

NEXT epoch



PRINT "Training finished."

PRINT



' 11. Fetch and print the final learned weights

DIM nodes_to_fetch_final[2]

nodes_to_fetch_final[0] = "read_W:0"

nodes_to_fetch_final[1] = "read_B:0"



ResultMap = TENSORFLOW.SESSION_RUN(S, G, {}, nodes_to_fetch_final, [])



FinalW = TENSORFLOW.NEW_ARRAY_FROM_TENSOR(ResultMap{"read_W:0"})

FinalB = TENSORFLOW.NEW_ARRAY_FROM_TENSOR(ResultMap{"read_B:0"})



PRINT "Learned Weight (should be ~3.0): "; FinalW[0]

PRINT "Learned Bias (should be ~1.0): "; FinalB[0]

' --- End of File ---

' TensorFlow Integration Example
' Requires a model file "model.pb" in the same directory.

DLLIMPORT "tffunc"
PRINT "TensorFlow Version: "; TENSORFLOW.VERSION()

' 1. Create Graph and Session
GraphHandle = TENSORFLOW.NEW_GRAPH()
PRINT GraphHandle
IF NOT Typeof(GraphHandle) = "TF_GRAPH" THEN
  PRINT "Failed to create graph"
  END
ENDIF

' 2. Load the pre-trained model from a file
Success = TENSORFLOW.LOAD_GRAPH_FROM_FILE(GraphHandle, "model.pb")
IF Success = FALSE THEN
    PRINT "Failed to load model from file."
    END
ENDIF

SessionHandle = TENSORFLOW.NEW_SESSION(GraphHandle)

IF NOT Typeof(SessionHandle) = "TF_SESSION" THEN
  PRINT "Failed to create session"
  END
ENDIF

' 3. Prepare input data
DIM InputData[1, 4]  ' FIX: Define as a 1x4 matrix
InputData[0, 0] = 1.0
InputData[0, 1] = 2.0
InputData[0, 2] = 3.0
InputData[0, 3] = 4.0

InputTensor = TENSORFLOW.NEW_TENSOR_FROM_ARRAY(InputData)

' 4. Run Inference
DIM Inputs AS MAP
Inputs{"input:0"} = InputTensor

DIM Outputs[1]
Outputs[0] = "output:0"

ResultMap = TENSORFLOW.SESSION_RUN(SessionHandle, GraphHandle, Inputs, Outputs,[])

' 5. Process the results
IF TYPEOF(ResultMap) = "MAP" THEN
  ResultTensor = ResultMap{"output:0"}
  ResultArray = TENSORFLOW.NEW_ARRAY_FROM_TENSOR(ResultTensor)

  PRINT "Inference Result:"
  PRINT FRMV$(ResultArray)
ELSE
  PRINT "Inference failed."
ENDIF

' Handles for TF objects are managed by OpaqueHandle and will be
' automatically deleted when they go out of scope.
PRINT "Done."
' --- End of File ---


FUNC LongComputation(n)
    PRINT "Starting long computation in background..."
    total = 0
    FOR i = 1 TO n
        total = total + i
    NEXT i
    PRINT "Background computation finished."
    RETURN total
ENDFUNC

' --- Main Program ---
PRINT "Launching background thread..."
handle = THREAD LongComputation(10000)
PRINT "Main thread is continuing its work..."
PRINT "The handle is: "; handle

' Do other work here...
a = 1
DO WHILE NOT THREAD.ISDONE(handle)
    PRINT "Main thread waiting... a = "; a
    a = a + 1
    ' You could add a SLEEP here
LOOP

PRINT "Thread is done! Getting result..."
finalResult = THREAD.GETRESULT(handle)

PRINT "The final result from the thread is:"; finalResult
' --- End of File ---

' Comprehensive Test for TRY...CATCH...FINALLY

PRINT "--- TEST 1: Simple Error Catching ---"
TRY
    PRINT "Inside TRY block. An error is about to occur..."
    A = 10 / 0
    PRINT "This line should NOT be printed."
CATCH
    PRINT "SUCCESS: Caught the error!"
    PRINT "Error Code: "; ERR
    PRINT "Error Line: "; ERL
    PRINT "Error Message: "; ERRMSG$
ENDTRY
PRINT "Test 1 finished. Execution continued normally."
PRINT "-----------------------------------------"
PRINT

' ---

PRINT "--- TEST 2: No Error Occurs ---"
TRY
    PRINT "Inside TRY block. No error will occur here."
    A = 10 / 2
CATCH
    PRINT "FAILURE: This CATCH block should NOT run."
FINALLY
    PRINT "SUCCESS: FINALLY block ran, as expected."
ENDTRY
PRINT "Test 2 finished."
PRINT "-----------------------------------------"
PRINT

' ---

PRINT "--- TEST 3: Nested TRY...CATCH ---"
TRY
    PRINT "Outer TRY: Entering..."
    TRY
        PRINT "Inner TRY: Entering... about to cause an inner error."
        DIM B[1]
        B[5] = 10 ' Array out of bounds error
        PRINT "Inner TRY: This line should not be reached."
    CATCH
        PRINT "SUCCESS: Inner CATCH handled the error."
        PRINT "ERR: "; ERR; ", ERL: "; ERL
    ENDTRY
    PRINT "Outer TRY: Inner block finished. Now causing an outer error."
    C = 10 / 0 ' Division by zero
    PRINT "Outer TRY: This line should not be reached."
CATCH
    PRINT "SUCCESS: Outer CATCH handled the error."
    PRINT "ERR: "; ERR; ", ERL: "; ERL
ENDTRY
PRINT "Test 3 finished."
PRINT "-----------------------------------------"
PRINT

' ---

PRINT "--- TEST 4: Unhandled Error with FINALLY ---"
PRINT "The program should print the FINALLY message and then halt."
TRY
    PRINT "Inside TRY. An unhandled error is next."
    ' This error will not be caught, but FINALLY should still run.
    X = 1/0
FINALLY
    PRINT "SUCCESS: FINALLY block ran before program halted."
    END
ENDTRY
PRINT "FAILURE: This line should NEVER be printed."


' --- End of File ---

' ===============================================
' == jdBasic Turtle Graphics Demo (Animation-Ready)
' ===============================================

' --- 1. Initialization ---
SCREEN 800, 600, "Turtle Graphics Demo"

' --- 2. Draw a colored square (Static Drawing) ---
PRINT "Drawing a red square..."
TURTLE.CLEAR ' Ensure path is empty before starting a new drawing
TURTLE.SET_COLOR 255, 50, 50

FOR i = 1 TO 4
    TURTLE.FORWARD 100 ' This now just adds to the path memory
    TURTLE.RIGHT 90
NEXT i

CLS           ' Clear the screen buffer
TURTLE.DRAW   ' Render the entire path we just created
SCREENFLIP    ' Show the result
SLEEP 2000

' --- 3. Draw a star (Static Drawing) ---
PRINT "Drawing a star..."
TURTLE.CLEAR
TURTLE.PENUP
TURTLE.HOME
TURTLE.PENDOWN
TURTLE.SET_COLOR 200, 200, 255

FOR i = 1 TO 5
    TURTLE.FORWARD 150
    TURTLE.RIGHT 144
NEXT i

CLS
TURTLE.DRAW
SCREENFLIP
SLEEP 2000

' --- 4. Animate drawing a colorful spiral ---
PRINT "Animating a spiral..."
TURTLE.CLEAR
TURTLE.HOME
TURTLE.SETHEADING -90

FOR i = 1 TO 300
    ' --- Animation Loop ---

    ' a) Update State: Change color and move the turtle one step
    ' This adds ONE new segment to the turtle's path memory.
    r = (i * 20) MOD 255
    g = 255 - ((i * 10) MOD 255)
    b = 128
    TURTLE.SET_COLOR r, g, b
    TURTLE.FORWARD i * 0.5
    TURTLE.RIGHT 5

    ' b) Render Frame
    CLS           ' Clear the screen's backbuffer
    TURTLE.DRAW   ' Redraw the ENTIRE path, including the new segment
    SCREENFLIP    ' Show the updated frame

    ' c) Check for Quit and Delay
    IF INKEY$() = CHR$(27) THEN EXITFOR
    SLEEP 5 ' Short delay for smooth animation
NEXT i

PRINT "Demo complete. Press ESC to quit."
DO WHILE INKEY$() <> CHR$(27)
    SLEEP 20
LOOP
' --- End of File ---

' ===============================================
' == Dragon Curve Fractal in jdBasic
' ===============================================

SUB Update()
    CLS 10, 20, 30
    TURTLE.DRAW
    SCREENFLIP
    SLEEP 1
ENDSUB

' --- L-System Generation ---
AXIOM$ = "FX"
RULES = {}
RULES{"X"} = "X+YF+"
RULES{"Y"} = "-FX-Y"
GENERATIONS = 10 ' Be careful, >14 can be very slow!

PRINT "Generating Dragon Curve string..."
CURRENT_STRING$ = AXIOM$
FOR I = 1 TO GENERATIONS
    NEXT_STRING$ = ""
    FOR J = 1 TO LEN(CURRENT_STRING$)
        CHAR$ = MID$(CURRENT_STRING$, J, 1)
        IF MAP.EXISTS(RULES, CHAR$) THEN
            NEXT_STRING$ = NEXT_STRING$ + RULES{CHAR$}
        ELSE
            NEXT_STRING$ = NEXT_STRING$ + CHAR$
        ENDIF
    NEXT J
    CURRENT_STRING$ = NEXT_STRING$
NEXT I
PRINT "String generated with "; LEN(CURRENT_STRING$); " commands."
PRINT CURRENT_STRING$

' --- Main Drawing Program ---
SCREEN 1920, 1080, "Dragon Curve", 2
CLS 40, 10, 10 ' Dark red background

TURTLE.PENUP
TURTLE.SETPOS 300, 200
TURTLE.PENDOWN
TURTLE.SET_COLOR 255, 215, 0 ' Gold color

STEP_LENGTH = 4

PRINT "Drawing curve...Press ESC to quit."
' Interpret the final string as drawing commands
FOR I = 1 TO LEN(CURRENT_STRING$)
    CMD$ = MID$(CURRENT_STRING$, I, 1)
    IF CMD$ = "F" THEN
        TURTLE.FORWARD STEP_LENGTH
    ELSEIF CMD$ = "+" THEN
        TURTLE.RIGHT 90
    ELSEIF CMD$ = "-" THEN
        TURTLE.LEFT 90
    ENDIF
    Update
    IF INKEY$() = CHR$(27) THEN EXITFOR
NEXT I

PRINT "Dragon Curve drawing complete. Press ESC to quit."
DO WHILE INKEY$() <> CHR$(27)
    SLEEP 20
LOOP
' --- End of File ---

' ==========================================================
' == Fibonacci Spiral Fractal in jdBasic
' == Translated from a Python Turtle example.
' ==========================================================

' --- Configuration and Setup ---
' This factor scales the entire drawing up or down.

SUB Update()
    CLS 10, 20, 30
    TURTLE.DRAW
    SCREENFLIP
    SLEEP 200
ENDSUB

FACTOR = 5
SCREEN_W = 1920
SCREEN_H = 1080

' Initialize the graphics screen and sound (for fun)
SCREEN SCREEN_W, SCREEN_H, "jdBASIC Fibonacci Spiral"

N=12

IF N <= 1 THEN
    PRINT "Number of iterations must be > 1."
    END
ENDIF

' --- Main Drawing Logic ---
CLS 10, 20, 30 ' Clear screen to a dark background
TURTLE.HOME ' Start turtle in the center

' --- 1. Draw the Fibonacci Squares ---
' Initialize Fibonacci sequence variables
A = 0
B = 1
SQUARE_A = A
SQUARE_B = B

PRINT "Drawing squares..."
TURTLE.SET_COLOR 0, 100, 200 ' Set pen to blue for the squares

' Drawing the first square (size 1 * FACTOR)
TURTLE.FORWARD B * FACTOR
TURTLE.LEFT 90
TURTLE.FORWARD B * FACTOR
TURTLE.LEFT 90
TURTLE.FORWARD B * FACTOR
TURTLE.LEFT 90
TURTLE.FORWARD B * FACTOR

Update

' Update Fibonacci numbers for the next square
TEMP = SQUARE_B
SQUARE_B = SQUARE_B + SQUARE_A
SQUARE_A = TEMP

' Drawing the rest of the squares
FOR i = 1 TO N - 1
    TURTLE.BACKWARD SQUARE_A * FACTOR
    TURTLE.RIGHT 90
    TURTLE.FORWARD SQUARE_B * FACTOR
    TURTLE.LEFT 90
    TURTLE.FORWARD SQUARE_B * FACTOR
    TURTLE.LEFT 90
    TURTLE.FORWARD SQUARE_B * FACTOR

    ' Update Fibonacci numbers for the next square
    TEMP = SQUARE_B
    SQUARE_B = SQUARE_B + SQUARE_A
    SQUARE_A = TEMP
    Update
NEXT i

' --- 2. Draw the Spiral Arc ---
PRINT "Drawing spiral..."

' Lift pen and move to the starting point of the spiral.
' In jdBasic, SETPOS uses absolute screen coordinates, so we calculate
' the position relative to the center of the screen.
TURTLE.PENUP
TURTLE.SETPOS (SCREEN_W / 2) + FACTOR, (SCREEN_H / 2)
TURTLE.SETHEADING 0
TURTLE.PENDOWN

' Set pen to red for the spiral
TURTLE.SET_COLOR 255, 100, 80

' Reset Fibonacci numbers for the spiral calculation
A = 0
B = 1

' Draw a 90-degree arc for each Fibonacci number
TURTLE.LEFT 90
FOR i = 0 TO N - 1
    ' Calculate the length of the arc for this segment
    ARC_LENGTH = PI * B * FACTOR / 2
    
    ' The arc is drawn as 90 small straight lines
    STEP_LENGTH = ARC_LENGTH / 90
    
    FOR j = 1 TO 90
        TURTLE.FORWARD STEP_LENGTH
        TURTLE.LEFT 1
    NEXT j
    
    ' Update Fibonacci numbers for the next arc
    TEMP = A
    A = B
    B = TEMP + B
    Update
NEXT i

' --- 3. Finalize and Display ---
PRINT "Drawing complete."
TURTLE.PENUP
TURTLE.HOME

' Wait for user to press ESC to quit
PRINT "Press ESC to quit."
DO
    k$ = INKEY$()
    IF k$ = CHR$(27) THEN EXITDO
    SLEEP 20
LOOP
' --- End of File ---

' ===============================================
' == Recursive Fractal Tree in jdBasic
' ===============================================

SUB Update()
    CLS 10, 20, 30
    TURTLE.DRAW
    SCREENFLIP
    SLEEP 10
ENDSUB

SUB TREE(branch_len)
    ' Base Case: If the branch is too short, stop the recursion.
    IF branch_len < 3 THEN RETURN

    ' --- Draw the current branch ---
    ' Change color based on branch length for a nice effect
    IF branch_len > 50 THEN
        TURTLE.SET_COLOR 139, 69, 19 ' Brown for the trunk
    ELSE
        TURTLE.SET_COLOR 34, 139, 34 ' Green for the leaves
    ENDIF
    TURTLE.FORWARD branch_len

    ' --- Recursive Step ---
    ' 1. Turn left for the first sub-branch
    TURTLE.RIGHT 20
    TREE(branch_len * 0.7) ' Call self with a shorter branch

    ' 2. Turn right for the second sub-branch
    TURTLE.LEFT 40
    TREE(branch_len * 0.7) ' Call self again

    ' 3. Return to the starting point of this branch
    ' This is crucial for the other branches to draw correctly.
    TURTLE.RIGHT 20
    ' Set pen to brown to draw back down the branch
    TURTLE.SET_COLOR 139, 69, 19
    TURTLE.BACKWARD branch_len
    Update
ENDSUB


' --- Main Program ---
SCREEN 800, 600, "Fractal Tree"
CLS 135, 206, 250 ' Sky blue background

' Setup the turtle at the bottom of the screen
TURTLE.PENUP
TURTLE.SETPOS 400, 550
TURTLE.SETHEADING -90 ' Point straight up
TURTLE.PENDOWN

' Start the recursion with an initial branch length
TREE(100)

' Draw the final path and keep the window open
TURTLE.DRAW
SCREENFLIP
PRINT "Fractal Tree drawing complete. Press ESC to quit."
DO WHILE INKEY$() <> CHR$(27)
    SLEEP 20
LOOP
' --- End of File ---

' ===============================================
' == Koch Snowflake Fractal in jdBasic
' ===============================================
SUB Update()
    CLS 10, 20, 30
    TURTLE.DRAW
    SCREENFLIP
    SLEEP 10
ENDSUB

SUB KOCH(len)
    ' Base Case: If the segment is small enough, just draw a line.
    IF len < 4 THEN
        TURTLE.FORWARD len
        RETURN
    ENDIF

    ' Recursive Step: Replace the line with the Koch pattern
    KOCH(len / 3)
    TURTLE.LEFT 60
    KOCH(len / 3)
    TURTLE.RIGHT 120
    KOCH(len / 3)
    TURTLE.LEFT 60
    KOCH(len / 3)
    Update
ENDSUB

' --- Main Program ---
SCREEN 800, 800, "Koch Snowflake"
CLS 10, 20, 40 ' Dark blue background

TURTLE.SET_COLOR 220, 220, 255 ' Icy white/blue color

' Position the turtle to start the snowflake
TURTLE.PENUP
TURTLE.SETPOS 200, 450
TURTLE.PENDOWN

' A snowflake is made of three Koch curves forming a triangle
FOR i = 1 TO 3
    KOCH(400)
    TURTLE.RIGHT 120
NEXT i

' Draw the final path and keep window open
TURTLE.DRAW
SCREENFLIP
PRINT "Koch Snowflake drawing complete. Press ESC to quit."
DO WHILE INKEY$() <> CHR$(27)
    SLEEP 20
LOOP
' --- End of File ---

' jdBasic Lines and Dots (Vectorized)
' 1. Vars

SCREEN_W = 1920
SCREEN_H = 1080

SIZE = 500

FUNC RANDI(x,y)
    return rnd(1)
ENDFUNC

' 2. Initialize Graphics ---
PRINT "Initializing graphics screen..."
SCREEN SCREEN_W, SCREEN_H, "Lines (Vectorized)"
CLS 0, 0, 0 ' Clear screen to black

PRINT "Building line matrix..."
X = RESHAPE(OUTER([0],iota(SIZE),randi@)*SCREEN_W,[SIZE])
Y = RESHAPE(OUTER([0],iota(SIZE),randi@)*SCREEN_H,[SIZE])
X1  = RESHAPE(OUTER([0],iota(SIZE),randi@)*SCREEN_W,[SIZE])
Y1  = RESHAPE(OUTER([0],iota(SIZE),randi@)*SCREEN_H,[SIZE])
m = STACK(1,X,Y,X1,Y1)

PRINT "Building color matrix..."
r = RESHAPE(OUTER([0],iota(SIZE),randi@)*255,[SIZE])
g = RESHAPE(OUTER([0],iota(SIZE),randi@)*255,[SIZE])
b = RESHAPE(OUTER([0],iota(SIZE),randi@)*255,[SIZE])
c = STACK(1,r,g,b)

line m, c

SCREENFLIP

do
    SLEEP 100
    a$ = inkey$()
loop until a$ > ""

' --- End of File ---

' --- File Writer Demo ---
REPORT$ = "jdBasic File Report" + vbNewLine
REPORT$ = REPORT$ + "---------------------" + vbNewLine
REPORT$ = REPORT$ + "Date: " + DATE$() + vbNewLine
REPORT$ = REPORT$ + "Status: OK"

TXTWRITER "report.txt", REPORT$
PRINT "report.txt has been written with correct newlines."

' You can also use other constants we added, like PI
PRINT "The value of PI is: "; PI


PRINT "--- Testing CSVWRITER ---"
' --- Writing a CSV with a Header Row ---

PRINT "Preparing data and headers..."

' 1. Create the array of headers.
HEADERS = ["ID", "Value1", "Value2"]

' 2. Create the numeric data matrix.
DATA_MATRIX = RESHAPE(IOTA(12), [4, 3])
DATA_MATRIX = DATA_MATRIX * 1.1

' 3. Call CSVWRITER with all four arguments.
CSVWRITER "data_with_header.csv", DATA_MATRIX, ";", HEADERS

PRINT "File 'data_with_header.csv' has been written successfully!"

PRINT "File export test complete."


' --- Locale Formatting Demo ---

MY_NUMBER = 1234567.89

PRINT "Default 'C' Locale:"
PRINT MY_NUMBER
PRINT ""

' For Windows, locale names are "German", "French", etc.
' On Linux, they are often "de_DE.UTF-8", "fr_FR.UTF-8"
PRINT "Setting locale to German..."
SETLOCALE "German"

PRINT "German Locale:"
PRINT MY_NUMBER

' The CSVWRITER will now also use this format!
DATA = RESHAPE([PI, MY_NUMBER], [1, 2])
CSVWRITER "german_numbers.csv", DATA, ";"

PRINT "german_numbers.csv has been written."

' --- End of File ---

