' ===================================================================
' == Tic-Tac-Toe for jdBasic
' == by Gemini (Refactored)
' ===================================================================
'
' A complete, graphical Tic-Tac-Toe game with mouse controls,
' win/draw detection, and a persistent highscore system.
'
' --- CONTROLS ---
' - Click on a square to place your piece (X or O).
' - Click the "New Game" button to start a new round.
' - Press the ESC key to quit the game.
'
' -------------------------------------------------------------------

' ===================================================================
' 1. GLOBAL VARIABLES & CONSTANTS
' ===================================================================

' --- Game Board ---
' A 3x3 array representing the game board.
' 0 = Empty, 1 = Player X, 2 = Player O
DIM board[3, 3]

' --- Game State ---


' --- Graphics & UI ---
SCREEN_W = 600
SCREEN_H = 700
CELL_SIZE = 160
GRID_MARGIN = 60
GRID_SIZE = CELL_SIZE * 3
GRID_LINE_WIDTH = 10

' --- Files ---
HIGHSCORE_FILE$ = "tictactoe_scores.txt"


' ===================================================================
' 3. INITIALIZATION
' ===================================================================
' Resets the board and game state for a new round.
SUB StartNewRound()
    ' Reset the board to all zeros (empty) using RESHAPE
    board = RESHAPE([0], [3, 3])

    currentPlayer = 1 ' X always starts
    gameOver = FALSE
    winner = 0
ENDSUB

' Loads scores from the file. If the file doesn't exist, initializes scores to 0.
SUB LoadHighscores()
    ' Set default scores in case file doesn't exist or is invalid
    playerXScore = 0
    playerOScore = 0

    file_content$ = TXTREADER$(HIGHSCORE_FILE$)
    
    ' If the file is empty or couldn't be read, ERR will be non-zero
    IF ERR <> 0 THEN
        PRINT "Highscore file not found. Creating a new one."
        GOTO ende
    ENDIF

    lines = SPLIT(file_content$, CHR$(10)) ' Split by newline
    IF LEN(lines) >= 2 THEN
        playerXScore = VAL(lines[0])
        playerOScore = VAL(lines[1])
        PRINT "Highscores loaded successfully."
    ELSE
        PRINT "Highscore file is corrupt. Starting fresh."
    ENDIF
ende:
ENDSUB

' Initializes the entire game, including graphics and highscores.
SUB InitGame()
    SCREEN SCREEN_W, SCREEN_H, "jdBasic Tic-Tac-Toe"
    LoadHighscores()
    StartNewRound()
ENDSUB

' Saves the current scores to the file.
SUB SaveHighscores()
    ' Create a string with one score per line
    content_to_save$ = STR$(playerXScore) + CHR$(10) + STR$(playerOScore)
    TXTWRITER HIGHSCORE_FILE$, content_to_save$
    IF ERR <> 0 THEN
        PRINT "Error: Could not save highscores to file!"
    ENDIF
ENDSUB

' ===================================================================
' 4. MAIN GAME LOOP
' ===================================================================

SUB GameLoop()
    DO
        ' --- Step 1: Handle User Input ---
        HandleInput()

        ' --- Step 2: Draw Everything ---
        DrawGame()

        ' --- Step 3: Check for Quit Condition ---
        k$ = INKEY$()
        IF k$ <> "" AND ASC(k$) = 27 THEN ' 27 is ESC key
            EXITDO
        ENDIF

        ' --- Step 4: Small delay to be CPU-friendly ---
        SLEEP 16 ' Target ~60 FPS

    LOOP UNTIL FALSE ' Loop forever until EXITDO is called
ENDSUB


' ===================================================================
' 5. INPUT HANDLING
' ===================================================================

SUB HandleInput()
    ' We only care about the left mouse button click (button 1)
    IF MOUSEB(1) THEN
        mx = MOUSEX()
        my = MOUSEY()

        ' --- Check if the click is on the "New Game" button ---
        ' Button area: x=200, y=620, width=200, height=50
        IF mx >= 200 AND mx <= 400 AND my >= 620 AND my <= 670 THEN
            StartNewRound()
            SLEEP 200 ' Short delay to prevent double-clicking
            RETURN
        ENDIF

        ' --- If the game is over, don't process board clicks ---
        IF gameOver THEN RETURN

        ' --- Check if the click is within the grid boundaries ---
        IF mx >= GRID_MARGIN AND mx < (GRID_MARGIN + GRID_SIZE) AND my >= GRID_MARGIN AND my < (GRID_MARGIN + GRID_SIZE) THEN
            ' Convert mouse coordinates to grid cell indices
            col = (mx - GRID_MARGIN) / CELL_SIZE
            row = (my - GRID_MARGIN) / CELL_SIZE

            ' If the chosen cell is empty, make the move
            IF board[row, col] = 0 THEN
                board[row, col] = currentPlayer
                
                ' After the move, check for a winner or draw
                CheckForWinner()

                ' If the game is still going, switch players
                IF NOT gameOver THEN
                    IF currentPlayer = 1 THEN
                        currentPlayer = 2
                    ELSE
                        currentPlayer = 1
                    ENDIF
                ENDIF
            ENDIF
        ENDIF
        ' Add a small delay to debounce the mouse click
        SLEEP 200
    ENDIF
ENDSUB


' ===================================================================
' 6. GAME LOGIC
' ===================================================================

' Checks all win conditions and draw condition using array logic.
SUB CheckForWinner()
    ' --- Check Rows and Columns ---
    FOR i = 0 TO 2
        ' Check row i
        row_slice = SLICE(board, 0, i)
        IF row_slice[0] <> 0 AND ALL(row_slice = row_slice[0]) THEN
            winner = row_slice[0]
            GOTO WinnerFound
        ENDIF

        ' Check column i
        col_slice = SLICE(board, 1, i)
        IF col_slice[0] <> 0 AND ALL(col_slice = col_slice[0]) THEN
            winner = col_slice[0]
            GOTO WinnerFound
        ENDIF
    NEXT i

    ' --- Check Diagonals ---
    IF board[0, 0] <> 0 AND board[0, 0] = board[1, 1] AND board[1, 1] = board[2, 2] THEN
        winner = board[0, 0]
        GOTO WinnerFound
    ENDIF
    IF board[0, 2] <> 0 AND board[0, 2] = board[1, 1] AND board[1, 1] = board[2, 0] THEN
        winner = board[0, 2]
        GOTO WinnerFound
    ENDIF

    ' --- Check for a Draw ---
    ' A draw occurs if there is no winner and the board is full (no zeros).
    IF NOT ANY(board = 0) THEN
        winner = 3 ' Special value for a draw
        gameOver = TRUE
    ENDIF
    RETURN

WinnerFound:
    ' --- This block is executed only when a win is detected ---
    gameOver = TRUE
    IF winner = 1 THEN
        playerXScore = playerXScore + 1
    ELSE
        playerOScore = playerOScore + 1
    ENDIF
    SaveHighscores()
ENDSUB


' ===================================================================
' 7. DRAWING ROUTINES
' ===================================================================

' Main drawing sub, calls all other drawing helpers.
SUB DrawGame()
    CLS 20, 35, 50 ' Clear screen to a dark navy blue

    DrawGrid()
    DrawPieces()
    DrawUI()

    SCREENFLIP ' Show everything we've drawn
ENDSUB

' Draws the 3x3 grid lines.
SUB DrawGrid()
    ' Vertical Lines
    LINE GRID_MARGIN + CELL_SIZE, GRID_MARGIN, GRID_MARGIN + CELL_SIZE, GRID_MARGIN + GRID_SIZE, 150, 180, 200
    LINE GRID_MARGIN + 2 * CELL_SIZE, GRID_MARGIN, GRID_MARGIN + 2 * CELL_SIZE, GRID_MARGIN + GRID_SIZE, 150, 180, 200
    ' Horizontal Lines
    LINE GRID_MARGIN, GRID_MARGIN + CELL_SIZE, GRID_MARGIN + GRID_SIZE, GRID_MARGIN + CELL_SIZE, 150, 180, 200
    LINE GRID_MARGIN, GRID_MARGIN + 2 * CELL_SIZE, GRID_MARGIN + GRID_SIZE, GRID_MARGIN + 2 * CELL_SIZE, 150, 180, 200
ENDSUB

' Iterates through the board and draws the X's and O's.
SUB DrawPieces()
    PIECE_MARGIN = 30 ' Margin inside each cell for the shapes
    FOR r = 0 TO 2
        FOR c = 0 TO 2
            x_start = GRID_MARGIN + c * CELL_SIZE + PIECE_MARGIN
            y_start = GRID_MARGIN + r * CELL_SIZE + PIECE_MARGIN
            x_end = GRID_MARGIN + (c + 1) * CELL_SIZE - PIECE_MARGIN
            y_end = GRID_MARGIN + (r + 1) * CELL_SIZE - PIECE_MARGIN

            ' --- Draw 'X' for player 1 ---
            IF board[r, c] = 1 THEN
                ' Draw two thick lines for the X
                LINE x_start, y_start, x_end, y_end, 230, 80, 80
                LINE x_start, y_end, x_end, y_start, 230, 80, 80
            ENDIF

            ' --- Draw 'O' for player 2 ---
            IF board[r, c] = 2 THEN
                cx = GRID_MARGIN + c * CELL_SIZE + CELL_SIZE / 2
                cy = GRID_MARGIN + r * CELL_SIZE + CELL_SIZE / 2
                radius = (CELL_SIZE / 2) - PIECE_MARGIN
                CIRCLE cx, cy, radius, 80, 180, 230
            ENDIF
        NEXT c
    NEXT r
ENDSUB

' Draws all text, scores, and buttons.
SUB DrawUI()
    ' --- Draw Scores ---
    score_text$ = FORMAT$("Score: Player X [{:5d}]    -    Player O [{:5d}]", playerXScore, playerOScore)
    TEXT 10, 10, score_text$, 220, 220, 220
    ' --- Draw Status Message (Current Player or Winner) ---
    status_text$ = " "
    IF gameOver THEN
        IF winner = 1 THEN status_text$ = "Player X Wins!"
        IF winner = 2 THEN status_text$ = "Player O Wins!"
        IF winner = 3 THEN status_text$ = "It's a Draw!"
    ELSE
        IF currentPlayer = 1 THEN status_text$ = "Player X's Turn"
        IF currentPlayer = 2 THEN status_text$ = "Player O's Turn"
    ENDIF
    TEXT 180, 580, status_text$, 255, 255, 100 ' Bright yellow
    ' --- Draw "New Game" Button ---
    RECT 200, 620, 200, 50, 100, 120, 140, TRUE ' Button background
    RECT 200, 620, 200, 50, 200, 220, 240, FALSE ' Button border
    TEXT 255, 635, "New Game", 255, 255, 255
ENDSUB

' ===================================================================
' 2. MAIN PROGRAM FLOW (Execution starts here)
' ===================================================================
OPTION "NOPAUSE" ' Disable default ESC key behavior to handle it ourselves
InitGame()
GameLoop()
PRINT "Thanks for playing! Final scores saved."
